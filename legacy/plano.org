#+STARTUP: overview indent inlineimages logdrawer
#+TITLE:  Alfredo's MAC0110 Journal
#+AUTHOR:      Alfredo Goldman
#+LANGUAGE:    bt-br
#+TAGS: noexport(n) Stats(S)
#+TAGS: Teaching(T) R(R) OrgMode(O) Python(P)
#+TAGS: Book(b) Code(C) FPGA(F) Autotuning(A)
#+TAGS: ExportableReports(E)
#+TAGS: DataVis(v) PaperReview(W)
#+EXPORT_SELECT_TAGS: Blog
#+OPTIONS:   H:3 num:t toc:nil \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+COLUMNS: %25ITEM %TODO %3PRIORITY %TAGS
#+SEQ_TODO: TODO(t!) STARTED(s!) WAITING(w@) APPT(a!) | DONE(d!) CANCELLED(c!) DEFERRED(f!)

#+LATEX_CLASS_OPTIONS: [a4paper]
#+LATEX_HEADER: \usepackage[margin=2cm]{geometry}
#+LATEX_HEADER: \usepackage{amsmath,amsfonts,amssymb,amsthm}
#+LATEX_HEADER: \usepackage{sourcecodepro}
#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+LATEX_HEADER: \usepackage{booktabs}
#+LATEX_HEADER: \usepackage{array}
#+LATEX_HEADER: \usepackage{colortbl}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \usepackage{algpseudocode}
#+LATEX_HEADER: \usepackage{algorithm}
#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \usepackage[english]{babel}
#+LATEX_HEADER: \usepackage[scale=2]{ccicons}
#+LATEX_HEADER: \usepackage{hyperref}
#+LATEX_HEADER: \usepackage{relsize}
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{bm}
#+LATEX_HEADER: \usepackage{amsfonts}
#+LATEX_HEADER: \usepackage{wasysym}
#+LATEX_HEADER: \usepackage{float}
#+LATEX_HEADER: \usepackage{ragged2e}
#+LATEX_HEADER: \usepackage{textcomp}
#+LATEX_HEADER: \usepackage{pgfplots}
#+LATEX_HEADER: \usepackage{todonotes}
#+LATEX_HEADER: \usepgfplotslibrary{dateplot}
#+LATEX_HEADER: \lstdefinelanguage{ein-julia}%
#+LATEX_HEADER:   {morekeywords={abstract,struct,break,case,catch,const,continue,do,else,elseif,%
#+LATEX_HEADER:       end,export,false,for,function,immutable,mutable,using,import,importall,if,in,%
#+LATEX_HEADER:       macro,module,quote,return,switch,true,try,catch,type,typealias,%
#+LATEX_HEADER:       while,<:,+,-,::,/},%
#+LATEX_HEADER:    sensitive=true,%
#+LATEX_HEADER:    alsoother={$},%
#+LATEX_HEADER:    morecomment=[l]\#,%
#+LATEX_HEADER:    morecomment=[n]{\#=}{=\#},%
#+LATEX_HEADER:    morestring=[s]{"}{"},%
#+LATEX_HEADER:    morestring=[m]{'}{'},%
#+LATEX_HEADER: }[keywords,comments,strings]%
#+LATEX_HEADER: \lstset{ %
#+LATEX_HEADER:   backgroundcolor={},
#+LATEX_HEADER:   basicstyle=\ttfamily\scriptsize,
#+LATEX_HEADER:   breakatwhitespace=true,
#+LATEX_HEADER:   breaklines=true,
#+LATEX_HEADER:   captionpos=n,
# #+LATEX_HEADER:   escapeinside={\%*}{*)},
#+LATEX_HEADER:   extendedchars=true,
#+LATEX_HEADER:   frame=n,
#+LATEX_HEADER:   language=R,
#+LATEX_HEADER:   rulecolor=\color{black},
#+LATEX_HEADER:   showspaces=false,
#+LATEX_HEADER:   showstringspaces=false,
#+LATEX_HEADER:   showtabs=false,
#+LATEX_HEADER:   stepnumber=2,
#+LATEX_HEADER:   stringstyle=\color{gray},
#+LATEX_HEADER:   tabsize=2,
#+LATEX_HEADER: }
#+LATEX_HEADER: \renewcommand*{\UrlFont}{\ttfamily\smaller\relax}

* Programa do curso
** Aula 01 - [2020-03-02 seg]
Objetivo da aula: Dar uma ideia geral do que vai acontecer no semestre
*** Vis√£o Geral do Curso
- Vamos come√ßar em um ambiente amig√°vel: Julia e Jupyter
- Em seguida vamos passar para linha de comando
  - Sim, compila√ß√£o tem que ser expl√≠cita
- Ap√≥s ver os primeiros programas em Julia
- Sim vamos ver outro paradigma: o funcional com Haskel
- Isso tudo cobrindo o conte√∫do do curso
  - Sem esquecer controle de vers√£o e testes automatizados
*** Conhecendo um pouco a classe
  No curso vamos usar o [[https://www.mentimeter.com][Menti]] uma ferramenta para pesquisas an√¥nimas. N√£o tenha medo voc√™ n√£o ser√° identificado!
  Vamos come√ßar:
 - Primeira Consulta:
    Quem j√° sabe programar?
 - Segunda Consulta:
    Qual a sua linguagem preferida?
 - Terceira Consulta:
    Qual o seu objetivo daqui a quatro anos?
*** Entendendo a necessidade de termos uma linguagem de programa√ß√£o
  Vou precisar de dois volunt√°rios
  - Descrever como fritar um ovo para um extraterrestre?
  - Descrever escovar os dentes para um homem pr√© hist√≥rico?
  Para os dois casos, vamos abstrair que a linguagem falada e/ou escrita seja um problema.
  Exemplo popular (gera√ß√£o youtube): [[https://www.youtube.com/watch?v=Ct-lOOUqmyY][Como passar manteiga de amendoim]]
  Uma linguagem √© uma forma de se expressar:
  - Dados (n√∫meros, letras, etc)
  - Procedimentos (formas de manipular dados)
  S√≥ lembrando procedimentos tamb√©m podem ser dados :)
*** L√≥gica de programa√ß√£o √© uma coisa natural
 Vamos ver um exemplo da Internet, conhecido como teste de Einsten, vou pegar
a formula√ß√£o do s√≠tio [[https:://www.geniol.com.br/logica/problemas/teste-de-einstein/][Geniol]]
*** O curso em si
- Exerc√≠cios Programa
- Mini Exerc√≠cios Programa (corre√ß√£o bin√°ria)
- Provas
Programar √© como andar de bicileta, s√≥ se aprende programando!
Pl√°gio √© inaceit√°vel, com puni√ß√µes severas

Recomenda-se fortemente que os alunos usem um ambiente baseado em Linux!
Programadores raiz usam linha de comando!

Linguagem: Vamos come√ßar com Julia em um ambiente amig√°vel, o Jupyter

O meu objetivo com o curso √© que voc√™s aprendam ao final:
- Princ√≠pios b√°sicos de algoritmos (ementa do curso)
- Controle de vers√µes com o Git
- No√ß√µes de como programar em diferentes linguagens
  - A linguagem √© apenas a ferramenta!
- Testes automatizados

Se voc√™ est√° ansioso √© j√° quer come√ßar a ver algum material, tem dois livros
dispon√≠veis: o de [[https://benlauwens.github.io/ThinkJulia.jl/latest/book.html][Julia]] e o de [[https://sttp.site/][Testes]].
** Aula 02 - [2020-03-04 qua]
Objetivo da aula ter uma vis√£o geral da evolu√ß√£o do Hardware e das linguagens de programa√ß√£o
*** Hist√≥ria da Computa√ß√£o
   Slides do Pedro
*** Prepara√ß√£o para a pr√≥xima aula
Pode ser √∫til j√° ter o ambiente de desenvolvimento com Julia instalado.
**** TODO Falar mais sobre Linux?
:LOGBOOK:
- State "TODO"       from              [2020-02-21 Fri 14:59]
:END:
** Aula 03 -[2020-03-09 seg]
Objetivo: Ver o interpretador de Julia como uma calculadora poderosa, introduzir a no√ß√£o de vari√°veis
*** Come√ßando com o modo interativo do Julia.
Quem quiser j√° pode instalar o ambiente de programa√ß√£o, usem esse [[https://julialang.org/][link]]

Dentro do Julia (ap√≥s chamar julia na linha de comando), vamos come√ßar com n√∫meros inteiros:
#+NAME: 12228cf8-4dae-4454-8494-6e712c891426
#+begin_SRC ein-julia :results output :session localhost :async yes
1 + 2
#+end_SRC

#+RESULTS: 12228cf8-4dae-4454-8494-6e712c891426
: 3

#+RESULTS:
: 3

#+begin_SRC ein-julia :results output :session localhost :async yes
40 * 3
#+end_SRC

#+RESULTS:
: 120

#+begin_SRC ein-julia :results output :session localhost :async yes
84 / 2
#+end_SRC
Notem que nesse caso, houve uma mudan√ßa de tipos, pois 84 e 2 s√£o inteiros e o resultado
√© um n√∫mero em ponto flutuante (float)
#+RESULTS:
: 42.0

Tamb√©m √© poss√≠vel pedir o resultado inteiro usando o operador div:
#+begin_SRC ein-julia :results output :session localhost :async yes
div(84,2)
#+end_SRC

#+RESULTS:
: 42

Tamb√©m d√° para fazer a exponencia√ß√£o:

#+begin_SRC ein-julia :results output :session localhost :async yes
2^31
#+end_SRC

#+RESULTS:
: 2147483648
 Express√µes mais complexas tamb√©m podem ser calculadas:

 #+begin_SRC ein-julia :results output :session localhost :async yes
23 + 2 * 2 + 3 * 4
 #+end_SRC

 #+RESULTS:
 : 39
 Sim, a preced√™ncia de operadores usual tamb√©m √© v√°lida em Julia. Mas, ai
vem a primeira li√ß√£o de programa√ß√£o: * Escreva para humanos, n√£o para m√°quinas *

 #+begin_SRC ein-julia :results output :session localhost :async yes
23 + (2 * 2) + (3 * 4)
 #+end_SRC

Em julia tamb√©m podemos fazer opera√ß√µes com n√∫meros em ponto flutuante:

#+begin_SRC ein-julia :results output :session py :async yes
23.5 * 3.14
#+end_SRC

#+RESULTS:
: 73.79

ou
#+begin_SRC ein-julia :results output :session localhost :async yes
12.5 / 2.0
#+end_SRC

#+RESULTS:
: 6.25

Acima temos mais um exemplo de c√≥digo escrito para pessoas, ao se escrever
2.0 estamos deixando claro que o segundo par√¢metro √© um n√∫mero float.

√â importante saber que n√∫meros em ponto flutuante tem precis√£o limitada, logo n√£o se espante com resultados inesperados como abaixo:

#+NAME: 62234de1-001d-4390-97af-e5ad203ac125
#+begin_SRC ein-julia :results output :session localhost
1.2 - 1.0
#+end_SRC

#+RESULTS: 62234de1-001d-4390-97af-e5ad203ac125
: [....]

ou
#+NAME: a9808540-b252-4b3e-80cf-f65127b343f5
#+begin_SRC ein-julia :results output :session localhost
0.1 + 0.2
#+end_SRC

#+RESULTS: a9808540-b252-4b3e-80cf-f65127b343f5
: [....]

ou ainda

#+NAME: e02fa7e7-b7b7-405c-9b89-fdb8f370bbb1
#+begin_SRC ein-julia :results output :session localhost
10e15 + 1 - 10e15
#+end_SRC

#+RESULTS: e02fa7e7-b7b7-405c-9b89-fdb8f370bbb1
: 0.0

Um outro operador interessante √© o % que faz o resto da divis√£o

#+NAME: 4e403942-5d45-473a-90be-9b02690bbb25
#+begin_SRC ein-julia :results output :session localhost
4 % 3
#+end_SRC

#+RESULTS: 4e403942-5d45-473a-90be-9b02690bbb25
: 1

*** Vari√°veis e seus tipos
Em Julia tamb√©m temos o conceito de vari√°veis, que servem para armazenar os
diferentes conte√∫dos de dados poss√≠veis.

#+NAME: 0571e6f9-2ce1-4e7f-b0ae-408686fe4fb2
#+begin_SRC ein-julia :results output :session localhost :async yes
a = 7
2 + a
#+end_SRC

#+RESULTS: 0571e6f9-2ce1-4e7f-b0ae-408686fe4fb2
: 9

√â importante notar que as vari√°veis em Julia podem receber novos valores e o tipo
da vari√°vel depende do que foi atrubu√≠do inicialmente.

#+NAME: 7f85f7ed-67f8-44e7-bd41-a5e59e70f3f8
#+begin_SRC ein-julia :results output :session localhost :async
a = 3
a = a + 1
typeof(a)
#+end_SRC

#+RESULTS: 7f85f7ed-67f8-44e7-bd41-a5e59e70f3f8
: Int64

Aproveitando o momento, podemos ver que h√° v√°rios tipos primitivos em Julia, sendo os
principais:

#+NAME: c715ca40-1dbb-46af-811f-e4432ae8ac0f
#+begin_SRC ein-julia :results output :session localhost :async yes :exports both
typeof(1)
typeof(1.1)
typeof("Bom dia")
#+end_SRC

#+RESULTS: c715ca40-1dbb-46af-811f-e4432ae8ac0f
: String

Falando em strings, elas s√£o definidas por conjuntos de caracteres entre aspas como:
#+NAME: 573261b3-3e9a-43f6-ae48-3e8eb6cb86bb
#+begin_SRC ein-julia :results output :session localhost
s1 = "Olha que legal"
s2 = "Outra String"
#+end_SRC

#+RESULTS: 573261b3-3e9a-43f6-ae48-3e8eb6cb86bb
: "Outra String"

D√° tamb√©m para fazer opera√ß√µes como strings como concatena√ß√£o:

#+NAME: 60e75287-87fb-47e0-bc02-d56dc5cddde9
#+begin_SRC ein-julia :results output :session localhost
s1 = "Tenha um"
s2 = " Bom dia"
s3 = s1 * s2
#+end_SRC

#+RESULTS: 60e75287-87fb-47e0-bc02-d56dc5cddde9
: "Tenha um Bom dia"

Ou pot√™ncia:

#+NAME: aa619a34-1c8d-4636-a7b5-2ae7bb8681ef
#+begin_SRC ein-julia :results output :session localhost
s = "Nao vou mais fazer coisas que possam desagradar os meus colegas"
s ^ 10
#+end_SRC

#+RESULTS: aa619a34-1c8d-4636-a7b5-2ae7bb8681ef
: [....]

Ainda sobre vari√°veis, h√° umas regras com rela√ß√£o aos seus nomes, tem que
come√ßar com uma letra, pode ter d√≠gitos e n√£o pode ser uma palavra reservada.  √â
bom notar que Julia por ser uma linguagem moderna, aceita nomes de caracteres em
unicode, pode exemplo

#+begin_SRC ein-julia :results output :async yes
\delta = 2  # Para se fazer o delta, deve se digitar \ seguido de delta, seguido de <tab>
#+end_SRC
*** Sa√≠da de dados
Para fazer sa√≠das usam-se dois comandos, print() e o println(), sendo que o primeiro n√£o pula linha e o segundo pula.
#+NAME: cab1bf67-75d1-441d-a756-7c1b1a3220de
#+begin_SRC ein-julia :results output :session localhost :async yes
print("Hello ")
println("World!")
println("Ola, mundo!")
#+end_SRC

#+RESULTS: cab1bf67-75d1-441d-a756-7c1b1a3220de

Para evitar que se digitem muitos caracteres, por vezes podemos usar "a√ßucares sint√°ticos".

#+NAME: af7bbe44-209e-46a6-9b53-4cf52ccf8533
#+begin_SRC ein-julia :results output :session localhost
x = 1
x = x + 1
x += 1  # forma equivalente a acima
#+end_SRC

#+RESULTS: af7bbe44-209e-46a6-9b53-4cf52ccf8533
: 3

** Aula 04 -[2020-03-11 qua]
  Objetivo: Come√ßar a entender como funcionam as fun√ß√µes
*** O uso de fun√ß√µes √© uma abstra√ß√£o natural
Na aula passada j√° vimos umas fun√ß√µes e isso foi bem natural, foram elas:
- typeof() - Que dado um par√¢metro devolve o seu tipo
- div() - Que dados dois par√¢metros devolve a divis√£o inteira do primeiro pelo segundo
- print() e println() - Que dados diversos par√¢metros os imprime, sem devolver nada
Inclusive, aqui vale a pena ver que podemos pedir ajuda ao Julia para saber o que fazem as
fun√ß√µes. Para isso, se usa o ? antes da fun√ß√£o:
#+NAME: 1d02325a-f2a1-4175-8903-f509560cc245
#+begin_SRC ein-julia :results output :session localhost :async yes
?typeof()
?div()
?print()
#+end_SRC

#+RESULTS: 1d02325a-f2a1-4175-8903-f509560cc245
:
:
:   No documentation found.
:
:   Binding [36mtypeof() ?div() ?print()[39m does not exist.

Ao fazer isso, inclusive descobrimos que o div() pode ser usado tamb√©m como \div.

Uma outra fun√ß√£o bem √∫til √© a que permite transformar um tipo de valor em outro.

#+NAME: 91a6eaca-2a85-4d05-a699-3707ce5c2a8f
#+begin_SRC ein-julia :results output :session localhost
parse(Float64, "32")
#+end_SRC

#+RESULTS: 91a6eaca-2a85-4d05-a699-3707ce5c2a8f
: 32.0

Para convers√£o de valores em ponto flutuante para inteiros, temos a fun√ß√£o trunc.

#+NAME: a2c1f3da-d8f1-4d85-9d34-47113b32d716
#+begin_SRC ein-julia :results output :session localhost
trunc(Int64, 2.25)
#+end_SRC

#+RESULTS: a2c1f3da-d8f1-4d85-9d34-47113b32d716
: 2

De forma inversa temos o float.

#+NAME: 7810375a-7fd9-4fb3-bc89-6e02b3464f4c
#+begin_SRC ein-julia :results output :session localhost
float(2)
#+end_SRC

#+RESULTS: 7810375a-7fd9-4fb3-bc89-6e02b3464f4c
: 2.0

Finalmente, podemos transformar um valor em uma string, como em:

#+NAME: 1a904e1c-4613-4bb1-a574-2a2017aadfbc
#+begin_SRC ein-julia :results output :session localhost
string(3)
#+end_SRC

#+RESULTS: 1a904e1c-4613-4bb1-a574-2a2017aadfbc
: "3"
ou
#+NAME: 3a4b773d-d0c1-425d-8681-65c88a759726
#+begin_SRC ein-julia :results output :session localhost
string(3.57)
#+end_SRC

#+RESULTS: 3a4b773d-d0c1-425d-8681-65c88a759726
: "3.57"

Tamb√©m tem muitas fun√ß√µes matem√°ticas prontas como
- sin(x) - calcula  seno de x em radianos
- cos(x)
- tan(x)
- deg2rad(x) - converte x de graus em radianos
- rad2deg(x)
- log(x) - calcula o logar√≠tmo natural de x
- log(x, b) - calcula o logar√≠tmo de x na base b
- log2(x) - calcula o logar√≠tmo de x na base 2
- log10(x)
- exp(x) - calcula o expoente da base natural de x
- abs(x) - calcula o m√≥dulo de x
- sqrt(x) - calcula a raiz quadrada
- isqrt(x) - calcula a raiz quadrada inteira de x
- cbrt(x) - raiz c√∫bica de x
- factorial(x) - calcula o fatorial de x

Em julia tamb√©m √© poss√≠vel criar fun√ß√µes conforme as suas necessidades, como abaixo:
#+NAME: 8f733746-e1b4-4a37-92b3-ae495090f020
#+begin_SRC ein-julia :results output :session localhost
function mensagemDeBomDia()
   println("Tenha um bom dia!")
end
#+end_SRC

#+RESULTS: 8f733746-e1b4-4a37-92b3-ae495090f020
: mensagemDeBomDia (generic function with 1 method)

Para usar uma fun√ß√£o, basta cham√°-la:

#+NAME: 5a983c1d-fbec-4f99-978a-7187dcb44a30
#+begin_SRC ein-julia :results output :session localhost
MensagemDeBomDia()
#+end_SRC

#+RESULTS: 5a983c1d-fbec-4f99-978a-7187dcb44a30


Fun√ß√µes, podem receber um ou mais par√¢metros:

#+NAME: aa31a96d-c645-4598-9502-b97640374f82
#+begin_SRC ein-julia :results value :session localhost
function imprime(a)
   println(" Vou imprimir ", a)
end
imprime(42)
#+end_SRC

#+RESULTS: aa31a96d-c645-4598-9502-b97640374f82

Tamb√©m √© poss√≠vel que uma fun√ß√£o chame outra fun√ß√µa como em:

#+NAME: fab1fb94-6596-4001-94c4-1dad607e9546
#+begin_SRC ein-julia :results output :session localhost
function imprimeduasvezes(a)
   imprime(a)
   imprime(a)
end
imprimeduasvezes(13)
#+end_SRC

#+RESULTS: fab1fb94-6596-4001-94c4-1dad607e9546
O n√∫mero de par√¢metros determina qual a fun√ß√£o correta deve ser chamada:
#+NAME: b0af26b3-0aba-4247-a13b-5ff581119f84
#+begin_SRC ein-julia :results output :session localhost
function recebe(a)
  println("Recebi um parametro: ", a)
end
function recebe(a, b)
  println("Recebi dois parametros: ", a, " ", b)
end

#+end_SRC

#+RESULTS: b0af26b3-0aba-4247-a13b-5ff581119f84
: recebe (generic function with 2 methods)

Conforme a chamada, a fun√ß√£o chamada ser√° diferente:

#+NAME: e828de2d-ece2-4d0a-b88b-abbbe5b2a701
#+begin_SRC ein-julia :results output :session localhost
recebe(1)
recebe(1, 2)
#+end_SRC

#+RESULTS: e828de2d-ece2-4d0a-b88b-abbbe5b2a701
Tamb√©m d√° para chamar fun√ß√µes com vari√°veis e com opera√ß√µes, como
em:

#+NAME: 89cea054-ece5-40d7-ac31-a652f461d94b
#+begin_SRC ein-julia :results output :session localhost
a = 10
recebe(a)
recebe(a, a + 1)

#+end_SRC

#+RESULTS: 89cea054-ece5-40d7-ac31-a652f461d94b

As fun√ß√µes que vimos at√© agora imprimem mensagens, mas n√£o devolvem nada.
O typeof() delas √© nothing, ou seja, algo que n√£o pode ser atribu√≠do.

Mas, tamb√©m √© poss√≠vel fazer fun√ß√µes que devolvem valores, como:

#+begin_SRC ein-julia :results output :session localhost
function soma1(a)
  return a + 1
end
#+end_SRC

Nesse caso, se for passado um par√¢metro num√©rico, a fun√ß√£o devolver√° o valor incrementado (adicionado de 1).

Claro que isso pode ser usado com f√≥rmulas mais complicadas como:

#+begin_SRC ein-julia :results output :session localhost
function hipotenusa(a, b)
  hip = a * a + b * b
  return hip
end
#+end_SRC
ou para a verifica√ß√£o de f√≥rmulas, como rela√ß√µes trogonom√©tricas:
#+begin_SRC ein-julia :results output :session localhost
function verificaequacao(x)
  soma = sin(x)^2 + cos(x)^2
  return soma == 1.0
end
#+end_SRC
** Aula 05 - <2020-03-16 seg>
  Nessa aula, em meio ao caos de uma pandemia mundial, vamos aprender um novo comando.
O desvio condicional, atrav√©s dele √© poss√≠vel alterar o fluxo de execu√ß√£o de um programa. At√© o
momento n√£o t√≠nhamos comentado isso explicitamente, mas a ordem de execu√ß√£o de instru√ß√µes segue
a ordem em que elas est√£o. Vejamos o exemplo abaixo:
#+NAME: cdbb133a-e6e7-4d78-bd70-8d7d41b5a949
#+begin_SRC ein-julia :results output :session localhost
println("Oi")
println("um")
println("dois")
#+end_SRC

#+RESULTS: cdbb133a-e6e7-4d78-bd70-8d7d41b5a949
: [....]

A ordem de impress√£o ser√° Oi, um e dois.

Da mesma forma n√£o temos problema ao executar o c√≥digo abaixo.

#+NAME: e03586b7-6414-4a10-b43a-fd5345210d51
#+begin_SRC ein-julia :results output :session localhost
denominador = 0
denominador += 2
30 / denominador
#+end_SRC

#+RESULTS: e03586b7-6414-4a10-b43a-fd5345210d51
: [....]

Apesar da vari√°vel denominador come√ßar inicialmente com 0, antes de se fazer a
divis√£o, ela estar√° valendo 2.

Como √© de se esperar nem sempre queremos que essa ordem seja respeitada. Observe
o seguinte exemplo:

#+NAME: c8e3e174-d6fa-4175-a0ef-b572509afd3e
#+begin_SRC ein-julia :results output :session localhost
pandemia = true
println("Vou sair de casa?")
if pandemia == true
   println("S√≥ vou sair de casa se for essencial")
end

#+end_SRC

#+RESULTS: c8e3e174-d6fa-4175-a0ef-b572509afd3e
: [....]
 O exemplo acima √© claro, se uma condi√ß√£o for verdadeira, o c√≥digo que
 est√° no escopo do if (isso √© entre a condi√ß√£o e o end) ser√° executado.

 Um outro exemplo:

 #+NAME: b7a9a3c7-cf10-41dc-9405-64e688e3d89a
 #+begin_SRC ein-julia :results output :session localhost
denominador = 0
if denominador != 0
   println("sei fazer a divis√£o se n√£o for por zero")
   println("o resultado da divis√£o de 30 por ", denominador, " √© igual a ", 30/denominador)
end


 #+end_SRC

 #+RESULTS: b7a9a3c7-cf10-41dc-9405-64e688e3d89a
 : [....]

 Situa√ß√µes muito comuns em computa√ß√£o devem ser favorecidas pela linguagem, nesse
caso do if, √© muito comum termos duas ou mais situa√ß√µes. Nesse sentido em Julia podemos
tamb√©m ter alternativas como abaixo:

 #+NAME: b363cb59-d5d8-449b-8474-f325b3b48db2
 #+begin_SRC ein-julia :results output :session localhost
pandemia = true
println("Vou sair de casa?")
if pandemia == true
   println("S√≥ vou sair de casa se for essencial")
else
   println("Balada liberada")
end
 #+end_SRC

 #+RESULTS: b363cb59-d5d8-449b-8474-f325b3b48db2

No caso de termos mais de uma altenativa, n√£o basta termos s√≥ uma condi√ß√£o,
nesse caso temos que usar elseif.

#+NAME: 2fa54533-0cf8-4cb4-b251-434a024649f1
#+begin_SRC ein-julia :results output :session localhost
pandemia = true
tenhoqueestudar = false
println("Vou sair de casa?")
if pandemia == true
   println("S√≥ vou sair de casa se for essencial")
elseif tenhoqueestudar == true
   println("Melhor ficar em casa")
else
   println("Balada liberada")
end
#+end_SRC

#+RESULTS: 2fa54533-0cf8-4cb4-b251-434a024649f1
: [....]

 Conhecendo o if, agora, escreva uma fun√ß√£o que recebe os coeficientes, a, b e c de uma
equa√ß√£o de segundo grau e imprime as suas ra√≠zes reais.

 Espa√ßo para a solu√ß√£o aqui :)

 Vamos agora a parte mais importante da aula, lembrando que at√© o momento aprendemos:
**** valores
**** var√≠aveis e alguns dos seus tipos
**** Alguma fun√ß√µes j√° prontas como div(), typeof(), parse(), string(), println(), etc
**** como fazer as nossas fun√ß√µes com a palavra reservada function e que termina por end
***** lembrando que a fun√ß√£o pode ou n√£o devolver algo atrav√©s do return
***** lembrando tamb√©m que uma fun√ß√£o pode chamar outra fun√ß√£o
**** como mudar o fluxo de execu√ß√£o normal com o if, elseif


Mas, agora vem a d√∫vida, uma fun√ß√£o pode se chamar?

#+NAME: e3d35c28-d40a-4ce2-aac4-8bee3537ac95
#+begin_SRC ein-julia :results output :session localhost
function imprime()
  println("Mensagem")
  imprime()
end
#+end_SRC

#+RESULTS: e3d35c28-d40a-4ce2-aac4-8bee3537ac95
: [....]

O resultado da fun√ß√£o √© curioso, ela vai ficar se chamando at√© uma mem√≥ria do computador
acabar (para quem conhece √© a pilha ou stack). Mas, ser√° que podemos usar isso de forma
mais inteligente ao nosso favor? Isso √©, em algum momento a fun√ß√£o teria que parar de se chamar
de forma a n√£o acabar com erro.

Uma forma de se fazer isso √© atrav√©s de um comando como o if, que pode ou n√£o seguir
chamando a fun√ß√£o, mas para isso vamos precisar receber um par√¢metro.

#+begin_SRC ein-julia :results output :session localhost
function countdown(n)
  println(n)
  if n > 0
    countdown(n-1)
  else
    println("Acabou")
  end
end
countdown(10)
#+end_SRC
 Para entender um pouco melhor o que acontece acima, vamos colocar mais umas
impress√µes.

 #+begin_SRC ein-julia :results output :session localhost
function countdown(n)
  println(n)
  if n > 0
    println("Vou chamar countdown com n = ", n - 1)
    countdown(n-1)
    println("Voltei da chamada com n = ", n - 1)
  else
    println("Acabou")
  end
end
countdown(10)
 #+end_SRC

Observando a sequ√™ncia de chamadas, fica claro como funciona o computador, de alguma forma,
cada uma das chamadas √© empilhada (colocada em um estrutura como uma pilha, de livros, mas
no caso de chamadas de fun√ß√£o), sendo que no final s√£o desempilhadas.

Vou desenhar para o caso countdown(5).

Essa estrutura √© bem poderosa, pois permite que opera√ß√µes sejam executadas um n√∫mero controlado de vezes.
Voltando ao countdown, imagine que ao inv√©s de imprimir uma mensagem quis√©ssemos fazer uma conta com o que ser√°
devolvido.

#+begin_SRC ein-julia :results output :session localhost
function soma(n)
  if n > 0
    return n + soma(n - 1)
  else
    return 1
  end
end
soma(10)
#+end_SRC

 Essa estrutura √© bastante poderosa e pode ser usada para o c√°lculo de produto, nesse
caso, a mudan√ßa √© bem pequena.

Da mesma forma segue um exemplo para o c√°lculo dos n primeiros elementos da soma
h√¢rmonica.

#+NAME: cde2230d-c34c-424c-85cf-38b66e823af3
#+begin_SRC ein-julia :results output :session localhost
function somaharmonica(atual, n)
  if atual >= n
    return 1.0 / atual
  else
    return 1.0 / atual + somaharmonica(atual + 1, n)
  end
end
somaharmonica(1, 10)
#+end_SRC

#+RESULTS: cde2230d-c34c-424c-85cf-38b66e823af3
: [....]

 O miniEP para a pr√≥xima semana ser√°:
****** computar a soma dos n primeiros inversos dos quadrados
****** computar os n primeiros elementos da soma harm√¥nica alternada, onde os elementos 1/n s√£o somados com sinais alternantes. Para isso um dos par√¢metros a serem passados ser√° o sinal.

Em alguns casos √© relativamente f√°cil pensar em testes para verificar se as fun√ß√µes feitas est√£o corretas. A forma mais f√°cil de se fazer isso √© atrav√©s de resultados conhecidos.
Por exemplo a soma alternada e o ln 2.
** Aula 10 - <2020-04-12 dom>

*** Agora na linha de comando
  Hoje, vamos continuar fazendo exerc√≠cios com Julia, a diferen√ßa √© que agora vamos usar
a linha de comando, isso √©, vamos criar arquivos fora do ambiente "seguro" do Jupyter.
Para isso, vamos criar arquivos com a extens√£o .jl com c√≥digo. Vamos come√ßar criando um
arquivo imprime.jl com apenas um print

  #+begin_SRC ein-julia :results output :session localhost
println("Agora do arquivo")
  #+end_SRC

  Ele pode ser compilado/executado chamando se julia imprime.jl

  Da mesma forma podemos usar arquivos para guardar fun√ß√µes como a
  de c√°lculo de pot√™ncias inteiras, que recebe um valor x, e devolve $x^ n$.

  #+begin_SRC ein-julia :results output :session localhost
  function pot(x, n)
    res = 1
    while n > 0
      res = res * x
      n = n - 1
    end
    return res
  end
  #+end_SRC

 Mas, como podemos usar essa fun√ß√£o, agora que ela est√° pronta? Usando o comando
include, h√° formas mais sofisticadas de usar "pacotes", mas por enquanto esse comando
ser√° suficiente.

 #+begin_SRC ein-julia :results output :session localhost
include("funct.jl")
println("2 elevado a 4 √© ", pot(2, 4)
 #+end_SRC

Isso inclusive nos ajuda no que se refere aos testes automatizados, pois o
arquivo com os testes automatizados pode ser executado de forma independente.

Sim, podemos incluir novas fun√ß√µes no arquivo funct.jl, como o c√°lculo de
fatorial.

Os testes de pot√™ncia a fatorial podem ser independentes!

Agora que temos as fun√ß√µes de c√°lculo de pot√™ncia e de fatorial, podemos us√°-las
para c√°lculos mais sofisticados como o de cosseno, usando s√©ries de Taylor:
\[ \mbox{cos}(x) = \Sum_{n = 0}^{\infty} \frac{(-1)^n x^{2n}}{(2n)!} \], sendo que o valor de $x$ √©
dado em radianos.

#+begin_SRC ein-julia :results output :session localhost
include("funct.jl")
function cosseno(x)
  Erro = 1f-7
  s√©rie = 0
  termo = 1
  i = 0
  while abs(termo > Erro)
     s√©rie = s√©rie + termo
     i = i + 1
     termo = potencia(-1, i) * potencia(x, 2 * i) / fat(2 * i)
  end
  s√©rie = s√©rie + termo
  return s√©rie
end
#+end_SRC

Mas, podemos melhorar a nossa fun√ß√£o de c√°lculo de cosseno observando que
d√° para a partir do termo anterior, chegar ao pr√≥ximo termo.


#+begin_SRC ein-julia :results output :session localhost
# aqui vai o c√≥digo
#+end_SRC

Agora uma discuss√£o sobre uma d√∫vida que apareceu para o monitor, a identa√ß√£o. Isso
√© o recuo que fazemos para delimitar blocos de c√≥digo em Julia. Vamos ver um exemplo:

#+begin_SRC ein-julia :results output :session localhost
function matematica()
   i = 1
   while i < 100
      if i % 2 == 0
         println(i, " √© par ")
      else
         if i % 3 == 0
            print(i, " √© divis√≠vel por tr√™s e ")
            soma = 0
            aux = i
            while aux > 0
               soma = soma + aux % 10
               aux = div(aux, 10)
            end
            if soma % 3 == 0
               println(" e a soma dos seus d√≠gitos tamb√©m")
            else
               println("Deu ruim, resultado n√£o esperado para: ", i)
               break # sim esse break √© justificado :)
            end
         end
      end
      i = i + 1
   end
end
#+end_SRC

Al√©m dos blocos, tamb√©m √© interessante entender o conceito de escopo, vamos a um exemplo:

#+begin_SRC ein-julia :results output :session localhost
function valeum(a)
   println("a valia: ", a)
   a = 1
   println("agora a vale ", a)
end
function avaleum()
   # n√£o imprime a aqui, pois daria erro
   a = 1
   println("a vale: ", a)
end

function vamosver()
   a = 3
   println("a vale: ", a)
   begin
     println("Modifiquei a em um bloco")
     a = 2
     println("a vale: ", a)
   end
   println("O a vale, fora do bloco ", a)
   valeum(a)
   println("a vale: ", a)
   avaleum()
   println("a vale: ", a)
end
#+end_SRC

 No c√≥digo acima, podemos ver duas coisas importantes, o escopo (valor de uma vari√°vel
vai al√©m dos blocos, pois ao modificar dentro de um bloco, modificamos a vari√°vel original.
 Por outro lado, o escopo √© independente conforme a fun√ß√£o.

 Ao chamar uma fun√ß√£o com uma vari√°vel √© passada uma c√≥pia da vari√°vel, que √© no in√≠cio da
fun√ß√£o igual ao valor original.

 Um exerc√≠cio para terminar. Dado um n√∫mero $n$ sabe-se que $n^3$ pode ser representado pela
soma de $n$ n√∫meros √≠mpares consecutivos, encontre esses valores para $n$ de 1 a 10.
** Aula 11 - <2020-04-22 qua>
*** Entrada de dados e o come√ßo de listas
Nessa aula, temos dois t√≥picos principais, como fazer a entrada de dados,
atrav√©s de comandos de entrada e com argumentos. Al√©m disso tamb√©m veremos
como tratar de um tipo especial de vari√°vel, onde √© poss√≠vel, guardar
mais de um valor.

**** O comando input
Quando queremos inserir dados, em Julia, tanto no Jupyter, como no mode
interativo, basta colocar dados. Mas, como podemos fazer para entrar
dados em um programa comum?

 Para isso temos o comando readline(), que interrompe a execu√ß√£o do
programa e espera pela entrada de uma String, o que ocorre quando a
tecla <enter> √© pressionada.

 #+begin_SRC ein-julia :results output :session localhost
println("Digite o seu nome")
resposta = readline()
println("O seu nome e: ", resposta)
 #+end_SRC

Como o readline() l√™ Strings, se quisermos ler n√∫meros, √©
necess√°rio usar o comando parse.

#+begin_SRC ein-julia :results output :session localhost
println("Digite um inteiro")
valor = parse(Int64, readline())
println("O numero digitado foi ", valor)
#+end_SRC

Sabendo ler n√∫meros do teclado, vamos a um exerc√≠cio simples, ler uma
sequ√™ncia de n√∫meros inteiros terminada por zero e devolver a sua soma.

#+begin_SRC ein-julia :results output :session localhost
# coloque a sua proposta aqui
#+end_SRC

**** Lendo atrav√©s da linha de comando
 A outra forma de ler comandos √© atrav√©s da constante ARGS que √©
preparada na chamada de um programa. Para entender melhor isso, vamos
ver o seguinte programa.

 #+begin_SRC ein-julia :results output :session localhost
println(ARGS)
 #+end_SRC

Se a linha acima est√° no arquivo args.jl, ao chamar julia args.jl com diversos
par√¢metros, teremos diversos resultados diferentes.

Por exemplo ao chamar:

julia args.jl 1 2 3 abc

Teremos como resposta

#+begin_SRC ein-julia :results output :session localhost
["1", "2", "3", "abc"]
#+end_SRC

Vamos analisar um pouco melhor essa resposta observando que cada
par√¢metro est√° em uma posi√ß√£o.

#+begin_SRC ein-julia :results output :session localhost
tam = length(ARGS)
println("O tamanho dos argumentos √©: ", tam)
for i in 1:tam
  println(ARGS[i])
end
#+end_SRC

 Olhando o c√≥digo acima, podemos ver que o comando length() devolve
o n√∫mero de argumentos, ou seja, o tamanho da lista ARGS. Al√©m disso
com os colchetes √© poss√≠vel acessar a cada posi√ß√£o da lista de forma
individual.


 O exemplo abaixo  soma os par√¢metros inteiros dados como argumentos. Ele
tamb√©m ilustra uma boa pr√°tica que √©, sempre colocar o c√≥digo em m√≥dulos,
no caso abaixo em fun√ß√µes:

 #+begin_SRC ein-julia :results output :session localhost
function main()
  tam = length(ARGS)
  s = 0
  i = 1
  while i <= tam
      valor = parse(Int, ARGS[i])
      println(valor)
      s = s + valor
      i = i + 1
  end
  println("A soma foi: ", s)
end
main()

 #+end_SRC

 A flexibilidade que temos ao usar listas √© enorme! Por isso,
listas ou vetores, merecem um t√≥pico pr√≥prio.

**** Listas

Vamos primeiro brincar um pouco no console.

#+begin_SRC ein-julia :results output :session localhost
vetor = [1, 2, 3]
println(vetor[1])
println(length(vetor))
vetor[2] = vetor[2] + 1
vetor[1] = 2 * vetor[3]
println(vetor)
#+end_SRC

 Como disse antes, o for foi feito para manipular vetores,
vamos ver umas fun√ß√µes, a primeira que imprime os elementos de um vetor
um por linha.

 #+begin_SRC ein-julia :results output :session localhost
function imprimeVetor(v)
  for el in v
    println(el)
  end
end
 #+end_SRC

 Isso tamb√©m pode ser feito atrav√©s dos √≠ndices do vetor:

 #+begin_SRC ein-julia :results output :session localhost
function imprimeVetor(v)
  for i in 1:lenght(v)
    println(v[i])
  end
end
 #+end_SRC

Como cada posi√ß√£o √© independente, podemos calcular a soma dos
elementos √≠mpares de um vetor

#+begin_SRC ein-julia :results output :session localhost
function somaImpVetor(v)
         soma = 0
         for i in 1:length(v)
           if v[i] % 2 == 1
             soma = soma + v[i]
           end
         end
         return soma
       end
#+end_SRC

Para terminar, vamos fazer uma fun√ß√£o onde dado um vetor de inteiros
de tamanho $n$, verifica se esse vetor √© uma permuta√ß√£o dos n√∫meros de
1 a $n$. Para isso, veremos se cada n√∫mero de 1 a $n$ est√° no vetor.

#+begin_SRC ein-julia :results output :session localhost
function permuta2(v)
   tam = length(v)
   for i in 1:tam
      if  !(i in v)
         return false
      end
   end
   return true
end
#+end_SRC

Foi usado o comando in de Julia que verifica se um elemento est√° no vetor.
** Aula 12 - <2020-04-27 seg>
*** Conhecendo melhor os vetores
**** Passar vetores como par√¢metro √© diferente
Assim como j√° passamos vari√°veis normais, ou escalares, como
par√¢metro de fun√ß√µes, tamb√©m podemos passar vetores. Mas, √© importante
ressaltar que isso ocorre de forma distinta, isso √©, os vetores s√£o
passados por refer√™ncia.

Vamos a uma analogia, quando se passa uma vari√°vel escalar, como
par√¢metro a fun√ß√£o recebe uma c√≥pia dela. J√° para um vetor, o que se
recebe √© uma c√≥pia do endere√ßo dele. Em algumas linguages como C, isso
√© completamente expl√≠cito, e essa refer√™ncia √© denominada ponteiro.

#+begin_SRC ein-julia :results output :session localhost
function mudavalores(x, v)
   println("x = ", x, " e v = ", v)
   x = 1
   v[1] = 1
   println("x = ", x, " e v = ", v)
end
function vesemuda()
   x = 0
   v = [2, 3, 4]
   println("x = ", x, " e v = ", v)
   println("Antes da mudavalores")
   mudavalores(x, v)
   println("Depois da mudavalores")
   println("x = ", x, " e v = ", v)
end
#+end_SRC

Ao executar a fun√ß√£o vesemuda(), podemos ver que como esperado para
a vari√°vel escalar, no escopo da fun√ß√£o a c√≥pia foi alterada, sem
mudan√ßa na vari√°vel $x$ original.

 Por outro lado, para o vetor, como t√≠nhamos uma c√≥pia do endere√ßo,
mudar sua primeira posi√ß√£o, fez com que o vetor original fosse alterado.
Mas, alterar a c√≥pia do endere√ßo, n√£o muda o endere√ßo final, como pode
se ver abaixo:

 #+begin_SRC ein-julia :results output :session localhost
function novovetor(v)
   println("O vetor era = ", v)
   v = ["a", "b", "c"]
   println("O vetor ficou sendo = ", v)
end
function vesemuda2()
   v = [2, 3, 4]
   println("v = ", v)
   println("Antes de novovetor")
   novovetor(v)
   println("Depois de novovetor")
   println("v = ", v)
end
 #+end_SRC

**** Vamos continuar vendo como manipular vetores

Para isso, vamos precisar conhecer algo de Julia, que vai
nos ajudar. Por enquanto j√° sabemos como acessar posi√ß√µes espec√≠ficas
de um vetor.

Mas, vamos precisar de alguns comandos adicionais para fazer
os pr√≥ximos exerc√≠cios. S√£o eles, criar um vetor vazio, adicionar um
ou mais elementos ao final do vetor, e criar um vetor de um tamanho
definido.

#+begin_SRC ein-julia :results output :session localhost
v = [] # define um vetor vazio
push!(v, 1)  # adiciona um primeiro elemento 1 ao vetor
push!(v, 2, 3) # adiciona os elementos 2 e 3 ao vetor
zeros(Int, 3) # cria um vetor para guardar inteiros com 3 posi√ß√µes
zeros(Float, 10) # cria um vetor para guardar floats com 10 posi√ß√µes
#+end_SRC

N√≥s j√° vimos que usualmente vetores em Julia podem guardar qualquer
tipo de vari√°vel, mas j√° √© bom saber que ao usarmos um vetor com
tipo pr√©-identificado, isso √©, por exemplo, s√≥ de inteiros. Seu
uso fica mais eficiente.

Vamos agora exercitar um pouco o uso de vetores:

Fa√ßa uma fun√ß√£o inverte que dado um vetor, devolve esse vetor com os
valores invertidos (isso √©, quem estava na primeira posi√ß√£o vai para
a √∫ltima e assim por diante).

#+begin_SRC ein-julia :results output :session localhost
# Aqui vai a function
#+end_SRC

Fa√ßa uma fun√ß√£o que recebe um vetor de inteiros e devolve um vetor
apenas com os n√∫meros √≠mpares do vetor original

#+begin_SRC ein-julia :results output :session localhost
# Aqui vai a function
#+end_SRC

 Dado um vetor de n√∫meros inteiros, fa√ßa uma fun√ß√£o que devolve um vetor que
 corresponde a uma leitura desse vetor, conforme o n√∫mero de elementos. Ou seja,
 dado o vetor [1, 1, 1, 4, 10, 10, 1] o vetor de sa√≠da dever ser [3, 1, 1, 4, 2,
 10, 1, 4] ou seja, tr√™s "1", um "4", dois "10" e um "quatro".

#+begin_SRC ein-julia :results output :session localhost
# Aqui vai a function
#+end_SRC
Sabendo que o comando rand(1:n), vai devolver um n√∫mero entre 1 e n.
Escreva uma fun√ß√£o que dado um inteiro n, devolve um vetor com uma
permuta√ß√£o de 1 a n.

#+begin_SRC ein-julia :results output :session localhost
# Aqui vai a function
#+end_SRC

Voltando ao exerc√≠cio da aula passada vamos ver como fazer com
que a verifica√ß√£o se um vetor corresponde a uma permuta√ß√£o de forma mais
eficiente. Como voc√™ faria isso
** Aula 16 <2020-05-06 qua>
*** Um pouco mais de sintaxe de Julia e vetores

Como √© de se imaginar, testes automatizados s√£o muito
utilizados por bons desenvolvedores. Logo podemos imaginar
que a linguagem Julia tem formas de ajudar a escrita de
testes.

Isso √© feito com o pacote de testes de Julia, para us√°-lo precisamos
usar o comando using. Vamos a um exemplo abaixo:
#+begin_SRC ein-julia :results output :session localhost
using Test
@test 1 == 1
@test 1 != 2
#+end_SRC

 O comando @test avalia a express√£o e verifica se o valor √©
verdadeiro (true), se for, n√£o faz nada. Mas, se n√£o for, aponta
o erro.

 Dessa forma, podemos escrever testes em Julia de forma mais compacta.
Para come√ßar vamos verificar se uma fun√ß√£o que recebe um vetor e devolve
a soma dos seus elementos funciona.

 #+begin_SRC ein-julia :results output :session localhost
using Test
include("soma.jl")
function testaTudo()
  @test soma([]) == 0
  @test soma([1]) == 1
  @test soma([10, 20, 30]) == 60
  println("final dos testes")
end
testaTudo()
 #+end_SRC
Que funciona verifica se a seguinte fun√ß√£o funciona:

#+begin_SRC ein-julia :results output :session localhost
function soma(v)
  s = 0
  for el in v
    s = s + el
  end
  return s
end
#+end_SRC

 Outro comando √∫til de Julia √© a verifica√ß√£o aproximada, pois j√°
vimos que opera√ß√µes com n√∫mero reais nem sempre √© exata. Essa
compara√ß√£o √© dada com \approx (barra approx)

 #+begin_SRC ein-julia :results output :session localhost
 0.2 + 0.2 + 0.2 \approx 0.6
 #+end_SRC

*** Voltando a vetores

Vamos agora voltar √† parte algor√≠tmica, com o seguinte problema.
Subsequ√™ncia de soma m√°xima. Dado um vetor de inteiros, devolver a
soma de elementos consecutivos que seja m√°xima.

Vamos come√ßar pelos testes.

#+begin_SRC ein-julia :results output :session localhost
using Test
function verificaSoma()
  @test somasub([]) == 0
  @test somasub([1, 2, 3]) == 6
  @test somasub[-1, -2, -3]) == -1
  @test somasub([10, 5, -17, 20, 5, -1, 3, -30, 10]) == 72
  @test somasub([31, -41, 59, 26, -53, 58, 97, -93, -23, 84] == 187
  println("Final dos testes")
end
#+end_SRC

 Vamos come√ßar com a solu√ß√£o de for√ßa bruta, isso √©, calcular a soma
de todas a sub-sequ√™ncias, procurando pela m√°xima.

 #+begin_SRC ein-julia :results output :session localhost
# lugar para escrever o codigo
 #+end_SRC

Agora vamos a um algoritmo mais elaborado. (Jay-Kadane)
#+begin_SRC ein-julia :results output :session localhost
function somasub(v)
  if length(v) == 0
    return 0
  end
  soma = 0
  somamax = v[1]
  for i in 1:length(v)
    if soma + v[i] < 0
      soma = 0
    else
      soma = soma + v[i]
    end
    if soma > somamax
      somamax = soma
    end
  end
  return somamax
end
#+end_SRC

Fa√ßa uma fun√ß√£o, onde dados dois vetores u e v, devolve o seu
produto escalar.

#+begin_SRC ein-julia :results output :session localhost

#+end_SRC

 Fa√ßa uma fun√ß√£o, onde dados dois vetores ordenados u e v,
sem repeti√ß√£o, devolve o vetor ordenado com os elementos de u
e v, sem repeti√ß√£o.

 #+begin_SRC ein-julia :results output :session localhost

 #+end_SRC

** Aula 17 <2020-05-18 seg>
*** Um pouco mais de manipula√ß√£o de vetores (com merge e busca) e mudan√ßa de base
Na aula passada, vimos como fazer um dos problemas de merge, isso, √©
dados dois vetores ordenados sem repeti√ß√£o, devolver um vetor que
corresponda a uni√£o deles sem repeti√ß√£o.
#+begin_SRC ein-julia :results output :session localhost
function merge(u, v)
  pu = 1   # ponteiro em u
  pv = 1   # ponteiro em v
  resp = []
  while pu <= length(u) && pv <= length(v)
    if u[pu] < v[pv]
       push!(resp, u[pu])
       pu = pu + 1
    elseif v[pv] < u[pu]
       push!(resp, v[pv])
       pv = pv + 1
    else
       push!(resp, v[pv])
       pu = pu + 1
       pv = pv + 1
    end
  end
  while pu <= length(u)
    push!(resp, u[pu])
    pu = pu + 1
  end
  while pv <= length(v)
    push!(resp, v[pv])
    pv = pv + 1
  end
  return resp
end
#+end_SRC

Com pequenas varia√ß√µes nesse c√≥digo, podemos fazer outros tipos de merge:
- Fazer a intersec√ß√£o
- Fazer a diferen√ßa (isso √©, elementos devolver apenas elementos que est√£o
em u, mas n√£o e, v

Todas essas solu√ß√µes se baseiam em varia√ß√µes do c√≥digo acima. Tudo isso
sabendo que os vetores originais est√£o ordenados e sem repeti√ß√£o.

Aproveitando, como podemos fazer para dado um vetor ordenado, com repeti√ß√µes,
devolver um vetor ordenado sem repeti√ß√µes?

#+begin_SRC ein-julia :results output :session localhost

#+end_SRC

A ordena√ß√£o tamb√©m pode ser √∫til para verificar se um elemento est√° em
um vetor, mas vamos come√ßar com a vers√£o simples, de percorrer todo o vetor.

Para isso, faremos uma fun√ß√£o que recebe um vetor e um elemento, caso o
elemento perten√ßa ao vetor, devolvemos sua posi√ß√£o, caso contr√°rio devolvemos
0.

#+begin_SRC ein-julia :results output :session localhost
function posicaonovetor(v, el)
  for i in 1:length(v)
    if el == v[i]
      return i
    end
  end
  return 0
end
#+end_SRC

A solu√ß√£o acima funciona, mas ela n√£o considera que o vetor est√° ordenado.
Para tentar entender uma solu√ß√£o melhor (busca bin√°ria), vamos fazer uma
brincadeira. Um volunt√°rio vai pensar em um n√∫mero entre 0 e 1023 e vou
advinh√°-lo em at√© 10 tentativas, sendo que as respostas podem ser:
- N√∫mero encontrado
- O n√∫mero que eu pensei √© maior
- O n√∫mero que eu pensei √© menor

A l√≥gica por tr√°s dessa solu√ß√£o √© que eu quero eliminar a maior quantidade
de n√∫meros a cada palpite, para fazer isso, o melhor √© pensar em um
palpite no "meio", que elimine metade dos n√∫meros em quest√£o.

Vamos agora desenvolver um algoritmo que faz a busca bin√°ria.
Mas, como ele √© um pouco mais complicado, vamos come√ßar com os testes,
validar os testes com a fun√ß√£o anterior (posi√ß√£o no vetor) e finalmente
escrever o nosso algoritmo de busca bin√°ria.

#+begin_SRC ein-julia :results output :session localhost

#+end_SRC

Na aula que vem veremos algumas formas de se ordenar um vetor,
sim Julia tem as fun√ß√µes sort() e sort!(). Mas, a motiva√ß√£o por
tr√°s de aprender a ordenar √© aprender como faz√™-lo.

*** Mudan√ßa de base
Vamos come√ßar com umas ideias intuitivas, na base 10, temos os
d√≠gitos de 0 a 9, e os n√∫meros s√£o agrupados de forma que o menos
significativo corresponde √† base 10^0, o segundo √† base 10¬π e assim
por diante.

Logo, um n√∫mero como o 123 √© na verdade igual a 3 * 10‚Å∞ + 2 * 10¬π + 1*10¬≤.
Isso √© t√£o natural que usamos naturalmente, sem pensar em base quando
falamos em base decimal.

O mesmo vale para outras bases, como a bin√°ria:

10010 √© igual a 0 * 2^0 + 1 * 2^1 + 0 * 2^2 + 0 * 2^3 + 1 * 2^4 ou seja √©
igual a 18 na base 10.

Dessa forma, podemos pensar em como devolver o valor na
base 10, para um n√∫mero qualquer na base 2.

#+begin_SRC ein-julia :results output :session localhost
function valorbase2(n)
  pot = 0
  soma = 0
  while n != 0
    dig = n % 10
    soma = soma + dig * 2 ^pot
    n = n √∑ 10
    pot = pot + 1
  end
  return soma
end
#+end_SRC

H√° duas coisas a observar acima, o c√≥digo pode ser melhorado e
podemos pensar em outras bases que n√£o sejam apenas a bin√°ria (a
dificuldade de trabalhar com bases maiores do que 10 √© devido
√†s vari√°veis inteiras terem apenas os d√≠gitos de 0 a 9).

Mas, vamos fazer isso de uma forma iterativa, usando testes
 automatizados.

Ap√≥s vermos como ter um n√∫mero em uma base menor, na base 10,
vamos ver como transformar um n√∫mero na base 10, em outra base.
Comecemos com a bin√°ria:

Temos as pot√™ncias: 1, 2, 4, 8, 16, 32, 64, ...
Como escrever o n√∫mero 99 em bin√°rio?
Come√ßamos pela parte menos significativa, isso √©, 99 % 2, e continuamos
com a sobra da parte mais significativa, isso √©, 99 % 2 (= 1) e
 99 \div 2 (= 49), e repetimos o mesmo procedimento.

#+begin_SRC ein-julia :results output :session localhost

#+end_SRC

Mas, n√£o vamos esquecer dos nossos testes :)

Olhando os c√≥digos com cuidado, d√° para generalizar?

** Aula 18 - Simulado de prova <2020-05-20 qua>
*** Prova de 2019 (traduzida de C para Julia)
**** Quest√£o 1 (1.5 pontos)
Dado o seu NUSP qual √© a sa√≠da do programa abaixo?
#+begin_SRC ein-julia :results output :session localhost
function misterio(n)
   b = n
   c = -1
   while b > 0
      a = b % 10
      b = b √∑ 10
      if a > c
         c = a
      end
      x = float(b / 10)
      println("n = ", n, "  a = ", a, "  b = ", b, "  c = ", c, "  x = ", x)
   end
   println("c = ", c, " n/100 ", n/100)
end
#+end_SRC

**** Quest√£o 2 (2.5 pontos)
Um nuÃÅmero inteiro n > 0 eÃÅ perfeito se ele for igual aÃÄ soma de seus divisores
positivos diferentes de n.

Exemplo:
-  6 eÃÅ perfeito, pois 6 = 1 + 2 + 3;
-  28 eÃÅ perfeito, pois 28 = 1 + 2 + 4 + 7 + 14.

FacÃßa uma fun√ß√£o que recebe um nuÃÅmero inteiro n > 0 e decide se n eÃÅ perfeito.

**** Quest√£o 3 (2.5 pontos)
Dado um vetor n nuÃÅmeros inteiros, desejamos encontrar o comprimento
de um maior segmento crescente da sequeÃÇncia.
Exemplo:
- para o vetor v = [4, 7, 2, 4, 7, ‚àí2, 5, 8, 1, 17]
um maior segmento crescente tem comprimento 3.
- para o vetor v = [10, 10, 5, 3, 2]
um maior segmento crescente tem comprimento 1.
- para o vetor v = [2, 7, 5, 6, 8, 13, 9, 11, 2, 5, 7, 4, 13]
um segmento crescente de comprimento maÃÅximo tem tamanho 4.

**** Quest√£o 4 (3.5 pontos)

Dizemos que um nuÃÅmero inteiro n eÃÅ 3-alternante se, quando n eÃÅ escrito
 na base 3, alterna nuÃÅmeros pares e ƒ±ÃÅmpares.
Exemplo:
- 151 eÃÅ 3-alternante, pois 151 escrito na base 3 eÃÅ 12121 que alterna pares e ƒ±ÃÅmpares.
- 145 eÃÅ 3-alternante, pois escrito na base 3 eÃÅ 12101, que alterna pares e ƒ±ÃÅmpares.
- 48 eÃÅ 3-alternante, pois escrito na base 3 eÃÅ 1210.
- 37 naÃÉo eÃÅ 3-alternante, pois escrito na base 3 eÃÅ 1101.
- 2 eÃÅ 3-alternante, pois se escreve 2 na base 3.
FacÃßa uma fun√ß√£o que leÃÇ um inteiro n ‚â• 0 e verifica se n eÃÅ 3-alternante.

** Aula 19 - Ordena√ß√£o

Tem que colocar conte√∫do aqui

** Aula 20 - Ainda ordena√ß√£o

Nessa aula vamos continuar vendo a ordena√ß√£o, mas antes disso,
vamos finalmente ver o algoritmo de busca bin√°ria para
encontrar um elemento em um vetor ordenado.

*** Busca bin√°ria
Ao inv√©s de percorrer o vetor, desde o in√≠cio, procurando o
elemento como em:
#+begin_SRC ein-julia :results output :session localhost
function buscaLinear(x, v)
  for i in 1:length(v)
    if v[i] == x
      return i
    end
  end
  return 0 # n√£o encontrou o x em v[]
end
#+end_SRC

Podemos a cada procura, para ver se o elemento est√°
no vetor, eliminar metado do vetor. Se o elemento for
menor que o meio, olhamos do come√ßo ao meio. se for maior
que o meio, olhamos do meio ao fim. Se for igual, achou.

#+begin_SRC ein-julia :results output :session localhost
function buscaBinaria(x, v)
   inicio = 1
   fim = length(v)
   while in <= fim
      meio = div(inicio + fim, 2)
      if v[meio] == x
        return meio
      elseif x < v[meio]
        fim = meio - 1
      else
        inicio = meio + 1
      end
   end
   return 0
end
#+end_SRC

 H√° tamb√©m a vers√£o recursiva, para isso temos que ter
o inƒ©cio e o fim como par√¢metros.

#+begin_SRC ein-julia :results output :session localhost
function buscaBinariaRec(inicio, fim, x, v)
   if inicio > fim
     return 0
   end
   meio = div(inicio + fim, 2)
   if v[meio] == x
     return meio
   elseif x < v[meio]
     buscaBinariaRec(inicio, meio - 1, x, v)
   else
     buscaBinariaRec(meio + 1, fim, x, v)
   end
end
#+end_SRC

*** M√©todos de busca mais elaborados

Uma forma mais eficiente de se ordenar um vetor √© usando a divis√£o e conquista,
isso √©, dado um vetor, quebramos em duas partes, ordenamos as partes e depois
fazemos o merge, no caso como podemos ter repeti√ß√£o, vamos usar a vers√£o que
permite duplica√ß√£o.

#+begin_SRC ein-julia :results output :session localhost
function merge(u, v)
  pu = 1  # ponteiro em u
  pv = 1  # ponteiro em v
  resp = []
  while pu <= length(u) && pv <= length(v)
    if u[pu] < v[pv]
      push!(resp, u[pu])
      pu = pu + 1
    elseif v[pv] < u[pu]
      push!(resp, v[pv])
      pv = pv + 1
    else
      push!(resp, v[pv])
      pu = pu + 1
    end
  end
  while pu <= length(u)
    push!(resp, u[pu])
    pu = pu + 1
  end
  while pv <= length(v)
    push!(resp, v[pv])
    pv = pv + 1
    end
  return resp
end
#+end_SRC

 Dado o merge, a ideia √©:
- Divida o vetor no meio
- Ordene cada metade separadamente
- Devolva o merge

Para isso vamos ver mais uma possibilidade de Julia,
dado um vetor v, v[1:meio] cria um vetor at√© o meio e
v[meio + 1:length(v)] cria um vetor do meio + 1 ao final.

Com isso fica f√°cil fazer o mergeSort.

#+begin_SRC ein-julia :results output :session localhost
function mergeSort(v)
  if length(v) <= 1
    return v
  end
  meio = div(length(v), 2)
  v1 = v[1:meio]
  v2 = v[meio + 1:length(v)]
  v1ord = mergeSort(v1)
  v2ord = mergeSort(v2)
  return merge(v1ord, v2ord)
end
#+end_SRC

 Vamos ao √∫ltimo algoritmo, que tamb√©m fica melhor de forma
recursiva, dado um vetor, o primeiro passo √© escolher um elemento
 de forma a dividir o vetor em duas partes, quem for menor ou
igual a esse elemento, e quem for maior. Isso deve ser feito
de forma recursiva.

#+begin_SRC ein-julia :results output :session localhost
function quick!(i, j, v)
    if j > i
        pivo = v[div(i+j, 2)]
        left = i
        right = j
        while left <= right
            while v[left] < pivo
                left += 1
            end
            while v[right] > pivo
                right -= 1
            end
            if left <= right
                v[left], v[right] = v[right], v[left]
                left += 1
                right -= 1
            end
        end
        quick!(i, right, v)
        quick!(left, j, v)
    end
    return v
end
#+end_SRC
** Aula 21 - Indo al√©m de vetores
Nessa aula o objetivo √© ir al√©m de vetores, primeiro entendendo que em
J√∫lia o que se pode fazer com vetores √© bem flex√≠vel, em seguida vamos
ver que vetores podem ter v√°rias dimens√µes. Veremos ao final alguns algoritmos
com matrizes.

*** Indo al√©m de vetores
Conforme j√° vimos antes, os vetores ocupam v√°rias posi√ß√µes de
mem√≥ria, uma forma de se inicializar um vetor √© atrav√©s da fun√ß√£o
zeros. Que cria um vetor com valores nulos.

#+begin_SRC ein-julia :results output :session localhost
zeros(1)
zeros(100)
zeros(Int8, 3)
#+end_SRC

A novidade √© que agora o zeros pode criar tamb√©m vetores de mais
de uma dimens√£o, ou matrizes.
#+begin_SRC ein-julia :results output :session localhost
zeros(3,3)
zeros(Int, 2, 2)
#+end_SRC

Duas outras fun√ß√ïes interessantes s√£o a ones() com comportamento
similar a zeros(), e a rand() que cria vetores ou matrizes com
n√∫meros aleat√≥rios.

O comando fill() serve para fazer isso com um valor espec√≠fico.
#+begin_SRC ein-julia :results output :session localhost
ones(3, 3)
rand(4, 4)
rand(1: 10, 5, 5)
fill(42, 3, 3, 3)
#+end_SRC

Tamb√©m √© poss√≠vel criar matrizes diretamente.

#+begin_SRC ein-julia :results output :session localhost
m = [1 2 3; 4 5 6; 7 8 9]
#+end_SRC

O comando length() funciona para matrizes, mas devolve o seu tamanho
total, mas temos tamb√©m os comandos ndims() e size().


A linguagem Julia ainda oferece v√°rios a√ßucares sint√°ticos, vejamos o
exemplo abaixo.
#+begin_SRC ein-julia :results output :session localhost
a = [1 2; 3 4]
b = [1 0; 0 1]
a * b
a .* b
#+end_SRC

Mas, lembrando que o objetivo da disciplina √© ensinar algoritmos, vamos
ver alguns.

Uma fun√ß√£o que imprime uma matriz quadrada m.

#+begin_SRC ein-julia :results output :session localhost
function imprimeMatriz(m)
    a = size(m)
    soma = 0
    for i in 1:a[1]
       for j in 1:a[2]
          print(" m[", i, ", ", j, "] = ", m[i,j])
        end
        println()
    end
end
#+end_SRC


Fa√ßa uma fun√ß√£o que recebe uma matriz quadrada e devolve a soma dos seus
elementos.

#+begin_SRC ein-julia :results output :session localhost
function somaMatriz(m)
    a = size(m)
    soma = 0
    for i in 1:a[1]
       for j in 1:a[2]
          soma = soma + m[i, j]
        end
     end
     return soma
  end
#+end_SRC

Uma matriz quadrada √© um quadrado m√°gico se a soma dos elementos de
cada linha, de cada coluna e das diagonais √© sempre igual. Fa√ßa uma
fun√ß√£o que dada uma matriz quadrada m, verifica se ela √© um
quadrado m√°gico.

#+begin_SRC ein-julia :results output :session localhost
function QuadradoMagico(m)
    if length(m) == 1
      return true
    end
    a = size(m)
    if length(a) != 2 || a[1] != a[2]
      return false
    end
    somaP = 0
    for i in 1:a[1]
      somaP = somaP + m[i, i]
    end
    soma = 0
    for i in 1:a[1]
       soma = soma + m[i, a[1] - i + 1]
    end
    if somaP != soma
       return false
    end
    for i in 1:a[1]
       somaL = 0
       somaC = 0
       for j in 1:a[2]
          somaL = somaL + m[i, j]
          somaC = somaC + m[j, i]
       end
       if somaL != somaP || somaC != somaP
          return false
       end
    end
    return true
end
#+end_SRC

** Aula 22 - Ainda matrizes

 Dadas duas matrizes m e n, fa√ßa uma fun√ß√£o que devolva o
produto delas (sem usar o * para matrizes).

 #+begin_SRC ein-julia :results output :session localhost
function multiplica(a, b)
   dima = size(a)
   dimb = size(b)
   if dima[2] != dimb[1]
     return -1
   end
   c = zeros(dima[1], dimb[2])
   for i in 1:dima[1]
      for j in 1:dimb[2]
         for k in 1:dima[2]
            c[i, j] = c[i, j] + a[i, k] * b[k, j]
         end
       end
   end
   return c
 end

 #+end_SRC

Uma matriz quadrada de tamanho n √© um quadrado latino se em cada linha e coluna
aparecem todos os valores de 1 a n. Fa√ßa uma fun√ß√£o que dada uma matriz
quadrada verifica se ela √© um quadrado latino.

#+begin_SRC ein-julia :results output :session localhost

#+end_SRC

Dizemos que uma matriz inteira A nxn  √© uma matriz de permuta√ß√£o se em cada linha e em cada
coluna houver n-1 elementos nulos e um √∫nico elemento igual a 1. Fa√ßa uma fun√ß√£o que recebe
uma matriz quadrada e que verifica se ela √© uma matriz de permuta√ß√£o.

#+begin_SRC ein-julia :results output :session localhost

#+end_SRC

Mas, conforme a abstra√ß√£o que fazemos as matrizes podem representar coisas diferentes,
por exemplo dada uma matriz quadrada n x n, a posi√ß√£o a[i][j], pode indicar se h√° um caminho
entre a cidade i e a cidade j.

Da mesma forma, a[i][j] pode representar a dist√¢ncia entre a cidade i e a cidade j. Com isso, podemos
ter problemas mais sofisticados como saber se d√° para chegar da cidade i na cidade j, ou o custo
do menor caminho.

Nessa aula, vamos ver, um exemplo mais elaborado do uso de matriz, atrav√©s de uma teoria conhecida
como percolation. Vamos primeiro entender o que seria isso usando o livro do Sedgewick e do Wayne
https://introcs.cs.princeton.edu/java/24percolation/

A pergunta √© saber qual √© a probabilidade, a partir da qual a percolation ocorre com grande
chance (digamos mais de 80%, ou seja em 100 tentativas, em 80 ocorre a percolation). Vamos para simplificar
o problema pensar em matrizes 20 por 20.

Como resolver esse problema?


** Aula 25 - C para quem programa em Julia

Como voc√™s devem lembrar, na primeira aula deixei claro que a linguagem de programa√ß√£o
era apenas o meio de se traduzir algum conceito algor√≠tmico para o computador, de forma
a permitir a sua execu√ß√£o.

Como infelizmente, Julia ainda n√£o √© uma linguagem bastante conhecida, v√°rias outras
linguagens mais tradicionais far√£o compania para voc√™s no curso. Conhecer v√°rias linguagens
n√£o √© ruim, mas por outro lado Julia n√£o ser conhecida √© :)

Nessa aula, a ideia √© apresentar a linguagem C para quem j√° programa em Julia. H√° algumas
diferen√ßas b√°sicas

*** Compilado versus Interpretada
 Enquanto Julia √© uma linguage interpretada, C √© uma linguagem compilada, isso √©, a partir
de um c√≥digo fonte, ao se passar pelo compilador, √© gerado um c√≥digo objeto, que se correto,
pode ser executado na arquitetura para qual foi compilado.

Vejamos um primeiro c√≥digo em C.
#+begin_src C
  #include <stdio.h>
  int main() {
    printf ("Hello World!\n");
  }
#+end_src

Para compilar o c√≥digo acima, usamos o comando

#+BEGIN_CENTER
gcc um.c
#+END_CENTER
Que vai gerar um arquivo execut√°vel a.out, que se chamado imprime
a mensagem. O ponto de entrada inicial de um programa em C √© √∫nico
e √© a fun√ß√£o main().

Mas, d√° para ver mais umas coisas no c√≥digo acima que s√£o diferen√ßas
em rela√ß√£o √† Julia. Mesmo para coisas b√°sicas como impress√£o √© necess√°rio
incluir bibliotecas, no caso a stdio.h que possui a fun√ß√£o printf().

Os blocos s√£o definidos com chaves (abre e fecha) e o ponto e v√≠rgula
delimita os comandos.

Al√©m disso, j√° d√° para ver que C √© fortemente tipado, isso √©, √© necess√°rio
dizer o tipo de tudo ou seja, a fun√ß√£o main() acima, n√£o devolve nada.

*** Linguagem Tipada

Para cada vari√°vel em C, √© necess√°rio definir o seu tipo, vamos a mais
um exemplo:

#+BEGIN_CENTER
 #include <stdio.h>
  void main() {
    int a = 1;
    int b = 2;
    int c;
    c = a + b
    printf ("O valor de c √© %d\n", c);
  }

#+END_CENTER

Acima √© poss√≠vel ver que podemos dar o tipo e definir a vari√°vel na mesma linha, ou
declarar e depois usar. N√£o √© poss√≠vel usar uma vari√°vel sem declarar explicitamente.
Isso tem vantagens claras, pois poss√≠veis erros podem ser encontrados j√° em tempo de
compila√ß√£o, antes da execu√ß√£o.

O comando de impress√£o tamb√©m segue uma sintaxe diferente, recebendo primeiro uma
string, e depois uma lista de par√¢metros. Nessa string, para saber como imprimir cada um
dos par√¢metros e usar %, no caso %d para inteiros, %g para ponto flutuante e %s para string.
O \n no final √© um indicativo para pular linha.

A declara√ß√£o de fun√ß√µes √© semelhante, s√≥ que para cada vari√°vel passada como par√¢metro √©
necess√°rio passar o seu tipo. Os tipos mais comuns em C s√£o, int, char, float e double.
N√£o h√° o tipo boolean em C, o que se faz √© usar compara√ß√µes, ou tipos inteiros, basicamente
0 equivale a falso e outros valores a verdadeiro.

#+BEGIN_CENTER
#include <stdio.h>

int soma(int a, int b){
  return a + b;
}
void main() {
  int a = 1;
  int b = 2;
  printf ("O valor  √© %d\n", soma(a, b));
  if (soma(a, b) == 3)
    printf(" Verdade = %d\n", soma(a, b) == 3);  // Bloco sem chaves
}
#+END_CENTER

No c√≥digo acima podemos ver que se o bloco tem apenas uma instru√ß√£o,
n√£o precisa usar as chaves.

Assim como em Julia, a recurs√£o tamb√©m funciona bem em C.

*** Comandos diferentes
J√° o for em C √© composto por tr√™s par√¢metros, todos opcionais,
a inicializa√ß√£o, a condi√ß√£o e o passo.

#+BEGIN_CENTER
 #include <stdio.h>
void main(){
  for (int p = 1; p <= 512; p *= 2) {
    printf("%d\n", p);
  }
}   
#+END_CENTER


A sintaxe do if √© um pouco diferente, principalmente no que se refere ao
uso de elses. Vejamos um exemplo e aproveitemos para usar o comando de 
entrada de dados pelo teclado, o scanf

Comando switch

#+BEGIN_CENTER
#include <stdio.h>
void main(){
  int n;

  printf("Entre com um n√∫mero: ");
  scanf("%d", &n);
    if (n < 0)
      printf("N√∫mero negativo\n");
      else if (n > 0)
        printf("N√∫mero positivo\n");
        else
          printf("zero\n");
}    
#+END_CENTER

Observem que quanto mais elses, mais ir√≠amos para a direita, logo isso
se escreve de uma forma alternativa:

#+BEGIN_CENTER
#include <stdio.h>
void main(){
  int n;

  printf("Entre com um n√∫mero: ");
  scanf("%d", &n);
    if (n < 0)
      printf("N√∫mero negativo\n");
    else if (n > 0)
      printf("N√∫mero positivo\n");
    else
      printf("zero\n");
}    
#+END_CENTER


Mas, o principal acima √© o operador &, que obt√©m o endere√ßo de
uma vari√°vel, ou seja a sua posi√ß√£o na mem√≥ria, podemos ver o efeito
disso na se√ß√£o abaixo.

Mas, antes um exemplo do uso de switch.

#+BEGIN_CENTER
#include <stdio.h>
void main()
{
    int n;

    printf("Qual a sua carta (1-13)? ");
    scanf("%d", &n);
    switch (n) {
      case  1: printf("Ace\n"); break;
      case 11: printf("Jack\n"); break;
      case 12: printf("Queen\n"); break;
      case 13: printf("King\n"); break;
      default: printf("%d\n", n); 
    }
}
#+END_CENTER
*** Vetores e ponteiros

Vejamos o exemplo abaixo, o primeiro a lidar com ponteiros de forma
mais expl√≠cita.

#+BEGIN_CENTER
#include <stdio.h>
void naoModifica(int a){
  a = 2;
}
void Modifica(int *a){
  *a = 2;
}  

void main(){
  int n = 3;

  printf("A vari√°vel n vale %d\n", n);
  naoModifica(n);
  printf("A vari√°vel n vale %d\n", n);
  Modifica(&n);
  printf("A vari√°vel n vale %d\n", n);   
}    
#+END_CENTER

O mais pr√≥ximo que vimos de ponteiros em Julia foi o
conceito de vetores, onde um vetor tamb√©m √© um ponteiro,
mas que tamb√©m guarda o seu tamanho.

Vamos a um exemplo de vetores em C.

#+BEGIN_CENTER
#include <stdio.h>
#include <stdlib.h>

void imprimeVetor(int *v, int tam){
  for (int i = 0; i < tam; i++)
    printf("v[%d] = %d  ",i, v[i]);
  printf("\n");
}

void inicializaVetor(int *v, int tam){
  for (int i = 0; i < tam; i++)
    v[i] = rand() % 100;
}

void vezes2Vetor(int *v, int tam){
  for (int i = 0; i < tam; i++)
    v[i] = 2 * v[i];
}



void main()
{
  int vetor[10];
  inicializaVetor(vetor, 10);
  imprimeVetor(vetor, 10);
  vezes2Vetor(vetor, 10);
  imprimeVetor(vetor, 10);  
}
#+END_CENTER

Mas, com grandes poderes vem grandes responsabilidades, veja o programa abaixo com
uma pequena modifica√ß√£o e um erro inserido.
