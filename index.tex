% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames,x11names}{xcolor}
%
\documentclass[
  letterpaper,
  DIV=11,
  numbers=noendperiod]{scrreprt}

\usepackage{amsmath,amssymb}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
\usepackage{lmodern}
\ifPDFTeX\else  
    % xetex/luatex font selection
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\setcounter{secnumdepth}{5}
% Make \paragraph and \subparagraph free-standing
\makeatletter
\ifx\paragraph\undefined\else
  \let\oldparagraph\paragraph
  \renewcommand{\paragraph}{
    \@ifstar
      \xxxParagraphStar
      \xxxParagraphNoStar
  }
  \newcommand{\xxxParagraphStar}[1]{\oldparagraph*{#1}\mbox{}}
  \newcommand{\xxxParagraphNoStar}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
  \let\oldsubparagraph\subparagraph
  \renewcommand{\subparagraph}{
    \@ifstar
      \xxxSubParagraphStar
      \xxxSubParagraphNoStar
  }
  \newcommand{\xxxSubParagraphStar}[1]{\oldsubparagraph*{#1}\mbox{}}
  \newcommand{\xxxSubParagraphNoStar}[1]{\oldsubparagraph{#1}\mbox{}}
\fi
\makeatother

\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{241,243,245}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.40,0.45,0.13}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\BuiltInTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\ExtensionTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.28,0.35,0.67}{#1}}
\newcommand{\ImportTok}[1]{\textcolor[rgb]{0.00,0.46,0.62}{#1}}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.07,0.07,0.07}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}

\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother

\KOMAoption{captions}{tableheading}
\makeatletter
\@ifpackageloaded{bookmark}{}{\usepackage{bookmark}}
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\AtBeginDocument{%
\ifdefined\contentsname
  \renewcommand*\contentsname{√çndice}
\else
  \newcommand\contentsname{√çndice}
\fi
\ifdefined\listfigurename
  \renewcommand*\listfigurename{Lista de Figuras}
\else
  \newcommand\listfigurename{Lista de Figuras}
\fi
\ifdefined\listtablename
  \renewcommand*\listtablename{Lista de Tabelas}
\else
  \newcommand\listtablename{Lista de Tabelas}
\fi
\ifdefined\figurename
  \renewcommand*\figurename{Figura}
\else
  \newcommand\figurename{Figura}
\fi
\ifdefined\tablename
  \renewcommand*\tablename{Tabela}
\else
  \newcommand\tablename{Tabela}
\fi
}
\@ifpackageloaded{float}{}{\usepackage{float}}
\floatstyle{ruled}
\@ifundefined{c@chapter}{\newfloat{codelisting}{h}{lop}}{\newfloat{codelisting}{h}{lop}[chapter]}
\floatname{codelisting}{Listagem}
\newcommand*\listoflistings{\listof{codelisting}{Lista de Listagens}}
\makeatother
\makeatletter
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\@ifpackageloaded{subcaption}{}{\usepackage{subcaption}}
\makeatother

\ifLuaTeX
\usepackage[bidi=basic]{babel}
\else
\usepackage[bidi=default]{babel}
\fi
\babelprovide[main,import]{portuguese}
% get rid of language-specific shorthands (see #6817):
\let\LanguageShortHands\languageshorthands
\def\languageshorthands#1{}
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\usepackage{bookmark}

\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same} % disable monospaced font for URLs
\hypersetup{
  pdftitle={Introdu√ß√£o √† Linguagem Julia},
  pdfauthor={Alfredo Goldman; Lucas de Sousa Rosa},
  pdflang={pt},
  colorlinks=true,
  linkcolor={blue},
  filecolor={Maroon},
  citecolor={Blue},
  urlcolor={Blue},
  pdfcreator={LaTeX via pandoc}}


\title{Introdu√ß√£o √† Linguagem Julia}
\author{Alfredo Goldman \and Lucas de Sousa Rosa}
\date{2024-10-26}

\begin{document}
\maketitle

\renewcommand*\contentsname{√çndice}
{
\hypersetup{linkcolor=}
\setcounter{tocdepth}{2}
\tableofcontents
}

\bookmarksetup{startatroot}

\chapter*{TODO: adicionar pref√°cio ou algo do
g√™nero}\label{todo-adicionar-prefuxe1cio-ou-algo-do-guxeanero}
\addcontentsline{toc}{chapter}{TODO: adicionar pref√°cio ou algo do
g√™nero}

\markboth{TODO: adicionar pref√°cio ou algo do g√™nero}{TODO: adicionar
pref√°cio ou algo do g√™nero}

\bookmarksetup{startatroot}

\chapter{Vis√£o Geral do Curso}\label{visuxe3o-geral-do-curso}

\bookmarksetup{startatroot}

\chapter{Vis√£o Geral da Evolu√ß√£o de Hardware e
Linguagens}\label{visuxe3o-geral-da-evoluuxe7uxe3o-de-hardware-e-linguagens}

\bookmarksetup{startatroot}

\chapter{Usando o Interpretador (REPL) como
Calculadora}\label{usando-o-interpretador-repl-como-calculadora}

Objetivo: Ver o interpretador de Julia como uma calculadora poderosa,
introduzir a no√ß√£o de vari√°veis.

\section{Come√ßando com o modo interativo do
Julia}\label{comeuxe7ando-com-o-modo-interativo-do-julia}

Quem quiser j√° pode instalar o ambiente de programa√ß√£o, usem esse
\href{https://julialang.org/}{link}. H√° tamb√©m alguns ambientes que
permitem o uso da linguagem no seu navegador, sugiro a busca pelas
palavras chave \texttt{Julia\ Language\ online}.

Dentro do Julia (ap√≥s chamar julia na linha de comando), vamos come√ßar
com contas com n√∫meros inteiros:

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{1} \OperatorTok{+} \FloatTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{40} \OperatorTok{*} \FloatTok{4}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
160
\end{verbatim}

Sim, como era de se esperar, podemos em Julia usar os operandos:
\texttt{+}, \texttt{-} e \texttt{*}, o resultado ser√° como o esperado.
Vejamos a seguir que com a divis√£o fica um pouco diferente:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=} \FloatTok{84} 
\NormalTok{b }\OperatorTok{=} \FloatTok{2}

\CommentTok{\# As vari√°veis a e b s√£o do tipo Int64}

\NormalTok{resultado }\OperatorTok{=}\NormalTok{ a }\OperatorTok{/}\NormalTok{ b}
\FunctionTok{println}\NormalTok{(resultado)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
42.0
\end{verbatim}

Notem que nesse caso, houve uma mudan√ßa de tipos, pois 84 e 2 s√£o
inteiros e o resultado √© um n√∫mero em ponto flutuante (float), podemos
ver isso, pois ao inv√©s de 42, tivemos como resultado 42.0.

Tamb√©m √© poss√≠vel pedir o resultado inteiro usando o operador
\texttt{div}:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{div}\NormalTok{(}\FloatTok{84}\NormalTok{,}\FloatTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
42
\end{verbatim}

Ou de forma equivalente usando o operador \texttt{\textbackslash{}div}
(para conseguir ver o s√≠mbolo da divis√£o √© necess√°rio digitar
\texttt{\textbackslash{}div} seguido da tecla
\texttt{\textless{}tab\textgreater{}}).

Al√©m das contas b√°sicas, tamb√©m d√° para fazer a exponencia√ß√£o:

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{2}\OperatorTok{\^{}}\FloatTok{31}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2147483648
\end{verbatim}

Express√µes mais complexas tamb√©m podem ser calculadas:

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{23} \OperatorTok{+} \FloatTok{2} \OperatorTok{*} \FloatTok{2} \OperatorTok{+} \FloatTok{3} \OperatorTok{*} \FloatTok{4}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
39
\end{verbatim}

Sim, a preced√™ncia de operadores usual tamb√©m √© v√°lida em Julia. Mas,
segue a primeira li√ß√£o de programa√ß√£o: \emph{Escreva para humanos, n√£o
para m√°quinas}.

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{23} \OperatorTok{+}\NormalTok{ (}\FloatTok{2} \OperatorTok{*} \FloatTok{2}\NormalTok{) }\OperatorTok{+}\NormalTok{ (}\FloatTok{3} \OperatorTok{*} \FloatTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
39
\end{verbatim}

Em Julia tamb√©m podemos fazer opera√ß√µes com n√∫meros em ponto flutuante:

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{23.5} \OperatorTok{*} \FloatTok{3.14}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
73.79
\end{verbatim}

ou

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{12.5} \OperatorTok{/} \FloatTok{2.0}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
6.25
\end{verbatim}

Acima temos mais um exemplo de c√≥digo escrito para pessoas, ao se
escrever 2.0 estamos deixando claro que o segundo par√¢metro √© um n√∫mero
float.

√â importante saber que n√∫meros em ponto flutuante tem precis√£o limitada,
logo n√£o se espante com resultados inesperados como abaixo:

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{1.2} \OperatorTok{{-}} \FloatTok{1.0}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0.19999999999999996
\end{verbatim}

Erros como esse s√£o bastante raros, tanto que usualmente confiamos
plenamente nas contas feitas com computadores e calculadoras. Mas, √© bom
saber que existem limita√ß√µes.

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{2.6} \OperatorTok{{-}} \FloatTok{0.7} \OperatorTok{{-}} \FloatTok{1.9}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2.220446049250313e-16
\end{verbatim}

ou

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{0.1} \OperatorTok{+} \FloatTok{0.2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0.30000000000000004
\end{verbatim}

ou ainda

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{10e15} \OperatorTok{+} \FloatTok{1} \OperatorTok{{-}} \FloatTok{10e15}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
0.0
\end{verbatim}

Esses problemas de precis√£o est√£o ligados a limita√ß√£o de como os n√∫meros
s√£o representados no computador. De maneira simplificada, os valores no
computador s√£o codificados em palavras, formadas por bits. Nos
computadores modernos as palavras tem 64 bits, ou 8 bytes. Logo, uma
outra limita√ß√£o est√° ligada aos n√∫meros inteiros muito grandes

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{2}\OperatorTok{\^{}}\FloatTok{63}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
-9223372036854775808
\end{verbatim}

Mas, para um curso introdut√≥rio basta saber que existem essas
limita√ß√µes. Como lidar com elas √© parte de um curso mais avan√ßado.

√â importante notar que o erro acima √© um \emph{erro silencioso}, ou seja
quanto estamos usando n√∫meros inteiros, pode ocorrer que o n√∫mero a ser
representado n√£o caiba no n√∫mero de bits dispon√≠vel, o que faz com que
ocorra um erro.

Voltando para as contas. Um outro operador interessante √© o \texttt{\%}
que faz o resto da divis√£o

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{4} \OperatorTok{\%} \FloatTok{3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1
\end{verbatim}

At√© agora vimos como trabalhar com um √∫nico valor, ou seja, como se
fosse no visor de uma calculadora. Mas, √© poss√≠vel ir al√©m. Ao inv√©s de
termos teclas de mem√≥ria, o computador nos oferece vari√°veis. Elas s√£o
como nomes para valores que queremos guardar e usar mais tarde.

Al√©m das opera√ß√µes b√°sicas tamb√©m temos as opera√ß√µes matem√°ticas
(fun√ß√µes), como por exemplo o seno, sin em ingl√™s. Para saber como uma
fun√ß√£o funciona podemos pedir ajuda ao ambiente, usando uma \texttt{?}
ou o macro \texttt{@doc}, e em seguida digitando o que queremos saber,
como por exemplo em:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{@doc}\NormalTok{ sin}
\end{Highlighting}
\end{Shaded}

A sa√≠da desse comando indica a opera√ß√£o que a fun√ß√£o realiza e ainda
apresenta alguns exemplos:

\begin{verbatim}
  sin(x)

  Compute sine of x, where x is in radians.

  See also sind, sinpi, sincos, cis, asin.

  Examples
  ‚â°‚â°‚â°‚â°‚â°‚â°‚â°‚â°

  julia> round.(sin.(range(0, 2pi, length=9)'), digits=3)
  1√ó9 Matrix{Float64}:
   0.0  0.707  1.0  0.707  0.0  -0.707  -1.0  -0.707  -0.0
\end{verbatim}

Ambos os comandos \texttt{?\ sin} \texttt{@doc\ sin} possuem a mesma
sa√≠da.

Notem que nem tudo que foi apresentado faz sentido no momento, mas j√° d√°
para entender o uso de uma fun√ß√£o como sin. Vejamos agora a raiz
quadrada:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{@doc}\NormalTok{ sqrt}
\end{Highlighting}
\end{Shaded}

Nela vemos que √© poss√≠vel calcular a raiz como em:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sqrt}\NormalTok{(}\FloatTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2.0
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{sqrt}\NormalTok{(}\FloatTok{4.0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2.0
\end{verbatim}

Mas, observamos tamb√©m na documenta√ß√£o a fun√ß√£o \texttt{big()}, que tem
a seguinte ajuda:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{@doc} \DataTypeTok{BigInt}
\end{Highlighting}
\end{Shaded}

A fun√ß√£o \texttt{big()} em Julia √© usada para criar n√∫meros inteiros
grandes, representados pelo tipo BigInt. Essa fun√ß√£o √© especialmente
√∫til quando voc√™ precisa lidar com n√∫meros muito grandes que excedem o
limite dos tipos inteiros padr√£o, como Int64 ou Int32.

Com n√∫meros BigInt, j√° n√£o h√° problemas de estouro, como podemos ver
abaixo:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{big}\NormalTok{(}\FloatTok{2}\NormalTok{) }\OperatorTok{\^{}} \FloatTok{1002}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
42860344287450692837937001962400072422456192468221344297750015534814042044997444899727935152627834325103786916702125873007485811427692561743938310298794299215738271099296923941684298420249484567511816728612185899934327765069595070236662175784308251658284785910746168670641719326610497547348822672277504
\end{verbatim}

Podemos ainda carregar fun√ß√µes de outros arquivos em nosso arquivo Julia
ou no pr√≥prio terminal, para isso basta utilizar o comando
\texttt{include("caminho/do/arquivo.jl")}, Julia l√™ o arquivo
especificado e executa todo o seu conte√∫do no contexto atual. Isso
significa que todas as fun√ß√µes, vari√°veis e defini√ß√µes no arquivo
tornam-se dispon√≠veis no ambiente onde \texttt{include} foi chamado.

Como por exemplo no primeiro caso tenho um arquivo chamado
\texttt{funcoes.jl} que possui a fun√ß√£o soma:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{ola}\NormalTok{(nome)}
    \FunctionTok{println}\NormalTok{(}\StringTok{"Ol√°"}\NormalTok{, nome)}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
ola (generic function with 1 method)
\end{verbatim}

Podemos incluir essa fun√ß√£o em um segundo arquivo utilizando o
\texttt{include("funcoes.jl")}, e utilizar a fun√ß√£o definida no arquivo
\texttt{funcoes.jl}

\begin{verbatim}
    include("funcoes.jl")
    println(ola("Alfredo"))  
\end{verbatim}

Cuja sa√≠da dever√° ser \texttt{Ol√°\ Alfredo}.

\section{Vari√°veis e seus tipos}\label{variuxe1veis-e-seus-tipos}

Em Julia tamb√©m temos o conceito de vari√°veis, que servem para armazenar
os diferentes conte√∫dos de dados poss√≠veis.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=} \FloatTok{7}
\FloatTok{2} \OperatorTok{+}\NormalTok{ a}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
9
\end{verbatim}

\subsection{Tipagem din√¢mica}\label{tipagem-dinuxe2mica}

√â importante notar que as vari√°veis em Julia podem receber novos valores
e o tipo da vari√°vel depende do que foi atribu√≠do por √∫ltimo.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=} \FloatTok{3}
\FunctionTok{typeof}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Int64
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=}\NormalTok{ a }\OperatorTok{+} \FloatTok{1}
\FunctionTok{typeof}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Int64
\end{verbatim}

Neste pr√≥ximo exemplo, a vari√°vel b √© inicializada com um valor de tipo
inteiro, contudo, ap√≥s a opera√ß√£o de multiplica√ß√£o, seu valor √© do tipo
ponto flutuante:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{b }\OperatorTok{=} \FloatTok{3}
\NormalTok{b }\OperatorTok{=}\NormalTok{ b }\OperatorTok{*} \FloatTok{0.5}
\FunctionTok{typeof}\NormalTok{(b)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Float64
\end{verbatim}

A tipagem din√¢mica apresenta diversas vantagens, entre elas a
flexibilidade, pois √© poss√≠vel reutilizar vari√°veis para armazenar
diferentes tipos de dados ao longo do tempo; e menos verbosidade, pois
n√£o √© necess√°rio especificar o tipo de cada vari√°vel, o que melhora a
legibilidade do c√≥digo.

Aproveitando o momento, podemos ver que h√° v√°rios tipos primitivos em
Julia, sendo os principais:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{typeof}\NormalTok{(}\FloatTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Int64
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{typeof}\NormalTok{(}\FloatTok{1.1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Float64
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{typeof}\NormalTok{(}\StringTok{"Bom dia"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
String
\end{verbatim}

Falando em Strings, elas s√£o definidas por conjuntos de caracteres entre
aspas como:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s1 }\OperatorTok{=} \StringTok{"Olha que legal"}
\NormalTok{s2 }\OperatorTok{=} \StringTok{"Outra String"}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
"Outra String"
\end{verbatim}

D√° tamb√©m para fazer opera√ß√µes com strings como concatena√ß√£o:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s1 }\OperatorTok{=} \StringTok{"Tenha um"}
\NormalTok{s2 }\OperatorTok{=} \StringTok{" Bom dia"}
\NormalTok{s3 }\OperatorTok{=}\NormalTok{ s1 }\OperatorTok{*}\NormalTok{ s2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
"Tenha um Bom dia"
\end{verbatim}

Ou pot√™ncia:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{s }\OperatorTok{=} \StringTok{"Nao vou mais fazer coisas que possam desagradar os meus colegas "}
\NormalTok{s }\OperatorTok{\^{}} \FloatTok{10}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
"Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fa" ‚ãØ 98 bytes ‚ãØ "s meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas "
\end{verbatim}

Ainda sobre vari√°veis, h√° umas regras com rela√ß√£o aos seus nomes, tem
que come√ßar com uma letra (ou com \texttt{\_}), pode ter d√≠gitos e n√£o
pode ser uma palavra reservada. √â bom notar que Julia por ser uma
linguagem moderna, aceita nomes de caracteres em unicode, por exemplo o
Œî (\texttt{\textbackslash{}Delta}):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Œî }\OperatorTok{=} \FloatTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2
\end{verbatim}

Mas, a linguagem vai bem al√©m com caracteres de animais e s√≠mbolos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{üê± }\OperatorTok{=} \FloatTok{5} \CommentTok{\# \textbackslash{}:cat: \textless{}tab\textgreater{}}
\NormalTok{üê∂ }\OperatorTok{=} \FloatTok{3} \CommentTok{\# \textbackslash{}:dog: \textless{}tab\textgreater{}}
\NormalTok{üè† }\OperatorTok{=} \FloatTok{20} \CommentTok{\# \textbackslash{}:house: \textless{}tab\textgreater{}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
20
\end{verbatim}

Isso n√£o adiciona nada do lado de algoritmos, mas √© poss√≠vel ter
vari√°veis bem bonitinhas. A lista de figuras pode ser encontrada
\href{://docs.julialang.org/en/v1/manual/unicode-input/}{aqui}.

\section{Sa√≠da de dados}\label{sauxedda-de-dados}

Para fazer sa√≠das usam-se dois comandos, \texttt{print()} e o
\texttt{println()}, sendo que o primeiro n√£o pula linha e o segundo
pula.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{print}\NormalTok{(}\StringTok{"Hello "}\NormalTok{)}
\FunctionTok{println}\NormalTok{(}\StringTok{"World!"}\NormalTok{)}
\FunctionTok{println}\NormalTok{(}\StringTok{"Ola, mundo!"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Hello World!
Ola, mundo!
\end{verbatim}

Para evitar que se digitem muitos caracteres, por vezes podemos usar
``a√ßucares sint√°ticos''.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{=} \FloatTok{1}
\NormalTok{x }\OperatorTok{=}\NormalTok{ x }\OperatorTok{+} \FloatTok{1}
\NormalTok{x }\OperatorTok{+=} \FloatTok{1}  \CommentTok{\# forma equivalente a acima, o mesmo vale para os operadores *, {-} e /}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
3
\end{verbatim}

Acima, vimos a forma de se inserir coment√°rios em Julia (sim esses ser√£o
ignorados pelo computador).

Exerc√≠cio: Fa√ßa o passo a passo para encontrar as ra√≠zes da equa√ß√£o de
segundo grau \(x^2 - 5 x + 6\), usando as v√°riaveis \texttt{a},
\texttt{b}, \texttt{c}, \texttt{\textbackslash{}Delta}, \texttt{x1} e
\texttt{x2}. Ap√≥s isso, compare com a solu√ß√£o a seguir:

\begin{Shaded}
\begin{Highlighting}[]

\CommentTok{\# Defini√ß√£o dos coeficientes}
\NormalTok{a }\OperatorTok{=} \FloatTok{1}
\NormalTok{b }\OperatorTok{=} \OperatorTok{{-}}\FloatTok{5}
\NormalTok{c }\OperatorTok{=} \FloatTok{6}

\CommentTok{\# C√°lculo do discriminante}
\NormalTok{delta }\OperatorTok{=}\NormalTok{ b}\OperatorTok{\^{}}\FloatTok{2} \OperatorTok{{-}} \FloatTok{4} \OperatorTok{*}\NormalTok{ a }\OperatorTok{*}\NormalTok{ c}

\CommentTok{\# C√°lculo das ra√≠zes}
\ControlFlowTok{if}\NormalTok{ delta }\OperatorTok{\textgreater{}=} \FloatTok{0}
\NormalTok{    x1 }\OperatorTok{=}\NormalTok{ (}\OperatorTok{{-}}\NormalTok{b }\OperatorTok{+} \FunctionTok{sqrt}\NormalTok{(delta)) }\OperatorTok{/}\NormalTok{ (}\FloatTok{2} \OperatorTok{*}\NormalTok{ a)}
\NormalTok{    x2 }\OperatorTok{=}\NormalTok{ (}\OperatorTok{{-}}\NormalTok{b }\OperatorTok{{-}} \FunctionTok{sqrt}\NormalTok{(delta)) }\OperatorTok{/}\NormalTok{ (}\FloatTok{2} \OperatorTok{*}\NormalTok{ a)}
    \FunctionTok{println}\NormalTok{(}\StringTok{"As ra√≠zes s√£o: x1 = }\SpecialCharTok{$}\NormalTok{x1}\StringTok{ e x2 = }\SpecialCharTok{$}\NormalTok{x2}\StringTok{"}\NormalTok{)}
\ControlFlowTok{else}
    \FunctionTok{println}\NormalTok{(}\StringTok{"A equa√ß√£o n√£o possui ra√≠zes reais."}\NormalTok{)}
\ControlFlowTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
As ra√≠zes s√£o: x1 = 3.0 e x2 = 2.0
\end{verbatim}

\bookmarksetup{startatroot}

\chapter{Introdu√ß√£o √†s
Fun√ß√µes}\label{introduuxe7uxe3o-uxe0s-funuxe7uxf5es}

Objetivo: Come√ßar a entender como funcionam as fun√ß√µes em uma linguagem
de programa√ß√£o

\section{O uso de fun√ß√µes √© uma abstra√ß√£o
natural}\label{o-uso-de-funuxe7uxf5es-uxe9-uma-abstrauxe7uxe3o-natural}

Na aula passada j√° vimos umas fun√ß√µes e isso foi bem natural, foram
elas:

\begin{itemize}
\item
  typeof() - Dado um par√¢metro devolve o seu tipo. Vari√°veis est√£o
  associadas a tipos;
\item
  div() - Dados dois par√¢metros devolve a divis√£o inteira do primeiro
  pelo segundo;
\item
  print() e println() - Dados diversos par√¢metros os imprime, sem
  devolver nada.
\end{itemize}

Inclusive, aqui vale a pena ver que podemos pedir ajuda ao Julia para
saber o que fazem as fun√ß√µes. Para isso, se usa o ? antes da fun√ß√£o:

\begin{verbatim}
?typeof()
?div()
?print()
\end{verbatim}

Ao fazer isso, inclusive descobrimos que o div() pode ser usado tamb√©m
como \div.

Uma outra fun√ß√£o bem √∫til √© a que permite transformar um tipo de valor
em outro.

\begin{verbatim}
parse(Float64, "32")
\end{verbatim}

Para convers√£o de valores em ponto flutuante para inteiros, temos a
fun√ß√£o trunc.

\begin{verbatim}
trunc(Int64, 2.25)
\end{verbatim}

De forma inversa temos o float.

\begin{verbatim}
float(2)
\end{verbatim}

Finalmente, podemos transformar um valor em uma string, como em:

\begin{verbatim}
string(3)
\end{verbatim}

ou

\begin{verbatim}
string(3.57)
\end{verbatim}

Tamb√©m tem muitas fun√ß√µes matem√°ticas prontas como

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.2714}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 2\tabcolsep) * \real{0.7286}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Fun√ß√£o
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Descri√ß√£o
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{sin(x)} & Calcula o seno de ( x ) em radianos \\
\texttt{cos(x)} & Calcula o cosseno de ( x ) em radianos \\
\texttt{tan(x)} & Calcula a tangente de ( x ) em radianos \\
\texttt{deg2rad(x)} & Converte ( x ) de graus em radianos \\
\texttt{rad2deg(x)} & Converte ( x ) de radianos em graus \\
\texttt{log(x)} & Calcula o logaritmo natural de ( x ) \\
\texttt{log(b,\ x)} & Calcula o logaritmo de ( x ) na base ( b ) \\
\texttt{log2(x)} & Calcula o logaritmo de ( x ) na base 2 \\
\texttt{log10(x)} & Calcula o logaritmo de ( x ) na base 10 \\
\texttt{exp(x)} & Calcula o expoente da base natural de ( x ) \\
\texttt{abs(x)} & Calcula o m√≥dulo de ( x ) \\
\texttt{sqrt(x)} & Calcula a raiz quadrada de ( x ) \\
\texttt{cbrt(x)} & Calcula a raiz c√∫bica de ( x ) \\
\texttt{factorial(x)} & Calcula o fatorial de ( x ) \\
\end{longtable}

A melhor forma de se acostumar a usar as fun√ß√µes √© fazendo contas e
verificando os resultados. Uma dica importante √© que para fun√ß√µes mais
complexas, pode ser que j√° existam fun√ß√µes prontas em Julia. Para isso
uma busca com as palavras chave. Um exemplo a seguir para procurar a
fun√ß√£o para o c√°lculo de seno hiperb√≥lico: ``julia lang hiperbolic
sin''. A busca pelo termo em ingl√™s √© uma boa dica para buscas em geral.

Em julia tamb√©m √© poss√≠vel criar fun√ß√µes conforme as suas necessidades,
como abaixo:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{mensagemDeBomDia}\NormalTok{()}
   \FunctionTok{println}\NormalTok{(}\StringTok{"Tenha um bom dia!"}\NormalTok{)}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
mensagemDeBomDia (generic function with 1 method)
\end{verbatim}

Para usar uma fun√ß√£o, basta cham√°-la:

\begin{verbatim}
MensagemDeBomDia()
\end{verbatim}

Fun√ß√µes, podem receber um ou mais par√¢metros:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{imprime}\NormalTok{(a)}
   \FunctionTok{println}\NormalTok{(}\StringTok{" Vou imprimir "}\NormalTok{, a)}
\KeywordTok{end}
\FunctionTok{imprime}\NormalTok{(}\FloatTok{42}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 Vou imprimir 42
\end{verbatim}

Tamb√©m √© poss√≠vel que uma fun√ß√£o chame outra fun√ß√£o como em:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{imprimeduasvezes}\NormalTok{(a)}
   \FunctionTok{imprime}\NormalTok{(a)}
   \FunctionTok{imprime}\NormalTok{(a)}
\KeywordTok{end}
\FunctionTok{imprimeduasvezes}\NormalTok{(}\FloatTok{13}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
 Vou imprimir 13
 Vou imprimir 13
\end{verbatim}

Mais ainda, tamb√©m √© poss√≠vel diferenciar fun√ß√µes por meio da quantidade
de par√¢metros.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{recebe}\NormalTok{(a)}
  \FunctionTok{println}\NormalTok{(}\StringTok{"Recebi um parametro: "}\NormalTok{, a)}
\KeywordTok{end}
\KeywordTok{function} \FunctionTok{recebe}\NormalTok{(a, b)}
  \FunctionTok{println}\NormalTok{(}\StringTok{"Recebi dois parametros: "}\NormalTok{, a, }\StringTok{" "}\NormalTok{, b)}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
recebe (generic function with 2 methods)
\end{verbatim}

Conforme a chamada, a fun√ß√£o chamada ser√° diferente:

\begin{verbatim}
recebe(1)
recebe(1, 2)
\end{verbatim}

Tamb√©m d√° para chamar fun√ß√µes com vari√°veis e com opera√ß√µes, como em:

\begin{verbatim}
a = 10
recebe(a)
recebe(a, a + 1)
\end{verbatim}

As fun√ß√µes que vimos at√© agora imprimem mensagens, mas n√£o devolvem
nada. O typeof() delas √© nothing, ou seja, algo que n√£o pode ser
atribu√≠do.

Mas, tamb√©m √© poss√≠vel fazer fun√ß√µes que devolvem valores, como:

\begin{verbatim}
function soma1(a)
  return a + 1
end
\end{verbatim}

Nesse caso, se for passado um par√¢metro num√©rico, a fun√ß√£o devolver√° o
valor incrementado (adicionado de 1).

Claro que isso pode ser usado com f√≥rmulas mais complicadas como:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{hipotenusa}\NormalTok{(a, b)}
\NormalTok{  hip }\OperatorTok{=}\NormalTok{ a }\OperatorTok{*}\NormalTok{ a }\OperatorTok{+}\NormalTok{ b }\OperatorTok{*}\NormalTok{ b}
  \ControlFlowTok{return}\NormalTok{ hip}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
hipotenusa (generic function with 1 method)
\end{verbatim}

Exerc√≠cio: Fa√ßa uma fun√ß√£o para encontrar o \Delta de uma equa√ß√£o de
segundo grau

\bookmarksetup{startatroot}

\chapter{Compara√ß√µes, o comando if e
recurs√£o}\label{comparauxe7uxf5es-o-comando-if-e-recursuxe3o}

Antes de falar em desvio (if), vamos ver um novo tipo de vari√°vel que
foi introduzido de forma natural. O tipo booleando, ou seja uma vari√°vel
que pode valer true (verdadeiro) ou false (falso). O seu uso est√°
intimamente ligado ao if.

Observem os seguintes exemplos:

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{2} \OperatorTok{+} \FloatTok{2} \OperatorTok{==} \FloatTok{4}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
true
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{3} \OperatorTok{!=} \FloatTok{8}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
true
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{23} \OperatorTok{\textless{}} \FloatTok{24}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
true
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{42} \OperatorTok{\textless{}=} \FloatTok{44}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
true
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\FloatTok{42} \OperatorTok{\textless{}} \FloatTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
false
\end{verbatim}

Vale chamar a aten√ß√£o, como em linguagens de programa√ß√£o o = √© usado
para atribui√ß√µes, para compara√ß√µes se usa o \texttt{==}. Da mesma forma
o != √© usado como diferente. Esses operadores, em conjunto com o
\texttt{\textless{}}, \texttt{\textless{}=}, \texttt{\textgreater{}} e
\texttt{\textgreater{}=} nos permitem comparar valores.

Sobre as vari√°veis booleanas vale tamb√©m observar o seu tipo. Uma
explica√ß√£o mais aprofundada sobre como essas vari√°veis funcionam ser√°
fornecida quando abordarmos os operadores condicionais:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{typeof}\NormalTok{(}\FloatTok{2} \OperatorTok{==} \FloatTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Bool
\end{verbatim}

Finalmente, tamb√©m podemos negar vari√°veis booleanas para inverter o seu
valor:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{!}\ConstantTok{true}
\NormalTok{!}\ConstantTok{false}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
true
\end{verbatim}

Nessa aula, vamos aprender um novo comando. O desvio condicional,
atrav√©s dele √© poss√≠vel alterar o fluxo de execu√ß√£o de um programa. At√©
o momento n√£o t√≠nhamos comentado isso explicitamente, mas a ordem de
execu√ß√£o de instru√ß√µes segue a ordem em que elas est√£o. Vejamos o
exemplo abaixo:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{println}\NormalTok{(}\StringTok{"Oi"}\NormalTok{)}
\FunctionTok{println}\NormalTok{(}\StringTok{"um"}\NormalTok{)}
\FunctionTok{println}\NormalTok{(}\StringTok{"dois"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Oi
um
dois
\end{verbatim}

A ordem de impress√£o ser√° Oi, um e dois.

Da mesma forma n√£o temos problema ao executar o c√≥digo abaixo.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{denominador }\OperatorTok{=} \FloatTok{0}
\NormalTok{denominador }\OperatorTok{+=} \FloatTok{2}
\FloatTok{30} \OperatorTok{/}\NormalTok{ denominador}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
15.0
\end{verbatim}

Apesar da vari√°vel denominador come√ßar inicialmente com 0, antes de se
fazer a divis√£o, ela estar√° valendo 2.

Como √© de se esperar nem sempre queremos que essa ordem seja respeitada.
Observe o seguinte exemplo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pandemia }\OperatorTok{=} \ConstantTok{true}
\FunctionTok{println}\NormalTok{(}\StringTok{"Vou sair de casa?"}\NormalTok{)}
\ControlFlowTok{if}\NormalTok{ pandemia }\OperatorTok{==} \ConstantTok{true}
   \FunctionTok{println}\NormalTok{(}\StringTok{"S√≥ vou sair de casa se for essencial"}\NormalTok{)}
\ControlFlowTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Vou sair de casa?
S√≥ vou sair de casa se for essencial
\end{verbatim}

O exemplo acima √© claro, se uma condi√ß√£o for verdadeira, o c√≥digo que
est√° no escopo do if (isso √© entre a condi√ß√£o e o end) ser√° executado.

Um outro exemplo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{denominador }\OperatorTok{=} \FloatTok{1}
\ControlFlowTok{if}\NormalTok{ denominador }\OperatorTok{!=} \FloatTok{0}
   \FunctionTok{println}\NormalTok{(}\StringTok{"sei fazer a divis√£o se n√£o for por zero"}\NormalTok{)}
   \FunctionTok{println}\NormalTok{(}\StringTok{"o resultado da divis√£o de 30 por "}\NormalTok{, denominador, }\StringTok{" √© igual a "}\NormalTok{, }\FloatTok{30}\OperatorTok{/}\NormalTok{denominador)}
\ControlFlowTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
sei fazer a divis√£o se n√£o for por zero
o resultado da divis√£o de 30 por 1 √© igual a 30.0
\end{verbatim}

Situa√ß√µes muito comuns em computa√ß√£o devem ser favorecidas pela
linguagem, nesse caso do if, √© muito comum termos duas ou mais
situa√ß√µes. Nesse sentido em Julia podemos tamb√©m ter alternativas como
abaixo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{ pandemia }\OperatorTok{=} \ConstantTok{true}
 \FunctionTok{println}\NormalTok{(}\StringTok{"Vou sair de casa?"}\NormalTok{)}
 \ControlFlowTok{if}\NormalTok{ pandemia }\OperatorTok{==} \ConstantTok{true}
    \FunctionTok{println}\NormalTok{(}\StringTok{"S√≥ vou sair de casa se for essencial"}\NormalTok{)}
 \ControlFlowTok{else}
    \FunctionTok{println}\NormalTok{(}\StringTok{"Balada liberada!!"}\NormalTok{)}
 \ControlFlowTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Vou sair de casa?
S√≥ vou sair de casa se for essencial
\end{verbatim}

No caso de termos mais de uma altenativa, n√£o basta termos s√≥ uma
condi√ß√£o, nesse caso temos que usar elseif.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pandemia }\OperatorTok{=} \ConstantTok{true}
\NormalTok{tenhoqueestudar }\OperatorTok{=} \ConstantTok{true}
\FunctionTok{println}\NormalTok{(}\StringTok{"Vou sair de casa?"}\NormalTok{)}
\ControlFlowTok{if}\NormalTok{ pandemia }\OperatorTok{==} \ConstantTok{true}
  \FunctionTok{println}\NormalTok{(}\StringTok{"S√≥ vou sair de casa se for essencial"}\NormalTok{)}
\ControlFlowTok{elseif}\NormalTok{ tenhoqueestudar }\OperatorTok{==} \ConstantTok{true}
  \FunctionTok{println}\NormalTok{(}\StringTok{"Melhor ficar em casa"}\NormalTok{)}
\ControlFlowTok{else}
  \FunctionTok{println}\NormalTok{(}\StringTok{"Balada liberada"}\NormalTok{)}
\ControlFlowTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Vou sair de casa?
S√≥ vou sair de casa se for essencial
\end{verbatim}

Conhecendo o if, agora, escreva uma fun√ß√£o que recebe os coeficientes,
a, b e c de uma equa√ß√£o de segundo grau e imprime as suas ra√≠zes reais.

Sim, a forma de se aprender a programar √© programando.

Vamos agora a parte mais importante do curso, lembrando que at√© o
momento aprendemos: - valores - var√≠aveis e alguns dos seus tipos -
alguma fun√ß√µes j√° prontas como div(), typeof(), parse(), string(),
println(), sin(), etc - como fazer as nossas fun√ß√µes com a palavra
reservada function e que termina por end - lembrando que a fun√ß√£o pode
ou n√£o devolver algo atrav√©s do return - lembrando tamb√©m que uma fun√ß√£o
pode chamar outra fun√ß√£o - como mudar o fluxo de execu√ß√£o normal com o
if, elseif

\section{Agora sim: Fun√ß√µes que se
chamam}\label{agora-sim-funuxe7uxf5es-que-se-chamam}

Agora podemos, ir ao t√≥pico principal da aula.

Observe a seguinte fun√ß√£o imprime().

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{imprime}\NormalTok{()}
    \FunctionTok{println}\NormalTok{(}\StringTok{"Mensagem positiva"}\NormalTok{)}
    \FunctionTok{imprime}\NormalTok{()}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
imprime (generic function with 1 method)
\end{verbatim}

Ao ser chamada, o que acontece? O computador far√° chamadas seguidas a
fun√ß√£o, imprimindo a mensagem, at√© o momento que ocorra uma limita√ß√£o de
mem√≥ria. Logo, fazer chamadas onde uma fun√ß√£o se chama, sem controle n√£o
√© uma boa ideia.

Por outro lado, podemos pensar em uma forma de chamada controlada, onde
a pr√≥pria fun√ß√£o decide o momento de parar de se chamar. Para isso,
vamos pegar uma fun√ß√£o matem√°tica bem conhecida, o fatorial.

Sabemos que 5! = 5.4.3.2.1. Mais, ainda dado um n√∫mero n, sabemos que n!
= n.(n - 1)! Continuando, temos que (n - 1)! = (n - 1).(n - 2)! e assim
por diante. Para reproduzir isso no computador precisamos saber quando
parar. Para isso, podemos usar que o fatorial de zero √© 1, ou 0! = 1.
Logo j√° temos a primeira parte da fun√ß√£o:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{fatorial}\NormalTok{(n)}
 \ControlFlowTok{if}\NormalTok{ n }\OperatorTok{==} \FloatTok{0}
   \ControlFlowTok{return} \FloatTok{1}
 \ControlFlowTok{else}
   \CommentTok{\# o que vamos colocar aqui?}
\ControlFlowTok{end}
\end{Highlighting}
\end{Shaded}

No c√≥digo acima, temos o crit√©rio de parada, ou seja quando n for igual
a zero, a resposta ser√° 1. Mas, e se n n√£o for zero. Nesse caso, temos
que seguir a f√≥rmula da recurs√£o ou seja n.(n - 1)!. Como (n - 1)! pode
ser escrito como fatorial(n - 1). Ficamos com a express√£o n * fatorial(n
- 1).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{fatorial}\NormalTok{(n)}
 \CommentTok{\# Crit√©rio de parada: quando n √© igual a 0, a recurs√£o termina}
 \ControlFlowTok{if}\NormalTok{ n }\OperatorTok{==} \FloatTok{0}
   \ControlFlowTok{return} \FloatTok{1}
 \ControlFlowTok{else}
   \ControlFlowTok{return}\NormalTok{ n }\OperatorTok{*} \FunctionTok{fatorial}\NormalTok{(n }\OperatorTok{{-}} \FloatTok{1}\NormalTok{) }\CommentTok{\# Chamada recursiva}
 \ControlFlowTok{end}
\KeywordTok{end}
\FunctionTok{fatorial}\NormalTok{(}\FloatTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
120
\end{verbatim}

Vamos a um segundo exemplo, a contagem regressiva. Mais uma vez, quando
se chega a zero, podemos considerar que a contagem terminou. Al√©m disso,
a cada n√∫mero, o pr√≥ximo passo √© o n√∫mero menos 1.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{contagem}\NormalTok{(n)}
   \ControlFlowTok{if}\NormalTok{ n }\OperatorTok{\textless{}} \FloatTok{0}
       \FunctionTok{println}\NormalTok{(}\StringTok{"Bum!"}\NormalTok{)}
   \ControlFlowTok{else}
       \FunctionTok{print}\NormalTok{(n, }\StringTok{" "}\NormalTok{)}
       \FunctionTok{contagem}\NormalTok{(n }\OperatorTok{{-}} \FloatTok{1}\NormalTok{)}
   \ControlFlowTok{end}
\KeywordTok{end}
\FunctionTok{contagem}\NormalTok{(}\FloatTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
5 4 3 2 1 0 Bum!
\end{verbatim}

Essa estrutura √© bem poderosa, pois permite que opera√ß√µes sejam
executadas um n√∫mero controlado de vezes. Voltando ao countdown, imagine
que ao inv√©s de imprimir uma mensagem quis√©ssemos fazer uma conta com o
que ser√° devolvido.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{soma}\NormalTok{(n)}
 \ControlFlowTok{if}\NormalTok{ n }\OperatorTok{\textgreater{}} \FloatTok{0}
   \ControlFlowTok{return}\NormalTok{ n }\OperatorTok{+} \FunctionTok{soma}\NormalTok{(n }\OperatorTok{{-}} \FloatTok{1}\NormalTok{)}
 \ControlFlowTok{else}
   \ControlFlowTok{return} \FloatTok{0}
 \ControlFlowTok{end}
\KeywordTok{end}

\FunctionTok{soma}\NormalTok{(}\FloatTok{11}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
66
\end{verbatim}

Essa estrutura √© bastante poderosa e pode ser usada para o c√°lculo de
produto, nesse caso, a mudan√ßa √© bem pequena.

Da mesma forma segue um exemplo para o c√°lculo dos n primeiros elementos
da soma h√¢rmonica.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{somaharmonica}\NormalTok{(atual, n)}
 \CommentTok{\# Caso base: se \textquotesingle{}atual\textquotesingle{} √© maior ou igual a \textquotesingle{}n\textquotesingle{}}
 \ControlFlowTok{if}\NormalTok{ atual }\OperatorTok{\textgreater{}=}\NormalTok{ n}
   \CommentTok{\# Retorna o rec√≠proco de \textquotesingle{}atual\textquotesingle{} (√∫ltimo termo da soma)}
   \ControlFlowTok{return} \FloatTok{1.0} \OperatorTok{/}\NormalTok{ atual}
 \ControlFlowTok{else}
   \CommentTok{\# Caso recursivo: soma o rec√≠proco de \textquotesingle{}atual\textquotesingle{} e chama a fun√ß√£o para o pr√≥ximo n√∫mero}
   \ControlFlowTok{return} \FloatTok{1.0} \OperatorTok{/}\NormalTok{ atual }\OperatorTok{+} \FunctionTok{somaharmonica}\NormalTok{(atual }\OperatorTok{+} \FloatTok{1}\NormalTok{, n)}
 \ControlFlowTok{end}
\KeywordTok{end}

\FunctionTok{somaharmonica}\NormalTok{(}\FloatTok{1}\NormalTok{, }\FloatTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
2.9289682539682538
\end{verbatim}

\bookmarksetup{startatroot}

\chapter{}\label{section}

Nessa aula, vamos ver algoritmos um pouco mais elaborados. Mas, sabendo
que vamos usar algo com um maior grau de sofistica√ß√£o, que tal pensar em
testes?

De uma forma geral, para verificar o funcionamento de um programa,
podemos escrever testes que verificam o funcionamento em algumas
situa√ß√µes espec√≠ficas.

Dado que o primeiro problema que queremos resolver √© um algoritmo que
encontra o n-√©simo n√∫mero de Fibonacci. Por que n√£o come√ßar com testes?

Uma forma de se fazr testes, e de forma manual, mas isso n√£o √©
reprodut√≠vel. A melhor maneira de se fazer testes, √© de forma
automatizada, ou seja criar c√≥digo que teste c√≥digo. Isso pode parecer
complicado, mas vamos ver abaixo que n√£o √©.

Em uma busca r√°pida, podemos ver que a sequ√™ncia de Fibonacci √© definida
da seguinte forma, os dois primeiros elementos \(F_1\) e \(F_2\) valem
1, em seguida temos a f√≥rmula \(F_n = F_{n-1} +  F_{n-2}\). Mas, antes
de pensar em resolver o problema vamos pensar em como testar.

J√° sabemos os primeiros valores, al√©m disso, atrav√©s de uma busca
r√°pida, podemos descobrir alguns valores da sequ√™ncia como \(F_5 =  5\)
e \(F_{12}  =
144\). Supondo que a fun√ß√£o para o c√°lculo do n-√©simo n√∫mero de
Fibonacci chamar√° fibo(). Podemos escrever o seguinte trecho de c√≥digo:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{testafibo\_versao1}\NormalTok{()}
  \ControlFlowTok{if} \FunctionTok{fibo}\NormalTok{(}\FloatTok{1}\NormalTok{) }\OperatorTok{==} \FloatTok{1}
    \FunctionTok{println}\NormalTok{(}\StringTok{"Deu certo para 1"}\NormalTok{)}
  \ControlFlowTok{end}
  \ControlFlowTok{if} \FunctionTok{fibo}\NormalTok{(}\FloatTok{2}\NormalTok{) }\OperatorTok{==} \FloatTok{1}
    \FunctionTok{println}\NormalTok{(}\StringTok{"Deu certo para 2"}\NormalTok{)}
  \ControlFlowTok{end}
  \ControlFlowTok{if} \FunctionTok{fibo}\NormalTok{(}\FloatTok{5}\NormalTok{) }\OperatorTok{==} \FloatTok{5}
    \FunctionTok{println}\NormalTok{(}\StringTok{"Deu certo para 5"}\NormalTok{)}
  \ControlFlowTok{end}
  \ControlFlowTok{if} \FunctionTok{fibo}\NormalTok{(}\FloatTok{12}\NormalTok{) }\OperatorTok{==} \FloatTok{144}
    \FunctionTok{println}\NormalTok{(}\StringTok{"Deu certo para 12"}\NormalTok{)}
  \ControlFlowTok{end}
  \FunctionTok{println}\NormalTok{(}\StringTok{"Final dos testes"}\NormalTok{)}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
testafibo_versao1 (generic function with 1 method)
\end{verbatim}

A fun√ß√£o de testes acima verifica se a fun√ß√£o fibo() devolve o resultado
correto para tr√™s casos. Mas, ela tem um defeito, ela imprime mensagens
demais, o que pode ser ruim. Considerando isso, vamos ver o primeiro
fundamento importante com rela√ß√£o a testes automatizados.

\emph{Se o teste passou, ele deve indicar apenas que deu certo!}

Levando em conta o que foi escrito acima, podemos mudar o nosso teste
para:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{testafibo}\NormalTok{()}
  \ControlFlowTok{if} \FunctionTok{fibo}\NormalTok{(}\FloatTok{1}\NormalTok{) }\OperatorTok{!=} \FloatTok{1}
    \FunctionTok{println}\NormalTok{(}\StringTok{"N√£o deu certo para 1"}\NormalTok{)}
  \ControlFlowTok{end}
  \ControlFlowTok{if} \FunctionTok{fibo}\NormalTok{(}\FloatTok{2}\NormalTok{) }\OperatorTok{!=} \FloatTok{1}
    \FunctionTok{println}\NormalTok{(}\StringTok{"N√£o deu certo para 2"}\NormalTok{)}
  \ControlFlowTok{end}
  \ControlFlowTok{if} \FunctionTok{fibo}\NormalTok{(}\FloatTok{5}\NormalTok{) }\OperatorTok{!=} \FloatTok{5}
    \FunctionTok{println}\NormalTok{(}\StringTok{"N√£o eu certo para 5"}\NormalTok{)}
  \ControlFlowTok{end}
  \ControlFlowTok{if} \FunctionTok{fibo}\NormalTok{(}\FloatTok{12}\NormalTok{) }\OperatorTok{!=} \FloatTok{144}
    \FunctionTok{println}\NormalTok{(}\StringTok{"N√£o deu certo para 12"}\NormalTok{)}
  \ControlFlowTok{end}
  \FunctionTok{println}\NormalTok{(}\StringTok{"Final dos testes"}\NormalTok{)}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
testafibo (generic function with 1 method)
\end{verbatim}

Agora de posse da nossa fun√ß√£o de testes, podemos pensar em escrever a
nossa fun√ß√£o de Fibonacci. Vamos ao caso f√°cil de n for menor que 2, a
resposta √© 1. Como vemos abaixo:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{fibo}\NormalTok{(n)}
    \ControlFlowTok{if}\NormalTok{ n }\OperatorTok{\textless{}=} \FloatTok{2}
        \ControlFlowTok{return} \FloatTok{1}
    \ControlFlowTok{else}
        \CommentTok{\# ainda n√£o sabemos o que colocar aqui...}
    \ControlFlowTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
fibo (generic function with 1 method)
\end{verbatim}

Mas, a resposta est√° na pr√≥pria defini√ß√£o da fun√ß√£o, ou seja:
\(F_n = F_{n-1} +  F_{n-2}\). Se o \(n\) for maior do que 2, temos que
fazer a soma dos valores de Fibonacci de \(n-1\) e de \(n-2\). Ou seja:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{fibo}\NormalTok{(n)}
    \ControlFlowTok{if}\NormalTok{ n }\OperatorTok{\textless{}=} \FloatTok{2}
        \ControlFlowTok{return} \FloatTok{1}
    \ControlFlowTok{else}
        \ControlFlowTok{return} \FunctionTok{fibo}\NormalTok{(n }\OperatorTok{{-}} \FloatTok{1}\NormalTok{) }\OperatorTok{+} \FunctionTok{fibo}\NormalTok{(n }\OperatorTok{{-}} \FloatTok{2}\NormalTok{)}
    \ControlFlowTok{end}
\KeywordTok{end}

\FunctionTok{fibo}\NormalTok{(}\FloatTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
55
\end{verbatim}

√â interessante notar que apesar de ser um dos exemplos cl√°ssicos de uso
de recurs√£o, o algoritmo acima √© extremamente ineficiente. A raz√£o √©
simples, cada vez que √© feita a chamada, toda os valores de Fibonacci
s√£o recalculados para os valores de \(n\) e \(n-1\).

Como Julia √© uma linguagem moderna podemos usar o conceito de
Memoiza√ß√£o, que evita calcular o que j√° foi calculado. O Memoize tem que
ser instalado no Julia com os comandos \texttt{import\ Pkg} e
\texttt{Pkg.add("Memoize")}.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{using} \BuiltInTok{Memoize}
\PreprocessorTok{@memoize} \KeywordTok{function} \FunctionTok{fibo}\NormalTok{(n)}
    \ControlFlowTok{if}\NormalTok{ n }\OperatorTok{\textless{}=} \FloatTok{2}
        \ControlFlowTok{return} \FloatTok{1}
    \ControlFlowTok{else}
        \ControlFlowTok{return} \FunctionTok{fibo}\NormalTok{(n }\OperatorTok{{-}} \FloatTok{1}\NormalTok{) }\OperatorTok{+} \FunctionTok{fibo}\NormalTok{(n }\OperatorTok{{-}} \FloatTok{2}\NormalTok{)}
    \ControlFlowTok{end}
\KeywordTok{end}

\FunctionTok{fibo}\NormalTok{(}\FloatTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
55
\end{verbatim}

As diferen√ßas de tempo das duas vers√µes podem ser verificada com o
comando @time. Da seguinte forma:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{@time} \FunctionTok{fibo}\NormalTok{(}\FloatTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
  0.000003 seconds
\end{verbatim}

\begin{verbatim}
55
\end{verbatim}

Esse tipo de comando, que come√ßa com @ √© conhecido como anota√ß√£o, e tem
o poder de mudar o comportamente de partes do c√≥digo.

Vamos ao segundo algoritmo da aula, o MDC (M√°ximo Divisor Comum). A
ideia √© usar o algoritmo de Euclides.

Basicamente ele diz que o MDC de dois n√∫meros a e b, √© igual ao MDC de b
e r, onde \(r=a\% b\). Quando esse resto for zero, chegamos a solu√ß√£o,
que √© b.

Vamos come√ßar com os testes para alguns valores bem conhecidos. Por
sinal come√ßar pelos testes antes de escrever o c√≥digo √© uma boa pr√°tica
de programa√ß√£o conhecida por TDD (Test Driven Design).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{testaMDC}\NormalTok{()}
    \ControlFlowTok{if} \FunctionTok{MDC}\NormalTok{(}\FloatTok{3298}\NormalTok{, }\FloatTok{2031}\NormalTok{)}\OperatorTok{!=} \FloatTok{1}
        \FunctionTok{println}\NormalTok{(}\StringTok{"deu erro, para 3298 e 2031"}\NormalTok{)}
    \ControlFlowTok{end}
    \ControlFlowTok{if} \FunctionTok{MDC}\NormalTok{(}\FloatTok{120}\NormalTok{, }\FloatTok{36}\NormalTok{)}\OperatorTok{!=} \FloatTok{12}
        \FunctionTok{println}\NormalTok{(}\StringTok{"deu erro, para 120 e 36"}\NormalTok{)}
    \ControlFlowTok{end}
    \ControlFlowTok{if} \FunctionTok{MDC}\NormalTok{(}\FloatTok{36}\NormalTok{, }\FloatTok{120}\NormalTok{)}\OperatorTok{!=} \FloatTok{12}
        \FunctionTok{println}\NormalTok{(}\StringTok{"deu erro, para 36 e 120"}\NormalTok{)}
    \ControlFlowTok{end}
    \FunctionTok{println}\NormalTok{(}\StringTok{"Acabaram os testes"}\NormalTok{)}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
testaMDC (generic function with 1 method)
\end{verbatim}

Vamos pensar na fun√ß√£o agora. Dessa vez, se o resto for 0, temos que
devolver o segundo termo. Caso contr√°rio temos que continuar com a regra

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{MDC}\NormalTok{(a, b)}
\NormalTok{    r }\OperatorTok{=}\NormalTok{ a }\OperatorTok{\%}\NormalTok{ b}
    \ControlFlowTok{if}\NormalTok{ r }\OperatorTok{==} \FloatTok{0}
        \ControlFlowTok{return}\NormalTok{ b}
    \ControlFlowTok{else}
        \ControlFlowTok{return} \FunctionTok{MDC}\NormalTok{(b, r)}
    \ControlFlowTok{end}
\KeywordTok{end}

\FunctionTok{testaMDC}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Acabaram os testes
\end{verbatim}

At√© agora usamos o modo interativo do Julia para fazer os nosso c√≥digos.
Mas, existe oura forma bem mais reutiliz√°vel, ou seja escrever o texto
em arqivos. Isso √© relativamente simples, basta usar um editor de texto
(puro) da sua prefer√™ncia, como o notepad, nano, juno, atom, vscode ou
outro e salvar um arquivo com a extens√£o .jl.

Mas, para que algo seja executado √© importante colocar uma chamada ao
final. Veja abaixo um poss√≠vel arquivo mdc.jl.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{testeMDC}\NormalTok{()}
    \ControlFlowTok{if} \FunctionTok{mdc}\NormalTok{(}\FloatTok{70}\NormalTok{, }\FloatTok{5}\NormalTok{) }\OperatorTok{!=} \FloatTok{5}
        \FunctionTok{println}\NormalTok{(}\StringTok{"N√£o funcionou para 70 e 5"}\NormalTok{)}
    \ControlFlowTok{end}
    \ControlFlowTok{if} \FunctionTok{mdc}\NormalTok{(}\FloatTok{13}\NormalTok{, }\FloatTok{7}\NormalTok{) }\OperatorTok{!=} \FloatTok{1}
        \FunctionTok{println}\NormalTok{(}\StringTok{"N√£o funcionou para 13 e 7"}\NormalTok{)}
    \ControlFlowTok{end}
    \ControlFlowTok{if} \FunctionTok{mdc}\NormalTok{(}\FloatTok{127}\NormalTok{, }\FloatTok{15}\NormalTok{) }\OperatorTok{!=} \FloatTok{1}
        \FunctionTok{println}\NormalTok{(}\StringTok{"N√£o funcionou para 127 e 15"}\NormalTok{)}
    \ControlFlowTok{end}
    \ControlFlowTok{if} \FunctionTok{mdc}\NormalTok{(}\FloatTok{20}\NormalTok{, }\FloatTok{15}\NormalTok{) }\OperatorTok{!=} \FloatTok{5}
        \FunctionTok{println}\NormalTok{(}\StringTok{"N√£o funcionou para 20 e 15"}\NormalTok{)}
    \ControlFlowTok{end}
    \ControlFlowTok{if} \FunctionTok{mdc}\NormalTok{(}\FloatTok{42}\NormalTok{, }\FloatTok{3}\NormalTok{) }\OperatorTok{!=} \FloatTok{3}
        \FunctionTok{println}\NormalTok{(}\StringTok{"N√£o funcionou para 42 e 3"}\NormalTok{)}
    \ControlFlowTok{end}
    \ControlFlowTok{if} \FunctionTok{mdc}\NormalTok{(}\FloatTok{42}\NormalTok{, }\FloatTok{8}\NormalTok{) }\OperatorTok{!=} \FloatTok{2}
        \FunctionTok{println}\NormalTok{(}\StringTok{"N√£o funcionou para 42 e 8"}\NormalTok{)}
    \ControlFlowTok{end}
    \FunctionTok{println}\NormalTok{(}\StringTok{"Final dos testes"}\NormalTok{)}
\KeywordTok{end}

\KeywordTok{function} \FunctionTok{mdc}\NormalTok{(a, b)}
\NormalTok{    r }\OperatorTok{=}\NormalTok{ a }\OperatorTok{\%}\NormalTok{ b}
    \ControlFlowTok{if}\NormalTok{ r }\OperatorTok{==} \FloatTok{0}
        \ControlFlowTok{return}\NormalTok{ b}
    \ControlFlowTok{else}
        \FunctionTok{mdc}\NormalTok{(b, r)}
    \ControlFlowTok{end}
\KeywordTok{end}

\FunctionTok{testeMDC}\NormalTok{()}
\FunctionTok{println}\NormalTok{(}\StringTok{"O mdc entre 1227 e 321 √© "}\NormalTok{, }\FunctionTok{mdc}\NormalTok{(}\FloatTok{1227}\NormalTok{, }\FloatTok{321}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Final dos testes
O mdc entre 1227 e 321 √© 3
\end{verbatim}

\bookmarksetup{startatroot}

\chapter{Testes automatizados e um pouco mais de
c√≥digo}\label{testes-automatizados-e-um-pouco-mais-de-cuxf3digo}

Vamos come√ßar o cap√≠tulo vendo uma forma mais simples de se rodar
testes. Nos testes que vimos at√© agora sempre havia o teste de uma
condi√ß√£o booleana associado a uma mensagem de erro quando n√£o
funcionasse. Mas, observando que a mensagem de erro geralmente est√°
ligada √† condi√ß√£o, por vezes a condi√ß√£o pode ser auto-explicativa.

Logo, uma forma elegante de expressar as condi√ß√µes pode ser √∫til na
escrita dos testes. Para isso, vamos usar o m√≥dulo de testes. Em
linguagens modernas, v√°rias das situa√ß√µes repetitivas que enfrentamos
podem ser evitadas usando alguma t√©cnica mais moderna.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{using} \BuiltInTok{Test}  
\PreprocessorTok{@testset} \StringTok{"Modelo de testes"} \ControlFlowTok{begin}
    \PreprocessorTok{@test} \FloatTok{2} \OperatorTok{==} \FloatTok{1} \OperatorTok{+} \FloatTok{1}
    \PreprocessorTok{@test} \ConstantTok{true}
    \PreprocessorTok{@test}\NormalTok{ !}\ConstantTok{false}
\ControlFlowTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Test Summary:    | Pass  Total  Time
Modelo de testes |    3      3  0.0s
\end{verbatim}

\begin{verbatim}
Test.DefaultTestSet("Modelo de testes", Any[], 3, false, false, true, 1.729115739073162e9, 1.729115739095434e9, false, "/home/lucas/√Årea de trabalho/livro-alfredo/aulas/07.qmd")
\end{verbatim}

No trecho acima primeiro indicamos que queremos fazer testes. Em seguida
usamos o \emph{test} que espera uma condi√ß√£o ou valor booleano.
Finalmente todos os testes s√£o reunidos em um \emph{testset}.

Claro que o teste d√° infoma√ß√µes relevantes quando falha:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{using} \BuiltInTok{Test}
\PreprocessorTok{@test} \FloatTok{2} \OperatorTok{+} \FloatTok{2} \OperatorTok{!=} \FloatTok{4}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Test Failed at REPL[2]:1
  Expression: 2 + 2 != 4
   Evaluated: 4 != 4
\end{verbatim}

Agora sim, vamos pensar em problemas algoritmicos novos. Que tal fazer a
soma dos d√≠gitos de um n√∫mero inteiro. Ou seja, pensar em um n√∫mero
d√≠gito √† d√≠gito. Vamos aos testes primeiro:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{using} \BuiltInTok{Test}
\PreprocessorTok{@testset} \StringTok{"Teste da Soma de D√≠gitos"} \ControlFlowTok{begin}
    \PreprocessorTok{@test} \FunctionTok{somaDig}\NormalTok{(}\FloatTok{0}\NormalTok{) }\OperatorTok{==} \FloatTok{0}
    \PreprocessorTok{@test} \FunctionTok{somaDig}\NormalTok{(}\FloatTok{1}\NormalTok{) }\OperatorTok{==} \FloatTok{1}
    \PreprocessorTok{@test} \FunctionTok{somaDig}\NormalTok{(}\FloatTok{100}\NormalTok{) }\OperatorTok{==} \FloatTok{1}
    \PreprocessorTok{@test} \FunctionTok{somaDig}\NormalTok{(}\FloatTok{123}\NormalTok{) }\OperatorTok{==} \FloatTok{6}
    \PreprocessorTok{@test} \FunctionTok{somaDig}\NormalTok{(}\FloatTok{321}\NormalTok{) }\OperatorTok{==} \FloatTok{6}
    \PreprocessorTok{@test} \FunctionTok{somaDig}\NormalTok{(}\FloatTok{99}\NormalTok{) }\OperatorTok{==} \FloatTok{18}
\ControlFlowTok{end}
\end{Highlighting}
\end{Shaded}

Vamos agora tentar pensar em como ``descascar'' um n√∫mero, dado o n√∫mero
123, uma forma seria pegar o resto por 10 (ou seja 3) e depois dividir
por 10 (ou seja 12), e assim por diante. Ou seja.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{somaDig}\NormalTok{(n)}
    \ControlFlowTok{if}\NormalTok{ n }\OperatorTok{\textless{}=}\FloatTok{0} \ControlFlowTok{return} \FloatTok{0}
    \ControlFlowTok{else}
        \ControlFlowTok{return}\NormalTok{ n }\OperatorTok{\%} \FloatTok{10} \OperatorTok{+} \FunctionTok{somaDig}\NormalTok{(n }\OperatorTok{√∑} \FloatTok{10}\NormalTok{)}
    \ControlFlowTok{end}
\KeywordTok{end}

\FunctionTok{println}\NormalTok{(}\FunctionTok{somaDig}\NormalTok{(}\FloatTok{1234}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
10
\end{verbatim}

Vamos agora a um outro problema cl√°ssico, a verifica√ß√£o se um n√∫mero √©
ou n√£o √© primo. Na pr√°tica para fazer isso, temos a defini√ß√£o, um n√∫mero
\(n\) √© primo apenas se for divis√≠vel apenas por 1 e por ele mesmo. Ou
seja, nenhum n√∫mero entre 2 e \(n - 1\) pode ser divisor de um n√∫mero
primo.

A forma de se fazer isso √© relativamente simples. Vamos pensar em uma
fun√ß√£o que tenta dividir um n√∫mero recursivamente, se conseguir devolve
falso, se n√£o conseguir devolve verdadeiro.

Vamos aos c√≥digo:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{divide}\NormalTok{(n, i)}
    \ControlFlowTok{if}\NormalTok{ n }\OperatorTok{\%}\NormalTok{ i }\OperatorTok{==} \FloatTok{0}
        \ControlFlowTok{return} \ConstantTok{false}
    \ControlFlowTok{elseif}\NormalTok{ i }\OperatorTok{==}\NormalTok{ n }\OperatorTok{{-}} \FloatTok{1}
        \ControlFlowTok{return} \ConstantTok{true}
    \ControlFlowTok{else}
        \ControlFlowTok{return} \FunctionTok{divide}\NormalTok{(n, i }\OperatorTok{+} \FloatTok{1}\NormalTok{)}
    \ControlFlowTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
divide (generic function with 1 method)
\end{verbatim}

Que pode ser chamada por:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{√©Primo}\NormalTok{(n)}
    \ControlFlowTok{return} \FunctionTok{divide}\NormalTok{(n, }\FloatTok{2}\NormalTok{)}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
√©Primo (generic function with 1 method)
\end{verbatim}

Mais um exemplo, o m√©todo de Newton para o c√°lculo de raiz quadrada.
Para achar a raiz de \(x\), a partir de um chute inicial (por exemplos
\(y= x /2\)), chegamos a um novo chute que √© a m√©dia de \(y\) e \(x/y\).

Mas, sim, vamos come√ßar com os testes. Como estamos usando n√∫meros do
tipo \emph{double} √© bom sempre ter uma toler√¢ncia, por isso vamos usar
uma compara√ß√£o aproximada. Tamb√©m poderiamos ter usado a fun√ß√£o
\emph{isapprox} da linguagem Julia.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{using} \BuiltInTok{Test}
\KeywordTok{function} \FunctionTok{quaseIgual}\NormalTok{(a, b)}
    \ControlFlowTok{if} \FunctionTok{abs}\NormalTok{(a }\OperatorTok{{-}}\NormalTok{ b) }\OperatorTok{\textless{}=} \FloatTok{1e{-}10}
        \ControlFlowTok{return} \ConstantTok{true}
    \ControlFlowTok{else}
        \ControlFlowTok{return} \ConstantTok{false}
    \ControlFlowTok{end}
\KeywordTok{end}


\PreprocessorTok{@testset} \StringTok{"Teste da raiz pelo m√©todo de Newton"} \ControlFlowTok{begin}
    \PreprocessorTok{@test} \FunctionTok{quaseIgual}\NormalTok{(}\FloatTok{3.0}\NormalTok{, }\FunctionTok{raiz}\NormalTok{(}\FloatTok{3.0} \OperatorTok{*} \FloatTok{3.0}\NormalTok{))}
    \PreprocessorTok{@test} \FunctionTok{quaseIgual}\NormalTok{(}\FloatTok{33.7}\NormalTok{, }\FunctionTok{raiz}\NormalTok{(}\FloatTok{33.7} \OperatorTok{*} \FloatTok{33.7}\NormalTok{))}
    \PreprocessorTok{@test} \FunctionTok{quaseIgual}\NormalTok{(}\FloatTok{223.7}\NormalTok{, }\FunctionTok{raiz}\NormalTok{(}\FloatTok{223.7} \OperatorTok{*} \FloatTok{223.7}\NormalTok{))}
    \PreprocessorTok{@test} \FunctionTok{quaseIgual}\NormalTok{(}\FloatTok{0.7}\NormalTok{, }\FunctionTok{raiz}\NormalTok{(}\FloatTok{0.7} \OperatorTok{*} \FloatTok{0.7}\NormalTok{))}
    \PreprocessorTok{@test} \FunctionTok{quaseIgual}\NormalTok{(}\FloatTok{1.0}\NormalTok{, }\FunctionTok{raiz}\NormalTok{(}\FloatTok{1.0} \OperatorTok{*} \FloatTok{1.0}\NormalTok{))}
\ControlFlowTok{end}
\end{Highlighting}
\end{Shaded}

Note que como estamos comparando n√∫meros em ponto flutuante, n√£o usamos
a compara√ß√£o exata.

A solu√ß√£o final √©:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{newton}\NormalTok{(c, n)}
\NormalTok{    q }\OperatorTok{=}\NormalTok{ n }\OperatorTok{/}\NormalTok{ c}
    \ControlFlowTok{if} \FunctionTok{quaseIgual}\NormalTok{(q, c)}
        \ControlFlowTok{return}\NormalTok{ q}
    \ControlFlowTok{else}
        \ControlFlowTok{return} \FunctionTok{newton}\NormalTok{( (c }\OperatorTok{+}\NormalTok{ q) }\OperatorTok{/} \FloatTok{2.0}\NormalTok{, n)}
    \ControlFlowTok{end}
\KeywordTok{end}


\KeywordTok{function} \FunctionTok{raiz}\NormalTok{(n)}
\NormalTok{    a }\OperatorTok{=}  \FunctionTok{newton}\NormalTok{(n }\OperatorTok{/} \FloatTok{2.0}\NormalTok{, n)}
    \FunctionTok{println}\NormalTok{(}\StringTok{"a raiz de "}\NormalTok{, n, }\StringTok{" √© "}\NormalTok{, a)}
    \ControlFlowTok{return}\NormalTok{ a}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
raiz (generic function with 1 method)
\end{verbatim}

\section{Fun√ß√µes ca√≥ticas}\label{funuxe7uxf5es-cauxf3ticas}

Vamos brincar um pouco agora com fun√ß√µes ca√≥ticas :), isso √©, fun√ß√µes,
que conforme o comportamento de uma constante \(k\), apresentam
resultados que podem convergir ou n√£o. Isso √©, a cada passo, quero saber
o valor do pr√≥ximo ponto aplicando a fun√ß√£o novamente, isso √©:
\[x_1 = f(x_0), x_2 = f(x_1), \ldots, x_n  = f(x_{n - 1})\]

As fun√ß√µes ca√≥ticas desempenham um papel significativo em diversas √°reas
da matem√°tica e da f√≠sica, com aplica√ß√µes que v√£o desde a modelagem de
crescimento populacional at√© a previs√£o de padr√µes clim√°ticos. Elas
tamb√©m s√£o fundamentais na an√°lise de circuitos el√©tricos n√£o lineares,
onde pequenas varia√ß√µes nas condi√ß√µes iniciais podem levar a resultados
drasticamente diferentes.

Para o nosso teste, a fun√ß√£o \(f\) √© extremamente simples:
\(x_{i + 1}=x_i * (1 -  x_i) * k\).

Implemente a fun√ß√£o e imprima os 30 primeiros resultados. Comece com um
valor de \(x\) entre 0 e 1, como 0.2. Use constantes
\(k = 2.1, 2.5, 2.8\) e \(3.1\) o que ocorre com \(k = 3.7\)?

Entregue o c√≥digo e um pequeno relat√≥rio sobre o que acontece.

\bookmarksetup{startatroot}

\chapter{Uma outra forma de se fazer
la√ßos}\label{uma-outra-forma-de-se-fazer-lauxe7os}

At√© o momento vimos que o computador √© muito bom para fazer contas e
repeti√ß√µes. Fizemos isso at√© agora com fun√ß√µes recursivas. Mas, existe
um outro comando para isso, o while. A motiva√ß√£o √© que enquanto alguma
condi√ß√£o for v√°lida, o computador continua repetindo os comandos.

O formato b√°sico √© o seguinte:

\begin{verbatim}
while condi√ß√£o
  # execute obloco
end  
\end{verbatim}

Enquanto a condi√ß√£o continuar verdadeira, o computador vai seguir
repetindo o bloco que pode ser formado por v√°rias intru√ß√µes. Logo, para
que a repeti√ß√£o, ou la√ßo, n√£o seja repetido indefinidamente, √© essencial
que algo ligado a condi√ß√£o seja atualizado no corpo do while.

Vejamos o exemplo simples da contagem regressiva:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n }\OperatorTok{=} \FloatTok{5}
\ControlFlowTok{while}\NormalTok{ n }\OperatorTok{\textgreater{}} \FloatTok{0}
  \FunctionTok{println}\NormalTok{(n)}
\NormalTok{  n }\OperatorTok{=}\NormalTok{ n }\OperatorTok{{-}} \FloatTok{1}
\ControlFlowTok{end}
\FunctionTok{println}\NormalTok{(}\StringTok{"Acabou"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
5
4
3
2
1
Acabou
\end{verbatim}

Mas, vamos ver abaixo um caso onde o uso de while deixa o c√≥digo mais
Claro que com a recurs√£o (onde √© ruim fazer uma com v√°rios par√£metros).
Veja a resolu√ß√£o da s√©rie de Taylor abaixo:

\begin{Shaded}
\begin{Highlighting}[]
 \KeywordTok{function} \FunctionTok{sinTaylor2}\NormalTok{(x)}
\NormalTok{   i }\OperatorTok{=} \FloatTok{1}
\NormalTok{   termo }\OperatorTok{=}\NormalTok{ x}
\NormalTok{   soma }\OperatorTok{=} \FloatTok{0.0}
   \ControlFlowTok{while}\NormalTok{ i }\OperatorTok{\textless{}=} \FloatTok{15}
\NormalTok{     soma }\OperatorTok{=}\NormalTok{ soma }\OperatorTok{+}\NormalTok{ termo}
\NormalTok{     termo }\OperatorTok{=} \OperatorTok{{-}}\FloatTok{1} \OperatorTok{*}\NormalTok{ termo }\OperatorTok{*}\NormalTok{ x }\OperatorTok{*}\NormalTok{ x }\OperatorTok{/}\NormalTok{ ((}\FloatTok{2} \OperatorTok{*}\NormalTok{ i) }\OperatorTok{*}\NormalTok{ (}\FloatTok{2} \OperatorTok{*}\NormalTok{ i }\OperatorTok{+} \FloatTok{1}\NormalTok{))}
\NormalTok{     i }\OperatorTok{=}\NormalTok{ i }\OperatorTok{+} \FloatTok{1}
   \ControlFlowTok{end}
   \ControlFlowTok{return}\NormalTok{ soma}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
sinTaylor2 (generic function with 1 method)
\end{verbatim}

Nela s√£o calculados os 15 primeiros termos.

Observem a vers√£o recursiva:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{sinTaylor}\NormalTok{(x)}
    \ControlFlowTok{return} \FunctionTok{sinTaylorRec}\NormalTok{(}\FloatTok{1}\NormalTok{, }\FloatTok{15}\NormalTok{, x, }\FloatTok{1}\NormalTok{, x)}
\KeywordTok{end}

\KeywordTok{function} \FunctionTok{sinTaylorRec}\NormalTok{(i, n, x, sinal, termo)}
    \ControlFlowTok{if}\NormalTok{ n }\OperatorTok{==}\NormalTok{ i}
      \ControlFlowTok{return} \FloatTok{0.0}
    \ControlFlowTok{else}
      \ControlFlowTok{return}\NormalTok{ sinal }\OperatorTok{*}\NormalTok{ termo }\OperatorTok{+}
         \FunctionTok{sinTaylorRec}\NormalTok{(i }\OperatorTok{+} \FloatTok{1}\NormalTok{, n, x, }\OperatorTok{{-}}\FloatTok{1} \OperatorTok{*}\NormalTok{ sinal, termo }\OperatorTok{*}\NormalTok{ x }\OperatorTok{*}\NormalTok{ x}\OperatorTok{/}\NormalTok{ (}\FloatTok{2}\OperatorTok{*}\NormalTok{i }\OperatorTok{*}\NormalTok{ (}\FloatTok{2}\OperatorTok{*}\NormalTok{i}\OperatorTok{+}\FloatTok{1}\NormalTok{)))}
    \ControlFlowTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
sinTaylorRec (generic function with 1 method)
\end{verbatim}

Podemos tamb√©m fazer opera√ß√µes com os d√≠gitos de um n√∫mero inteiro, para
isso opera√ß√µes como o resto da divis√£o por 10 e a divis√£o inteira por 10
s√£o bastante √∫teis. Abaixo temos as duas vers√µes que fazem a soma dos
d√≠gitos de um n√∫mero inteiro.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{using} \BuiltInTok{Test}
\KeywordTok{function} \FunctionTok{testaSD}\NormalTok{()}
  \PreprocessorTok{@test} \FunctionTok{sd}\NormalTok{(}\FloatTok{123}\NormalTok{) }\OperatorTok{==} \FloatTok{6}
  \PreprocessorTok{@test} \FunctionTok{sd}\NormalTok{(}\FloatTok{321}\NormalTok{) }\OperatorTok{==} \FloatTok{6}
  \PreprocessorTok{@test} \FunctionTok{sd}\NormalTok{(}\FloatTok{0}\NormalTok{) }\OperatorTok{==} \FloatTok{0}
  \PreprocessorTok{@test} \FunctionTok{sd}\NormalTok{(}\FloatTok{1001}\NormalTok{) }\OperatorTok{==} \FloatTok{2}
  \PreprocessorTok{@test} \FunctionTok{sd}\NormalTok{(}\FloatTok{3279}\NormalTok{) }\OperatorTok{==} \FloatTok{21}
  \FunctionTok{println}\NormalTok{(}\StringTok{"Fim dos testes"}\NormalTok{)}
\KeywordTok{end}

\KeywordTok{function} \FunctionTok{sd}\NormalTok{(x)}
  \ControlFlowTok{if}\NormalTok{ x }\OperatorTok{==} \FloatTok{0}
     \ControlFlowTok{return} \FloatTok{0}
  \ControlFlowTok{else}
\NormalTok{     d }\OperatorTok{=}\NormalTok{ x }\OperatorTok{\%} \FloatTok{10}
     \ControlFlowTok{return}\NormalTok{ d }\OperatorTok{+} \FunctionTok{sd}\NormalTok{(}\FunctionTok{div}\NormalTok{(x, }\FloatTok{10}\NormalTok{))}
  \ControlFlowTok{end}
\KeywordTok{end}

\KeywordTok{function} \FunctionTok{sd1}\NormalTok{(x)}
\NormalTok{  soma }\OperatorTok{=} \FloatTok{0}
  \ControlFlowTok{while}\NormalTok{ x }\OperatorTok{!=} \FloatTok{0}
\NormalTok{   d }\OperatorTok{=}\NormalTok{ x }\OperatorTok{\%} \FloatTok{10}
\NormalTok{   soma }\OperatorTok{=}\NormalTok{ soma }\OperatorTok{+}\NormalTok{ d}
\NormalTok{   x }\OperatorTok{=} \FunctionTok{div}\NormalTok{(x, }\FloatTok{10}\NormalTok{)}
  \ControlFlowTok{end}
  \ControlFlowTok{return}\NormalTok{ soma}
\KeywordTok{end}
\FunctionTok{testaSD}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Fim dos testes
\end{verbatim}

\bookmarksetup{startatroot}

\chapter{Aula de exerc√≠cios}\label{aula-de-exercuxedcios}

\section{Revisitando o c√°lculo do fatorial, recursivo e
interativo}\label{revisitando-o-cuxe1lculo-do-fatorial-recursivo-e-interativo}

Agora que aprendemos a fazer tamb√©m repeti√ß√µes com o comando while,
sempre √© bom pensar em qual o comando mais adequado. Vejamos o exemplo
abaixo com duas vers√µes da fun√ß√£o para o c√°lculo do Fatorial.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{fatorial\_recursivo}\NormalTok{(n}\OperatorTok{::}\DataTypeTok{Int64}\NormalTok{) }\CommentTok{\# Com o ::Int64 estamos definindo que o par√¢metro da fun√ß√£o deve ser um n√∫mero inteiro}
    \CommentTok{\# Caso base do fatorial: 0! e 1! s√£o iguais a 1}
    \ControlFlowTok{if}\NormalTok{ n }\OperatorTok{==} \FloatTok{0} \OperatorTok{||}\NormalTok{ n }\OperatorTok{==} \FloatTok{1}
        \ControlFlowTok{return} \FloatTok{1}
    \CommentTok{\# Chamada recursiva: n! = n * (n{-}1)!}
    \ControlFlowTok{else}
        \ControlFlowTok{return}\NormalTok{ n }\OperatorTok{*} \FunctionTok{fatorial\_recursivo}\NormalTok{(n }\OperatorTok{{-}} \FloatTok{1}\NormalTok{)}
    \ControlFlowTok{end}
\KeywordTok{end}

\KeywordTok{function} \FunctionTok{fatorial\_iterativo}\NormalTok{(n}\OperatorTok{::}\DataTypeTok{Int64}\NormalTok{)}
    \CommentTok{\# Inicializa o resultado como 1 (j√° que o fatorial de 0 √© 1)}
\NormalTok{    resultado }\OperatorTok{=} \FloatTok{1}

    \CommentTok{\# No loop estamos fazendo a multiplica√ß√£o: n * (n{-}1) * ... * 2}
    \ControlFlowTok{while}\NormalTok{ n }\OperatorTok{\textgreater{}} \FloatTok{1}
        \CommentTok{\# Multiplica o resultado pelo valor atual de n}
\NormalTok{        resultado }\OperatorTok{*=}\NormalTok{ n}

        \CommentTok{\# Decrementa n em 1 para continuar o c√°lculo do fatorial}
\NormalTok{        n }\OperatorTok{{-}=} \FloatTok{1}
    \ControlFlowTok{end}
    \ControlFlowTok{return}\NormalTok{ resultado}
\KeywordTok{end}

\FunctionTok{println}\NormalTok{(}\FunctionTok{fatorial\_recursivo}\NormalTok{(}\FloatTok{3}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
6
\end{verbatim}

No c√≥digo acima temos uma novidade, nos par√¢metros da fun√ß√£o, o tipo
est√° sendo declarado expicitamente. No caso, estamos dizendo que o valor
n que a fun√ß√£o vai receber √© de um tipo espec√≠fico. Ou seja um Inteiro
de 64 bits.

O estilo de c√≥digo est√° um pouco diferente do que antes, pois foi
escrito por outra pessoa. A monitora. Vemos que ela tem o h√°bito de usar
nomes de vari√°veis maiores al√©m do que usar contra√ß√µes como += e *=.

\section{Aproxima√ß√£o da raiz
quadrada}\label{aproximauxe7uxe3o-da-raiz-quadrada}

Para o pr√≥ximo exemplo, vamos ver o m√©todo de Newthon-Raphson para o
c√°lculo da raiz quadrada. √â um m√©todo recursivo no qual o pr√≥ximo valor
√© baseado no valor anterior. Quanto mais chamadas forem feitas, mais
pr√≥ximo do valor final vai se chegar.

Mais informa√ß√µes sobre o m√©todo podem ser encontradas em
\href{https://pt.wikipedia.org/wiki/M\%C3\%A9todo_de_Newton\%E2\%80\%93Raphson}{aqui}.
Mas para o momento temos que pensar na seguinte implementa√ß√£o. Para se
calcular a raiz, podemos usar a seguinte f√≥rmula, a partir de um palpite
inicial r, para o valor da raiz de x.

\[ r_{n+1} = 0.5 * (r + x / r)\]

Como o c√≥digo abaixo √© mais complicado, foram usados coment√°rios.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{aproxima\_raiz}\NormalTok{(x}\OperatorTok{::}\DataTypeTok{Float64}\NormalTok{, epsilon}\OperatorTok{::}\DataTypeTok{Float64}\NormalTok{)}\OperatorTok{::}\DataTypeTok{Float64}
    \ControlFlowTok{if}\NormalTok{ x }\OperatorTok{\textless{}} \FloatTok{0}
        \ControlFlowTok{return} \ConstantTok{nothing}
    \ControlFlowTok{end}

    \CommentTok{\# Chute inicial }
\NormalTok{    aproximacao }\OperatorTok{=}\NormalTok{ x}\OperatorTok{/}\FloatTok{2}
\NormalTok{    melhor\_aproximicao }\OperatorTok{=}\NormalTok{ aproximacao}

    \ControlFlowTok{while} \ConstantTok{true}
        \CommentTok{\# F√≥rmula para aproxima√ß√£o de raiz quadrada utilizando o m√©todo de Newthon{-}Raphson}
\NormalTok{        melhor\_aproximicao }\OperatorTok{=} \FloatTok{0.5} \OperatorTok{*}\NormalTok{ (aproximacao }\OperatorTok{+}\NormalTok{ x}\OperatorTok{/}\NormalTok{aproximacao)}

        \CommentTok{\# Se a dist√¢ncia absoluta entre os dois pontos √© menor do que epsilon, ent√£o podemos parar o m√©todo}
        \ControlFlowTok{if} \FunctionTok{abs}\NormalTok{(aproximacao }\OperatorTok{{-}}\NormalTok{ melhor\_aproximicao) }\OperatorTok{\textless{}=}\NormalTok{ epsilon}
            \ControlFlowTok{break}
        \ControlFlowTok{end}

        \CommentTok{\# Se a aproxima√ß√£o ainda n√£o for boa o sufuciente, ent√£o atualizamos a aproxima√ß√£o para a pr√≥xima itera√ß√£o}
\NormalTok{        aproximacao }\OperatorTok{=}\NormalTok{ melhor\_aproximicao}
    \ControlFlowTok{end}

    \ControlFlowTok{return}\NormalTok{ melhor\_aproximicao}

\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
aproxima_raiz (generic function with 1 method)
\end{verbatim}

Notem que foi introduzido um comando novo, o break, esse comando apenas
interrompe a execu√ß√£o do while. Ou seja, for√ßa a sa√≠da do la√ßo.

\section{Verificar se um n√∫mero √©
primo}\label{verificar-se-um-nuxfamero-uxe9-primo}

No pr√≥ximo exemplo, vamos verificar se um n√∫mero √© primo, ou seja, se os
seus √∫nicos divisores s√£o 1 e o pr√≥prio. A forma mais simples de se
fazer isso √© procurando dividir o n√∫mero por outros. Se algum dividir, o
n√∫mero n√£o √© primo.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{verifica\_primo}\NormalTok{(num }\OperatorTok{::}\DataTypeTok{ Int64}\NormalTok{)}
    \ControlFlowTok{if}\NormalTok{ num }\OperatorTok{\textless{}=} \FloatTok{1}
        \ControlFlowTok{return} \ConstantTok{false}
    \ControlFlowTok{end}
\NormalTok{    i}\OperatorTok{=}\FloatTok{2}
    \CommentTok{\# pode ser melhorado com i\textless{}=num/2}
    \CommentTok{\# ou tamb√©m com i\textless{}= sqrt(num): baseado no fato que um n√∫mero composto deve ter um fator menor ou igual a raiz desse n√∫mero}
    \ControlFlowTok{while}\NormalTok{ i}\OperatorTok{\textless{}}\NormalTok{num}
        \ControlFlowTok{if}\NormalTok{ num }\OperatorTok{\%}\NormalTok{ i }\OperatorTok{==} \FloatTok{0}
            \ControlFlowTok{return} \ConstantTok{false}
        \ControlFlowTok{end}
\NormalTok{        i}\OperatorTok{+=}\FloatTok{1}
    \ControlFlowTok{end}
    \ControlFlowTok{return} \ConstantTok{true}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
verifica_primo (generic function with 1 method)
\end{verbatim}

Assim, como o comando break √© usado para interromper a execu√ß√£o de um
la√ßo, o comando return, pode ser usado para terminar a execu√ß√£o de uma
fun√ß√£o, a qualquer momento.

\section{Verificar se um n√∫mero √©
pal√≠ndromo}\label{verificar-se-um-nuxfamero-uxe9-paluxedndromo}

Um n√∫mero pal√≠ndromo √© um n√∫mero que √© sim√©trico. Ou seja, a leitura dos
d√≠gitos da esquerda para a direita √© igual a leitura dos d√≠gitos na
ordem inversa. Por exemplo, o n√∫mero 121 √© pal√≠ndromo, assim como o 11 e
o 25677652. Os n√∫meros de um d√≠gito tamb√©m s√£o.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{e\_palindromo}\NormalTok{(n}\OperatorTok{::}\DataTypeTok{Int64}\NormalTok{)}
    \CommentTok{\#=}
\CommentTok{        Guarda os d√≠gitos de n que ainda devem ser invertidos}
\CommentTok{        A vari√°vel auxiliar √© necess√°ria para que o valor de n n√£o seja, perdido, e possamos usar ele posteriormente.}
\CommentTok{    =\#}
\NormalTok{    aux }\OperatorTok{=}\NormalTok{ n}
    \CommentTok{\# Guarda a invers√£o do n√∫mero n }
\NormalTok{    n\_inv }\OperatorTok{=} \FloatTok{0}

    \CommentTok{\#=}
\CommentTok{        Continuamos o while enquanto ainda h√° n√∫meros a serem invertidos,}
\CommentTok{        ou seja, enquanto aux for maior que 0.}
\CommentTok{    =\#}
    \ControlFlowTok{while}\NormalTok{ aux }\OperatorTok{\textgreater{}} \FloatTok{0} 
        \CommentTok{\# Coloca o √∫ltimo d√≠gito de aux na vari√°vel que guarda a invers√£o}
\NormalTok{        resto }\OperatorTok{=}\NormalTok{ aux }\OperatorTok{\%} \FloatTok{10}
\NormalTok{        n\_inv}\OperatorTok{=}\NormalTok{ n\_inv }\OperatorTok{*} \FloatTok{10} \OperatorTok{+}\NormalTok{ resto}

        \CommentTok{\# Retira o √∫ltimo d√≠gito de aux}
\NormalTok{        aux }\OperatorTok{=} \FunctionTok{div}\NormalTok{(aux,}\FloatTok{10}\NormalTok{)}
    \ControlFlowTok{end}

    \ControlFlowTok{if}\NormalTok{ n }\OperatorTok{==}\NormalTok{ n\_inv}
        \FunctionTok{println}\NormalTok{(}\StringTok{"O n√∫mero }\SpecialCharTok{$}\NormalTok{n}\StringTok{ √© pal√≠ndromo"}\NormalTok{)}
    \ControlFlowTok{else}
        \FunctionTok{println}\NormalTok{(}\StringTok{"O n√∫mero }\SpecialCharTok{$}\NormalTok{n}\StringTok{ n√£o √© pal√≠ndromo"}\NormalTok{)}
    \ControlFlowTok{end} 
\KeywordTok{end}

\FunctionTok{e\_palindromo}\NormalTok{(}\FloatTok{2002}\NormalTok{)}
\FunctionTok{e\_palindromo}\NormalTok{(}\FloatTok{1234}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
O n√∫mero 2002 √© pal√≠ndromo
O n√∫mero 1234 n√£o √© pal√≠ndromo
\end{verbatim}

\bookmarksetup{startatroot}

\chapter{Revisitando a aula passada}\label{revisitando-a-aula-passada}

Al√©m de discutirmos o que vimos na aula passada. Nessa aula, vimos uma
nova solu√ß√£o para o problema de verificar de um n√∫mero √© pal√≠ndromo.

Para isso usamos uma t√©cnica um pouco diferente, ou seja, ao inv√©s de
inverter o n√∫mero e compar√°-lo com o original. Verificamos se os seus
extremos s√£o iguais.

Observe o n√∫mero 234432, o primeiro passo seria verificar que nos
extremos, mais significativo e menos significativo, temos os n√∫meros 2.
Em seguida, podemos continuar com a verifica√ß√£o para o n√∫mero 3443. Se
em algum momento a verifica√ß√£o falhar o n√∫mero n√£o √© pal√≠ndromo.

Seguem os testes e o c√≥digo abaixo.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{using} \BuiltInTok{Test}

\KeywordTok{function} \FunctionTok{testaPal}\NormalTok{()}
  \PreprocessorTok{@test} \FunctionTok{testaPal}\NormalTok{(}\FloatTok{1}\NormalTok{)}
  \PreprocessorTok{@test} \FunctionTok{testaPal}\NormalTok{(}\FloatTok{131}\NormalTok{)}
  \PreprocessorTok{@test} \FunctionTok{testaPal}\NormalTok{(}\FloatTok{22}\NormalTok{)}
  \PreprocessorTok{@test} \FunctionTok{testaPal}\NormalTok{(}\FloatTok{53877835}\NormalTok{)}
  \PreprocessorTok{@test}\NormalTok{ !}\FunctionTok{testaPal}\NormalTok{(}\FloatTok{123}\NormalTok{)}
  \PreprocessorTok{@test}\NormalTok{ !}\FunctionTok{testaPal}\NormalTok{(}\FloatTok{23452}\NormalTok{)}
  \FunctionTok{println}\NormalTok{(}\StringTok{"Final dos testes"}\NormalTok{)}
\KeywordTok{end}

\KeywordTok{function} \FunctionTok{testaPal}\NormalTok{(n}\OperatorTok{::}\DataTypeTok{Int64}\NormalTok{)}
\CommentTok{\# o primeiro passo √© encontrar um n√∫mero com o mesmo n√∫mero de d√≠gitos de n}
\NormalTok{  pot10 }\OperatorTok{=} \FloatTok{1}
  \ControlFlowTok{while}\NormalTok{ pot10 }\OperatorTok{\textless{}}\NormalTok{ n}
\NormalTok{    pot10 }\OperatorTok{=}\NormalTok{ pot10 }\OperatorTok{*} \FloatTok{10}
  \ControlFlowTok{end}
\NormalTok{  pot10 }\OperatorTok{=} \FunctionTok{div}\NormalTok{(pot10, }\FloatTok{10}\NormalTok{)}


  \ControlFlowTok{while}\NormalTok{ n }\OperatorTok{\textgreater{}} \FloatTok{9}
\NormalTok{    d1 }\OperatorTok{=}\NormalTok{ n }\OperatorTok{\%} \FloatTok{10}
\NormalTok{    d2 }\OperatorTok{=} \FunctionTok{div}\NormalTok{(n, pot10)}
    \ControlFlowTok{if}\NormalTok{ d1 }\OperatorTok{!=}\NormalTok{ d2}
      \ControlFlowTok{return} \ConstantTok{false}
    \ControlFlowTok{end}
\NormalTok{    n }\OperatorTok{=} \FunctionTok{div}\NormalTok{(n }\OperatorTok{\%}\NormalTok{ pot10, }\FloatTok{10}\NormalTok{)}
\NormalTok{    pot10 }\OperatorTok{=} \FunctionTok{div}\NormalTok{(pot10, }\FloatTok{100}\NormalTok{)}
  \ControlFlowTok{end}
  \ControlFlowTok{return} \ConstantTok{true}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
testaPal (generic function with 2 methods)
\end{verbatim}

\section{Aleatoreidade}\label{aleatoreidade}

Em julia temos a fun√ß√£o rand() que devolve um n√∫mero em ponto flutuante
entre 0 e 1. Conforme os par√¢metros, podemos ter outros tipos de n√∫mero
como:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{rand}\NormalTok{(}\DataTypeTok{Int}\NormalTok{)  }\CommentTok{\# devolve um inteiro}
\FunctionTok{rand}\NormalTok{(}\FloatTok{1}\OperatorTok{:}\FloatTok{10}\NormalTok{) }\CommentTok{\# devolve um n√∫mero entre 1 e 10}
\FunctionTok{rand}\NormalTok{(}\DataTypeTok{Bool}\NormalTok{) }\CommentTok{\# devolve verdadeiro ou falso}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
false
\end{verbatim}

Mas, antes de ver um c√≥digo com rand(). Vamos pensar em um problema da
vida real. Imagine que temos que fazer um sorteio justo, e o √∫nico
instrumento que possu√≠mos para o sorteio √© uma moeda viciada. Que tem
como resultado muito mais faces do que coroas. D√° para usar essa moeda
em um sorteio justo?

A ideia para resolver o problema √© olhar para pares de sorteios. Ou
seja, vamos ignorar sorteios onde tenhamos duas faces ou duas coroas.
Nos outros, teremos uma coroa e uma face ou vice versa. As chances das
duas ser√£o de 50\%. Logo podemos assim, corrigir a moeda viciada.

Para simplificar o exerc√≠cio, a moeda pode devolver 0, ou 1,
correspondentes a cara ou a coroa. Observe a seguinte fun√ß√£o que simula
uma moeda viciada.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{sorteio}\NormalTok{()}
  \ControlFlowTok{if} \FunctionTok{rand}\NormalTok{() }\OperatorTok{\textgreater{}} \FloatTok{0.90}
    \ControlFlowTok{return} \FloatTok{1}
  \ControlFlowTok{else} 
    \ControlFlowTok{return} \FloatTok{0}
  \ControlFlowTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
sorteio (generic function with 1 method)
\end{verbatim}

Pode se observar que a fun√ß√£o devolve 0 na maior parte das vezes.
Podemos inclusive ver isso, fazendo mil sorteios:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{verificaSorteio}\NormalTok{()}
\NormalTok{   cara }\OperatorTok{=} \FloatTok{0}
\NormalTok{   coroa }\OperatorTok{=} \FloatTok{0}
\NormalTok{   i }\OperatorTok{=} \FloatTok{0}
   \ControlFlowTok{while}\NormalTok{ i }\OperatorTok{\textless{}} \FloatTok{1000}
     \ControlFlowTok{if} \FunctionTok{sorteio}\NormalTok{() }\OperatorTok{==} \FloatTok{0}
\NormalTok{        cara }\OperatorTok{=}\NormalTok{ cara }\OperatorTok{+} \FloatTok{1}
     \ControlFlowTok{else}
\NormalTok{        coroa }\OperatorTok{=}\NormalTok{ coroa }\OperatorTok{+} \FloatTok{1}
     \ControlFlowTok{end}
\NormalTok{     i }\OperatorTok{=}\NormalTok{ i }\OperatorTok{+} \FloatTok{1}
   \ControlFlowTok{end}
   \FunctionTok{println}\NormalTok{(}\StringTok{"O n√∫mero de caras foi: "}\NormalTok{, cara,}\StringTok{" e de coroas foi :"}\NormalTok{, coroa)}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
verificaSorteio (generic function with 1 method)
\end{verbatim}

Mas, podemos corrigir o sorteio da seguinte forma:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{sorteioBom}\NormalTok{()}
\NormalTok{   sorteio1 }\OperatorTok{=} \FunctionTok{sorteio}\NormalTok{()}
\NormalTok{   sorteio2 }\OperatorTok{=} \FunctionTok{sorteio}\NormalTok{()}
   \ControlFlowTok{while}\NormalTok{ sorteio1 }\OperatorTok{==}\NormalTok{ sorteio2 }\CommentTok{\# se forem iguais, tente novamente}
\NormalTok{     sorteio1 }\OperatorTok{=} \FunctionTok{sorteio}\NormalTok{()}
\NormalTok{     sorteio2 }\OperatorTok{=} \FunctionTok{sorteio}\NormalTok{()}
   \ControlFlowTok{end}
   \ControlFlowTok{return}\NormalTok{ sorteio1   }\CommentTok{\# ao termos um diferente, podemos devolver o primeiro sorteio}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
sorteioBom (generic function with 1 method)
\end{verbatim}

Podemos usar o verificaSorteio para ver a diferen√ßa.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{verificaSorteio}\NormalTok{()}
\NormalTok{   cara }\OperatorTok{=} \FloatTok{0}
\NormalTok{   coroa }\OperatorTok{=} \FloatTok{0}
\NormalTok{   i }\OperatorTok{=} \FloatTok{0}
   \ControlFlowTok{while}\NormalTok{ i }\OperatorTok{\textless{}} \FloatTok{1000}
     \ControlFlowTok{if} \FunctionTok{sorteioBom}\NormalTok{() }\OperatorTok{==} \FloatTok{0}
\NormalTok{        cara }\OperatorTok{=}\NormalTok{ cara }\OperatorTok{+} \FloatTok{1}
     \ControlFlowTok{else}
\NormalTok{        coroa }\OperatorTok{=}\NormalTok{ coroa }\OperatorTok{+} \FloatTok{1}
     \ControlFlowTok{end}
\NormalTok{     i }\OperatorTok{=}\NormalTok{ i }\OperatorTok{+} \FloatTok{1}
   \ControlFlowTok{end}
   \FunctionTok{println}\NormalTok{(}\StringTok{"O n√∫mero de caras foi: "}\NormalTok{, cara,}\StringTok{" e de coroas foi :"}\NormalTok{, coroa)}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
verificaSorteio (generic function with 1 method)
\end{verbatim}

Podemos ainda aproximar o n√∫mero de Euler (ùëí), constante matem√°tica que
√© a base dos logaritmos naturais, usando uma simula√ß√£o probabil√≠stica. A
ideia por tr√°s desse c√≥digo √© que o n√∫mero m√©dio de tentativas
necess√°rias para que a soma de n√∫meros aleat√≥rios entre 0 e 1 ultrapasse
1 se aproxima do valor de ùëí. Isso √© baseado em uma rela√ß√£o matem√°tica
que conecta essa situa√ß√£o ao n√∫mero ùëí.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{calculaEuler}\NormalTok{(total)}
\NormalTok{    soma\_tentativas }\OperatorTok{=} \FloatTok{0}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \FloatTok{1}\OperatorTok{:}\NormalTok{total}
\NormalTok{        soma }\OperatorTok{=} \FloatTok{0.0}
\NormalTok{        tentativas }\OperatorTok{=} \FloatTok{0}      
        \ControlFlowTok{while}\NormalTok{ soma }\OperatorTok{\textless{}=} \FloatTok{1}   \CommentTok{\# Continue gerando n√∫meros at√© a soma ultrapassar 1}
\NormalTok{            soma }\OperatorTok{+=} \FunctionTok{rand}\NormalTok{()     }\CommentTok{\# Gera n√∫mero aleat√≥rio entre 0 e 1}
\NormalTok{            tentativas }\OperatorTok{+=} \FloatTok{1}
        \ControlFlowTok{end}        
\NormalTok{        soma\_tentativas }\OperatorTok{+=}\NormalTok{ tentativas     }\CommentTok{\# Somar o n√∫mero de tentativas necess√°rias}
    \ControlFlowTok{end} 
    \ControlFlowTok{return}\NormalTok{ soma\_tentativas }\OperatorTok{/}\NormalTok{ total     }\CommentTok{\# A m√©dia do n√∫mero de tentativas ser√° uma estimativa de e}
\KeywordTok{end}

\FunctionTok{println}\NormalTok{(}\StringTok{"Estimativa de e (1000 itera√ß√µes): "}\NormalTok{, }\FunctionTok{calculaEuler}\NormalTok{(}\FloatTok{1000}\NormalTok{))}
\FunctionTok{println}\NormalTok{(}\StringTok{"Estimativa de e (100000 itera√ß√µes): "}\NormalTok{, }\FunctionTok{calculaEuler}\NormalTok{(}\FloatTok{100000}\NormalTok{))}
\FunctionTok{println}\NormalTok{(}\StringTok{"Estimativa de e (100000000 itera√ß√µes): "}\NormalTok{, }\FunctionTok{calculaEuler}\NormalTok{(}\FloatTok{100000000}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Estimativa de e (1000 itera√ß√µes): 2.713
Estimativa de e (100000 itera√ß√µes): 2.71589
Estimativa de e (100000000 itera√ß√µes): 2.71811446
\end{verbatim}

Para terminar a aula vamos aplicar o m√©todo de Monte Carlo para o
c√°lculo de Pi. Imaginem o primeiro quadrante, onde temos um semi-c√≠rculo
de raio 1, dentro de um quadrado de lado 1. Podemos sortear valores, os
que sairem dentro do c√≠rculo podem contar para a √°rea desse. Mais
informa√ß√µes podem ser vistas aqui
(https://pt.wikipedia.org/wiki/M\%C3\%A9todo\_de\_Monte\_Carlo)

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{calculaPi}\NormalTok{(total)}
\NormalTok{   noAlvo }\OperatorTok{=} \FloatTok{0}
\NormalTok{   i }\OperatorTok{=} \FloatTok{0}
   \ControlFlowTok{while}\NormalTok{ i }\OperatorTok{\textless{}}\NormalTok{ total}
\NormalTok{     x }\OperatorTok{=} \FunctionTok{rand}\NormalTok{() }\OperatorTok{/} \FloatTok{2.0} \CommentTok{\# gera um n√∫mero entre 0 e 0.5}
\NormalTok{     y }\OperatorTok{=} \FunctionTok{rand}\NormalTok{() }\OperatorTok{/} \FloatTok{2.0}
     \ControlFlowTok{if} \FunctionTok{sqrt}\NormalTok{(x }\OperatorTok{*}\NormalTok{ x }\OperatorTok{+}\NormalTok{ y }\OperatorTok{*}\NormalTok{ y) }\OperatorTok{\textless{}=} \FloatTok{0.5}
\NormalTok{       noAlvo }\OperatorTok{=}\NormalTok{ noAlvo }\OperatorTok{+} \FloatTok{1}
     \ControlFlowTok{end}
\NormalTok{     i }\OperatorTok{=}\NormalTok{ i }\OperatorTok{+} \FloatTok{1}
   \ControlFlowTok{end}
   \ControlFlowTok{return} \FloatTok{4} \OperatorTok{*}\NormalTok{ (noAlvo }\OperatorTok{/}\NormalTok{ total)  }\CommentTok{\# precisamos multiplicar para ter a √°rea de 4 quadrantes}
\KeywordTok{end} 

\FunctionTok{println}\NormalTok{(}\FunctionTok{calculaPi}\NormalTok{(}\FloatTok{100}\NormalTok{))}
\FunctionTok{println}\NormalTok{(}\FunctionTok{calculaPi}\NormalTok{(}\FloatTok{1000000}\NormalTok{))}
\FunctionTok{println}\NormalTok{(}\FunctionTok{calculaPi}\NormalTok{(}\FloatTok{1000000000}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
3.04
3.139624
3.141516436
\end{verbatim}

\bookmarksetup{startatroot}

\chapter{Entrada de dados e o come√ßo de
listas}\label{entrada-de-dados-e-o-comeuxe7o-de-listas}

Nessa aula, temos dois t√≥picos principais, como fazer a entrada de
dados, atrav√©s de comandos de entrada e com argumentos na linha de
comando. Al√©m disso tamb√©m veremos como tratar de um tipo especial de
vari√°vel, onde √© poss√≠vel, guardar mais de um valor.

\section{O comando input}\label{o-comando-input}

Quando queremos inserir dados, em Julia, basta colocar dados. Mas, como
podemos fazer para entrar dados em um programa comum?

Para isso temos o comando readline(), que interrompe a execu√ß√£o do
programa e espera pela entrada de uma String, o que ocorre quando a
tecla ``enter'' √© pressionada.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{println}\NormalTok{(}\StringTok{"Digite o seu nome"}\NormalTok{)}
\NormalTok{resposta }\OperatorTok{=} \FunctionTok{readline}\NormalTok{()}
\FunctionTok{println}\NormalTok{(}\StringTok{"O seu nome √©: "}\NormalTok{, resposta)}
\end{Highlighting}
\end{Shaded}

Caso, ao rodar o programa, voc√™ digitar \texttt{Maria}, e pressionar a
tecla enter, a resposta final do seu programa ser√°
\texttt{O\ seu\ nome\ √©:\ Maria}.

Como o readline() l√™ Strings, se quisermos ler n√∫meros, √© necess√°rio
usar o comando parse. O comando parse de forma simples possui dois
par√¢metros, o primeiro corresponde ao tipo que se quer transformar, e o
segundo o valor original.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{println}\NormalTok{(}\StringTok{"Digite um inteiro"}\NormalTok{)}
\NormalTok{valor }\OperatorTok{=} \FunctionTok{parse}\NormalTok{(}\DataTypeTok{Int64}\NormalTok{, }\FunctionTok{readline}\NormalTok{())}
\FunctionTok{println}\NormalTok{(}\StringTok{"O numero digitado foi "}\NormalTok{, valor)}
\end{Highlighting}
\end{Shaded}

Sabendo ler n√∫meros do teclado, vamos a um exerc√≠cio simples, ler uma
sequ√™ncia de n√∫meros inteiros terminada por zero e devolver a sua soma.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{somaVarios}\NormalTok{()}
\NormalTok{    soma }\OperatorTok{=} \FloatTok{0.0}
    \FunctionTok{println}\NormalTok{(}\StringTok{"Digite um n√∫mero"}\NormalTok{)}
\NormalTok{    n }\OperatorTok{=} \FunctionTok{parse}\NormalTok{(}\DataTypeTok{Float64}\NormalTok{, }\FunctionTok{readline}\NormalTok{())}
    \ControlFlowTok{while}\NormalTok{  n}\OperatorTok{!=}\FloatTok{0}
\NormalTok{        soma }\OperatorTok{=}\NormalTok{ soma }\OperatorTok{+}\NormalTok{ n}
        \FunctionTok{println}\NormalTok{(}\StringTok{"Digite um n√∫mero"}\NormalTok{)}
\NormalTok{        n }\OperatorTok{=} \FunctionTok{parse}\NormalTok{(}\DataTypeTok{Float64}\NormalTok{, }\FunctionTok{readline}\NormalTok{())}
    \ControlFlowTok{end}
    \FunctionTok{println}\NormalTok{(}\StringTok{"A soma √©: "}\NormalTok{, soma)}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Observe o seguinte exemplo que calcula os quadrados dos n√∫meros de uma
lista terminada por zero.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{leQ}\NormalTok{()}
\NormalTok{  x }\OperatorTok{=} \FunctionTok{readline}\NormalTok{()}
\NormalTok{  n }\OperatorTok{=} \FunctionTok{parse}\NormalTok{(}\DataTypeTok{Float64}\NormalTok{, x)}
  \ControlFlowTok{while}\NormalTok{ n }\OperatorTok{!=} \FloatTok{0}
    \FunctionTok{println}\NormalTok{(}\StringTok{"}\SpecialCharTok{$}\NormalTok{n}\StringTok{ ao quadrado √© "}\NormalTok{, n }\OperatorTok{*}\NormalTok{ n)}
\NormalTok{    x }\OperatorTok{=} \FunctionTok{readline}\NormalTok{()}
\NormalTok{    n }\OperatorTok{=} \FunctionTok{parse}\NormalTok{(}\DataTypeTok{Float64}\NormalTok{, x)}
  \ControlFlowTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Notem que o readline tamb√©m pode receber uma vari√°vel de arquivo para
que dados sejam lidos diretamente. Mas, nesse caso temos que tomar
Ocuidado para abrir (open()) e fechar (close()) o arquivo. Como abaixo:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{leQ}\NormalTok{()}
    \FunctionTok{println}\NormalTok{(}\StringTok{"Digite um n√∫mero"}\NormalTok{)}
\NormalTok{    f }\OperatorTok{=} \FunctionTok{open}\NormalTok{(}\StringTok{"numeros.txt"}\NormalTok{, }\StringTok{"r+"}\NormalTok{)}
\NormalTok{    x }\OperatorTok{=} \FunctionTok{readline}\NormalTok{(f)}
\NormalTok{    n }\OperatorTok{=} \FunctionTok{parse}\NormalTok{(}\DataTypeTok{Float64}\NormalTok{, x)}
    \ControlFlowTok{while}\NormalTok{ n }\OperatorTok{!=} \FloatTok{0}
        \FunctionTok{println}\NormalTok{(}\StringTok{"}\SpecialCharTok{$}\NormalTok{n}\StringTok{ ao quadrado √© "}\NormalTok{, n }\OperatorTok{*}\NormalTok{ n)}
        \FunctionTok{println}\NormalTok{(}\StringTok{"Digite outro n√∫mero"}\NormalTok{)}
\NormalTok{        x }\OperatorTok{=} \FunctionTok{readline}\NormalTok{(f)}
\NormalTok{        n }\OperatorTok{=} \FunctionTok{parse}\NormalTok{(}\DataTypeTok{Float64}\NormalTok{, x)}
    \ControlFlowTok{end}
    \FunctionTok{close}\NormalTok{(f)}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\section{Lendo atrav√©s da linha de
comando}\label{lendo-atravuxe9s-da-linha-de-comando}

A outra forma de ler comandos √© atrav√©s da constante ARGS que √©
preparada na chamada de um programa. Para entender melhor isso, vamos
ver o seguinte programa.

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{println}\NormalTok{(}\ConstantTok{ARGS}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Se a linha acima est√° no arquivo args.jl, ao chamar julia args.jl com
diversos par√¢metros, teremos diversos resultados diferentes.

Por exemplo ao chamar:

julia args.jl 1 2 3 abc

Teremos como resposta

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{[}\StringTok{"1"}\NormalTok{, }\StringTok{"2"}\NormalTok{, }\StringTok{"3"}\NormalTok{, }\StringTok{"abc"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

Vamos analisar um pouco melhor essa resposta observando que cada
par√¢metro est√° em uma posi√ß√£o.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tam }\OperatorTok{=} \FunctionTok{length}\NormalTok{(}\ConstantTok{ARGS}\NormalTok{)}
\FunctionTok{println}\NormalTok{(}\StringTok{"O tamanho dos argumentos √©: "}\NormalTok{, tam)}
\ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \FloatTok{1}\OperatorTok{:}\NormalTok{tam}
    \FunctionTok{println}\NormalTok{(}\ConstantTok{ARGS}\NormalTok{[i])}
\ControlFlowTok{end}
\end{Highlighting}
\end{Shaded}

Olhando o c√≥digo acima, podemos ver que a fun√ß√£o length() devolve o
n√∫mero de argumentos, ou seja, o tamanho da lista ARGS. Al√©m disso com
os colchetes √© poss√≠vel acessar a cada posi√ß√£o da lista de forma
individual.

O exemplo abaixo soma os par√¢metros inteiros dados como argumentos. Ele
tamb√©m ilustra uma boa pr√°tica que √©, sempre colocar o c√≥digo em
m√≥dulos, no caso abaixo em fun√ß√µes:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{SomaEntrada}\NormalTok{()}
\NormalTok{    tam }\OperatorTok{=} \FunctionTok{length}\NormalTok{(}\ConstantTok{ARGS}\NormalTok{)}
\NormalTok{    s }\OperatorTok{=} \FloatTok{0}
\NormalTok{    i }\OperatorTok{=} \FloatTok{1}
    \ControlFlowTok{while}\NormalTok{ i }\OperatorTok{\textless{}=}\NormalTok{ tam}
\NormalTok{        valor }\OperatorTok{=} \FunctionTok{parse}\NormalTok{(}\DataTypeTok{Int}\NormalTok{, }\ConstantTok{ARGS}\NormalTok{[i])}
        \FunctionTok{println}\NormalTok{(valor)}
\NormalTok{        s }\OperatorTok{=}\NormalTok{ s }\OperatorTok{+}\NormalTok{ valor}
\NormalTok{        i }\OperatorTok{=}\NormalTok{ i }\OperatorTok{+} \FloatTok{1}
    \ControlFlowTok{end}
    \FunctionTok{println}\NormalTok{(}\StringTok{"A soma foi: "}\NormalTok{, s)}
\KeywordTok{end}
\FunctionTok{SomaEntrada}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

A flexibilidade que temos ao usar listas √© enorme! Por isso, listas ou
vetores, merecem um t√≥pico pr√≥prio.

\section{Listas}\label{listas}

Vamos primeiro brincar um pouco no console.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vetor }\OperatorTok{=}\NormalTok{ [}\FloatTok{1}\NormalTok{, }\FloatTok{2}\NormalTok{, }\FloatTok{3}\NormalTok{]}
\FunctionTok{println}\NormalTok{(vetor[}\FloatTok{1}\NormalTok{])}
\FunctionTok{println}\NormalTok{(}\FunctionTok{length}\NormalTok{(vetor))}
\NormalTok{vetor[}\FloatTok{2}\NormalTok{] }\OperatorTok{=}\NormalTok{ vetor[}\FloatTok{2}\NormalTok{] }\OperatorTok{+} \FloatTok{1}
\NormalTok{vetor[}\FloatTok{1}\NormalTok{] }\OperatorTok{=} \FloatTok{2} \OperatorTok{*}\NormalTok{ vetor[}\FloatTok{3}\NormalTok{]}
\FunctionTok{println}\NormalTok{(vetor)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
1
3
[6, 3, 3]
\end{verbatim}

Como disse antes, o for foi feito para manipular vetores, vamos ver umas
fun√ß√µes, a primeira que imprime os elementos de um vetor um por linha.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{imprimeVetor}\NormalTok{(v)}
    \ControlFlowTok{for}\NormalTok{ el }\KeywordTok{in}\NormalTok{ v}
        \FunctionTok{println}\NormalTok{(el)}
    \ControlFlowTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Isso tamb√©m pode ser feito por meio dos √≠ndices do vetor:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{imprimeVetor}\NormalTok{(v)}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \FloatTok{1}\OperatorTok{:}\FunctionTok{lenght}\NormalTok{(v)}
        \FunctionTok{println}\NormalTok{(v[i])}
    \ControlFlowTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Como cada posi√ß√£o √© independente, podemos calcular a soma dos elementos
√≠mpares de um vetor

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{somaImpVetor}\NormalTok{(v)}
\NormalTok{    soma }\OperatorTok{=} \FloatTok{0}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \FloatTok{1}\OperatorTok{:}\FunctionTok{length}\NormalTok{(v)}
        \ControlFlowTok{if}\NormalTok{ v[i] }\OperatorTok{\%} \FloatTok{2} \OperatorTok{==} \FloatTok{1}
\NormalTok{            soma }\OperatorTok{=}\NormalTok{ soma }\OperatorTok{+}\NormalTok{ v[i]}
        \ControlFlowTok{end}
    \ControlFlowTok{end}
    \ControlFlowTok{return}\NormalTok{ soma}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Tamb√©m vimos em aula alguns outros exemplos, como calcular a m√©dia dos
elementos em um vetor.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{mediaV}\NormalTok{(v)}
\NormalTok{   soma }\OperatorTok{=} \FloatTok{0.0}
   \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in}\NormalTok{ v}
\NormalTok{      soma }\OperatorTok{=}\NormalTok{ soma }\OperatorTok{+}\NormalTok{ i}
   \ControlFlowTok{end}
   \ControlFlowTok{return}\NormalTok{ soma }\OperatorTok{/} \FunctionTok{length}\NormalTok{(v)}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Devolver a soma dos elementos √≠mpares de um vetor

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{somaImpar}\NormalTok{(v)}
\NormalTok{    soma }\OperatorTok{=} \FloatTok{0}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in}\NormalTok{ v}
        \ControlFlowTok{if}\NormalTok{ i }\OperatorTok{\%} \FloatTok{2} \OperatorTok{==} \FloatTok{1}
\NormalTok{            soma }\OperatorTok{=}\NormalTok{ soma }\OperatorTok{+}\NormalTok{ i}
        \ControlFlowTok{end}
    \ControlFlowTok{end}
    \ControlFlowTok{return}\NormalTok{ soma}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Imprimir os n√∫meros divis√≠veis por 5 de um vetor.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{imprimeDivisivelPor5}\NormalTok{(v)}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in}\NormalTok{ v}
        \ControlFlowTok{if}\NormalTok{ i }\OperatorTok{\%} \FloatTok{5} \OperatorTok{==} \FloatTok{0}
            \FunctionTok{println}\NormalTok{(i)}
        \ControlFlowTok{end}
    \ControlFlowTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Com uma pequena varia√ß√£o e usando o comando push!() podemos ver como
devolver um vetor com os n√∫meros divis√≠veis por 5.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{devolveDivisivelPor5}\NormalTok{(v)}
\NormalTok{    x }\OperatorTok{=}\NormalTok{ []  }\CommentTok{\# come√ßa com um vetor vazio}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in}\NormalTok{ v}
        \ControlFlowTok{if}\NormalTok{ i }\OperatorTok{\%} \FloatTok{5} \OperatorTok{==} \FloatTok{0}
            \FunctionTok{push!}\NormalTok{(x, i)  }\CommentTok{\# adiciona um elemento ao vetor x}
        \ControlFlowTok{end}
    \ControlFlowTok{end}
    \ControlFlowTok{return}\NormalTok{ x}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\subsection{√Ålgebra linear e Listas}\label{uxe1lgebra-linear-e-listas}

A manipula√ß√£o de listas √© uma parte fundamental da √°lgebra linear, que
estuda vetores e matrizes. Fun√ß√µes como o produto escalar de dois
vetores s√£o exemplos cl√°ssicos. Abaixo temos dois exemplos de produto
escalar de dois vetores. lembrado esse √© definido como a soma dos
produtos de elementos em posi√ß√µes iguais.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{dotProduct}\NormalTok{(a, b)}
\NormalTok{    soma }\OperatorTok{=} \FloatTok{0}
    \ControlFlowTok{if} \FunctionTok{length}\NormalTok{(a) }\OperatorTok{!=} \FunctionTok{length}\NormalTok{(b)}
       \ControlFlowTok{return}\NormalTok{ soma   }\CommentTok{\# o produto n√£o est√° definido se os tamanhos s√£o diferentes}
    \ControlFlowTok{end}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \FloatTok{1}\OperatorTok{:}\FunctionTok{length}\NormalTok{(a)}
\NormalTok{        soma }\OperatorTok{=}\NormalTok{ soma }\OperatorTok{+}\NormalTok{ a[i] }\OperatorTok{*}\NormalTok{ b[i]}
    \ControlFlowTok{end}
    \ControlFlowTok{return}\NormalTok{ soma}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Acima vimos que um caso especial do uso do for, consiste em fazer Ofor
varias entre 1 e um tamanho (1:lenght(a))

Observem a diferen√ßa na vers√£o abaixo:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{dotProduct}\NormalTok{(a, b)}
\NormalTok{    soma }\OperatorTok{=} \FloatTok{0}
    \ControlFlowTok{if} \FunctionTok{length}\NormalTok{(a) }\OperatorTok{!=} \FunctionTok{length}\NormalTok{(b)}
       \ControlFlowTok{return}\NormalTok{ soma   }\CommentTok{\# o produto n√£o est√° definido se os tamanhos s√£o diferentes}
    \ControlFlowTok{end}   
\NormalTok{    i }\OperatorTok{=} \FloatTok{1}
    \ControlFlowTok{for}\NormalTok{ x }\KeywordTok{in}\NormalTok{ a}
\NormalTok{        soma }\OperatorTok{=}\NormalTok{ soma }\OperatorTok{+}\NormalTok{ x }\OperatorTok{*}\NormalTok{ b[i]}
\NormalTok{        i }\OperatorTok{=}\NormalTok{ i }\OperatorTok{+} \FloatTok{1}
    \ControlFlowTok{end} 
    \ControlFlowTok{return}\NormalTok{ soma}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\subsection{Exerc√≠cio de
permuta√ß√£o}\label{exercuxedcio-de-permutauxe7uxe3o}

Para terminar, vamos fazer uma fun√ß√£o onde dado um vetor de inteiros de
tamanho \(n\), verifica se esse vetor √© uma permuta√ß√£o dos n√∫meros de 1
a \(n\). Para isso, veremos se cada n√∫mero de 1 a \(n\) est√° no vetor.

Mas, sem esquecer dos testes:

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{@testset} \StringTok{"Verifica Permuta√ß√£o"} \ControlFlowTok{begin}
    \PreprocessorTok{@test} \FunctionTok{permuta}\NormalTok{([}\FloatTok{1}\NormalTok{,}\FloatTok{2}\NormalTok{,}\FloatTok{3}\NormalTok{])}
    \PreprocessorTok{@test} \FunctionTok{permuta}\NormalTok{([}\FloatTok{3}\NormalTok{, }\FloatTok{2}\NormalTok{, }\FloatTok{1}\NormalTok{])}
    \PreprocessorTok{@test} \FunctionTok{permuta}\NormalTok{([}\FloatTok{1}\NormalTok{])}
    \PreprocessorTok{@test} \FunctionTok{permuta}\NormalTok{([}\FloatTok{2}\NormalTok{, }\FloatTok{1}\NormalTok{])}
    \PreprocessorTok{@test} \FunctionTok{permuta}\NormalTok{([}\FloatTok{4}\NormalTok{, }\FloatTok{2}\NormalTok{, }\FloatTok{3}\NormalTok{, }\FloatTok{1}\NormalTok{])}
    \PreprocessorTok{@test}\NormalTok{ !}\FunctionTok{permuta}\NormalTok{([}\FloatTok{1}\NormalTok{, }\FloatTok{1}\NormalTok{])}
    \PreprocessorTok{@test}\NormalTok{ !}\FunctionTok{permuta}\NormalTok{([}\FloatTok{1}\NormalTok{, }\FloatTok{3}\NormalTok{])}
    \PreprocessorTok{@test} \FunctionTok{permuta}\NormalTok{([])}
\ControlFlowTok{end}
\end{Highlighting}
\end{Shaded}

e o c√≥digo:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{permuta}\NormalTok{(v)}
\NormalTok{   tam }\OperatorTok{=} \FunctionTok{length}\NormalTok{(v)}
   \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \FloatTok{1}\OperatorTok{:}\NormalTok{tam}
      \ControlFlowTok{if}\NormalTok{  !(i }\KeywordTok{in}\NormalTok{ v)}
         \ControlFlowTok{return} \ConstantTok{false}
      \ControlFlowTok{end}
   \ControlFlowTok{end}
   \ControlFlowTok{return} \ConstantTok{true}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

Foi usado o comando in de Julia que verifica se um elemento est√° no
vetor.

\bookmarksetup{startatroot}

\chapter{Exerc√≠cios com vetores}\label{exercuxedcios-com-vetores}

Os vetores permitem que sejam realizados algoritmos bem mais complexos,
nesse cap√≠tulo veremos algums exerc√≠cios.

\section{Permuta√ß√£o}\label{permutauxe7uxe3o}

Dado um vetor com inteiros, queremos verificar se esse vetor cont√©m uma
permuta√ß√£o. Para isso, temos que verificar em um vetor de tamanho n, se
ele cont√©m os n√∫meros de 1 a n exatamente uma vez cada 1. O vetor {[}3,
1, 2{]} √© uma permuta√ß√£o, pois tem tamanho 3 e os elementos de 1 a 3
aparecem uma vez.

Uma forma de se resolver esse problema √© por meio de um indicador de
passagem. Inicialmente vamos supor que o vetor √© uma permuta√ß√£o, em
seguida verificamos se todos os n√∫meros entre 1 e n est√£o no vetor. Isso
pode ser feito com comando in, que verifica se um elemento pertence ao
vetor.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{permuta√ß√£o}\NormalTok{(l)}
\NormalTok{    perm }\OperatorTok{=} \ConstantTok{true}
\NormalTok{    tamanho }\OperatorTok{=} \FunctionTok{length}\NormalTok{(l)}
\NormalTok{    i }\OperatorTok{=} \FloatTok{1}
    \ControlFlowTok{while}\NormalTok{ i }\OperatorTok{\textless{}=}\NormalTok{ tamanho}
        \ControlFlowTok{if}\NormalTok{ !(i }\KeywordTok{in}\NormalTok{ l)}
\NormalTok{            perm }\OperatorTok{=} \ConstantTok{false}
        \ControlFlowTok{end}    
\NormalTok{        i }\OperatorTok{+=} \FloatTok{1}
    \ControlFlowTok{end}
    \ControlFlowTok{return}\NormalTok{ perm}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
permuta√ß√£o (generic function with 1 method)
\end{verbatim}

Uma outra alternativa √© verificar se para cada elemento do vetor, se ele
est√° entre 1 e n, e √© unico. Ou seja, verificamos se o primeiro elemento
est√° entre 1 e n, e depois percorremos o vetor para ver se ele √© √∫nico.
Em seguida fazemos isso para os elementos seguintes. O c√≥digo fica:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{permuta√ß√£o}\NormalTok{(l)}
\NormalTok{    perm }\OperatorTok{=} \ConstantTok{true}
\NormalTok{    tamanho }\OperatorTok{=} \FunctionTok{length}\NormalTok{(l)}
\NormalTok{    i }\OperatorTok{=} \FloatTok{1}
    \ControlFlowTok{while}\NormalTok{ i }\OperatorTok{\textless{}=}\NormalTok{ tamanho}
        \ControlFlowTok{if}\NormalTok{ (l[i] }\OperatorTok{\textgreater{}}\NormalTok{ tamanho }\OperatorTok{||}\NormalTok{ l[i] }\OperatorTok{\textless{}=} \FloatTok{0}\NormalTok{)}
\NormalTok{            perm }\OperatorTok{=} \ConstantTok{false}
        \ControlFlowTok{end}
\NormalTok{        j }\OperatorTok{=}\NormalTok{ i }\OperatorTok{+}\FloatTok{1}
        \ControlFlowTok{while}\NormalTok{ j }\OperatorTok{\textless{}=}\NormalTok{ tamanho}
            \ControlFlowTok{if}\NormalTok{ l[j] }\OperatorTok{==}\NormalTok{ l[i]}
\NormalTok{                perm }\OperatorTok{=} \ConstantTok{false}
            \ControlFlowTok{end}
\NormalTok{            j }\OperatorTok{+=} \FloatTok{1}
        \ControlFlowTok{end}
\NormalTok{        i }\OperatorTok{+=} \FloatTok{1}
    \ControlFlowTok{end}
    \ControlFlowTok{return}\NormalTok{ perm}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
permuta√ß√£o (generic function with 1 method)
\end{verbatim}

Uma outra alternativa √© ter um vetor auxiliar onde contamos as
ocorr√™ncias de cada n√∫mero entre 1 e n. Ao final, todos os elementos
desse vetor auxiliar tem que valer 1. Dessa vez, aproveitamos e j√°
colocamos os testes automatizados.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{using} \BuiltInTok{Test}
\KeywordTok{function} \FunctionTok{permuta√ß√£o}\NormalTok{(l)}
\NormalTok{    perm }\OperatorTok{=} \ConstantTok{true}
\NormalTok{    tamanho }\OperatorTok{=} \FunctionTok{length}\NormalTok{(l)}
\NormalTok{    aux }\OperatorTok{=} \FunctionTok{zeros}\NormalTok{(}\DataTypeTok{Int8}\NormalTok{, tamanho)}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in}\NormalTok{ l}
      \ControlFlowTok{if}\NormalTok{ i }\OperatorTok{\textless{}} \FloatTok{1} \OperatorTok{||}\NormalTok{ i }\OperatorTok{\textgreater{}}\NormalTok{ tamanho}
\NormalTok{        perm }\OperatorTok{=} \ConstantTok{false}
      \ControlFlowTok{else}
\NormalTok{        aux[i] }\OperatorTok{+=} \FloatTok{1}
      \ControlFlowTok{end}
    \ControlFlowTok{end}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in}\NormalTok{ aux}
      \ControlFlowTok{if}\NormalTok{ i }\OperatorTok{!=} \FloatTok{1}
\NormalTok{        perm }\OperatorTok{=} \ConstantTok{false}
      \ControlFlowTok{end}
    \ControlFlowTok{end}  
    \ControlFlowTok{return}\NormalTok{ perm}
\KeywordTok{end}

\PreprocessorTok{@testset} \StringTok{"Verifica Permuta√ß√£o"} \ControlFlowTok{begin}
    \PreprocessorTok{@test} \FunctionTok{permuta√ß√£o}\NormalTok{([}\FloatTok{1}\NormalTok{,}\FloatTok{2}\NormalTok{,}\FloatTok{3}\NormalTok{])}
    \PreprocessorTok{@test} \FunctionTok{permuta√ß√£o}\NormalTok{([}\FloatTok{3}\NormalTok{, }\FloatTok{2}\NormalTok{, }\FloatTok{1}\NormalTok{])}
    \PreprocessorTok{@test} \FunctionTok{permuta√ß√£o}\NormalTok{([}\FloatTok{1}\NormalTok{])}
    \PreprocessorTok{@test} \FunctionTok{permuta√ß√£o}\NormalTok{([}\FloatTok{2}\NormalTok{, }\FloatTok{1}\NormalTok{])}
    \PreprocessorTok{@test} \FunctionTok{permuta√ß√£o}\NormalTok{([}\FloatTok{4}\NormalTok{, }\FloatTok{2}\NormalTok{, }\FloatTok{3}\NormalTok{, }\FloatTok{1}\NormalTok{])}
    \PreprocessorTok{@test}\NormalTok{ !}\FunctionTok{permuta√ß√£o}\NormalTok{([}\FloatTok{1}\NormalTok{, }\FloatTok{1}\NormalTok{])}
    \PreprocessorTok{@test}\NormalTok{ !}\FunctionTok{permuta√ß√£o}\NormalTok{([}\FloatTok{1}\NormalTok{, }\FloatTok{3}\NormalTok{])}
    \PreprocessorTok{@test}\NormalTok{ !}\FunctionTok{permuta√ß√£o}\NormalTok{([}\FloatTok{4}\NormalTok{, }\FloatTok{2}\NormalTok{, }\FloatTok{3}\NormalTok{, }\OperatorTok{{-}}\FloatTok{1}\NormalTok{])}
    \PreprocessorTok{@test}\NormalTok{ !}\FunctionTok{permuta√ß√£o}\NormalTok{([}\FloatTok{5}\NormalTok{, }\FloatTok{2}\NormalTok{, }\FloatTok{3}\NormalTok{, }\FloatTok{1}\NormalTok{])}
    \PreprocessorTok{@test} \FunctionTok{permuta√ß√£o}\NormalTok{([])}
    \PreprocessorTok{@test}\NormalTok{ !}\FunctionTok{permuta√ß√£o}\NormalTok{([}\FloatTok{0}\NormalTok{, }\FloatTok{3}\NormalTok{, }\FloatTok{3}\NormalTok{])}
    \PreprocessorTok{@test}\NormalTok{ !}\FunctionTok{permuta√ß√£o}\NormalTok{([}\FloatTok{2}\NormalTok{, }\FloatTok{2}\NormalTok{, }\FloatTok{2}\NormalTok{])}
\ControlFlowTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Test Summary:       | Pass  Total  Time
Verifica Permuta√ß√£o |   12     12  0.1s
\end{verbatim}

\begin{verbatim}
Test.DefaultTestSet("Verifica Permuta√ß√£o", Any[], 12, false, false, true, 1.729792205835976e9, 1.729792205941158e9, false, "/workspaces/livro-alfredo/aulas/112.qmd")
\end{verbatim}

\section{Histograma}\label{histograma}

J√° que vimos o exemplo anterior onde ``contamos'' o n√∫mero, podemos ir
um pouco al√©m e calcular o histograma de um vetor com n√∫meros entre 1 e
10.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{using} \BuiltInTok{Test}

\KeywordTok{function} \FunctionTok{histograma}\NormalTok{(l)}
\NormalTok{    result }\OperatorTok{=}\NormalTok{ [}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{]}
\NormalTok{    i }\OperatorTok{=} \FloatTok{1}
    \ControlFlowTok{while}\NormalTok{ i }\OperatorTok{\textless{}=} \FunctionTok{length}\NormalTok{(l)}
\NormalTok{        valor\_atual }\OperatorTok{=}\NormalTok{ l[i]}
        \ControlFlowTok{if}\NormalTok{ valor\_atual }\OperatorTok{\textgreater{}=} \FloatTok{1} \OperatorTok{\&\&}\NormalTok{ valor\_atual }\OperatorTok{\textless{}=} \FloatTok{10}
\NormalTok{           result[valor\_atual] }\OperatorTok{+=} \FloatTok{1}
        \ControlFlowTok{end}
\NormalTok{        i }\OperatorTok{+=} \FloatTok{1}
    \ControlFlowTok{end}
    \ControlFlowTok{return}\NormalTok{ result}
\KeywordTok{end}

\PreprocessorTok{@testset} \StringTok{"Verifica Histograma"} \ControlFlowTok{begin}
    \PreprocessorTok{@test}\NormalTok{ [}\FloatTok{1}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{] }\OperatorTok{==} \FunctionTok{histograma}\NormalTok{([}\FloatTok{1}\NormalTok{])}
    \PreprocessorTok{@test}\NormalTok{ [}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{] }\OperatorTok{==} \FunctionTok{histograma}\NormalTok{([}\OperatorTok{{-}}\FloatTok{1}\NormalTok{])}
    \PreprocessorTok{@test}\NormalTok{ [}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{1}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{] }\OperatorTok{==} \FunctionTok{histograma}\NormalTok{([}\FloatTok{3}\NormalTok{])}
    \PreprocessorTok{@test}\NormalTok{ [}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{1}\NormalTok{] }\OperatorTok{==} \FunctionTok{histograma}\NormalTok{([}\FloatTok{10}\NormalTok{])}
    \PreprocessorTok{@test}\NormalTok{ [}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{] }\OperatorTok{==} \FunctionTok{histograma}\NormalTok{([}\FloatTok{11}\NormalTok{])}
    \PreprocessorTok{@test}\NormalTok{ [}\FloatTok{1}\NormalTok{,}\FloatTok{4}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{2}\NormalTok{,}\FloatTok{5}\NormalTok{,}\FloatTok{1}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{1}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{] }\OperatorTok{==} \FunctionTok{histograma}\NormalTok{([}\FloatTok{5}\NormalTok{,}\FloatTok{6}\NormalTok{,}\FloatTok{5}\NormalTok{,}\FloatTok{4}\NormalTok{,}\FloatTok{5}\NormalTok{,}\FloatTok{5}\NormalTok{,}\FloatTok{4}\NormalTok{,}\FloatTok{2}\NormalTok{,}\FloatTok{8}\NormalTok{,}\FloatTok{2}\NormalTok{,}\FloatTok{1}\NormalTok{,}\FloatTok{2}\NormalTok{,}\FloatTok{5}\NormalTok{,}\FloatTok{2}\NormalTok{])}
    \PreprocessorTok{@test}\NormalTok{ [}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{,}\FloatTok{0}\NormalTok{] }\OperatorTok{==} \FunctionTok{histograma}\NormalTok{([])}
    \ControlFlowTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Test Summary:       | Pass  Total  Time
Verifica Histograma |    7      7  0.1s
\end{verbatim}

\begin{verbatim}
Test.DefaultTestSet("Verifica Histograma", Any[], 7, false, false, true, 1.729792206375156e9, 1.729792206428047e9, false, "/workspaces/livro-alfredo/aulas/112.qmd")
\end{verbatim}

\section{Modelando problemas com o
computador}\label{modelando-problemas-com-o-computador}

O computador pode ser uma ferramenta bem poderosa para a modelagem de
problemas reais. Para isso vamos pegar o caso do problema dos
anivers√°rios. Esse problema tamb√©m √© conhecido pelo paradoxo do
anivers√°rio: Calcular a probabilidade de que em uma sala com n pessoas,
pelo menos duas possuam a mesma data de anivers√°rio. Esse problema pode
ser resolvido usando probabilidade, por meio da qual se descobre que se
a sala tem 23 pessoas a chance de duas terem a mesma data √© de pouco
mais de 50\%.

Mas, tamb√©m podemos modelar esse problema computacionalmente. Para isso,
o primeiro passo √© simplificar as datas, ao inv√©s de m√™s e ano, podemos
codificar os dias em um n√∫mero entre 1 e 365, sendo que 1 corresponderia
a primeiro de janeiro. Para resolver o problema, podemos sortear n
datas, e ver se h√° alguma repeti√ß√£o, se houver encontramos duas pessoas
com a mesma data.

Isso est√° representado na fun√ß√£o experimento\_niver abaixo. Mas, para
saber a chance real, temos que repetr o experimento v√°rias vezes. Na
fun√ß√£o main() abaixo, pedimos a quantidade de experimentos e o n√∫mero de
pessoas para executar a simula√ß√£o.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{experimento\_niver}\NormalTok{(n)}
\NormalTok{    repetiu }\OperatorTok{=} \ConstantTok{false}
\NormalTok{    i }\OperatorTok{=} \FloatTok{1}
\NormalTok{    nivers }\OperatorTok{=}\NormalTok{ []}
    \ControlFlowTok{while}\NormalTok{ i }\OperatorTok{\textless{}=}\NormalTok{ n }\OperatorTok{\&\&}\NormalTok{ (repetiu }\OperatorTok{==} \ConstantTok{false}\NormalTok{)}
\NormalTok{        niver }\OperatorTok{=} \FunctionTok{rand}\NormalTok{(}\FloatTok{1}\OperatorTok{:}\FloatTok{365}\NormalTok{)}
        \ControlFlowTok{if}\NormalTok{ niver }\KeywordTok{in}\NormalTok{ nivers}
\NormalTok{            repetiu }\OperatorTok{=} \ConstantTok{true}
        \ControlFlowTok{end}
        \FunctionTok{push!}\NormalTok{(nivers, niver)}
\NormalTok{        i }\OperatorTok{+=} \FloatTok{1}
    \ControlFlowTok{end}
    \ControlFlowTok{return}\NormalTok{ repetiu}
\KeywordTok{end}

\KeywordTok{function} \FunctionTok{main}\NormalTok{()}
    \FunctionTok{print}\NormalTok{(}\StringTok{"Quantos experimentos? "}\NormalTok{)}
\NormalTok{    quantas }\OperatorTok{=} \FunctionTok{readline}\NormalTok{()}
    \FunctionTok{print}\NormalTok{(}\StringTok{"Quantas pessoas? "}\NormalTok{)}
\NormalTok{    npessoas }\OperatorTok{=} \FunctionTok{readline}\NormalTok{()}
\NormalTok{    quantas }\OperatorTok{=} \FunctionTok{parse}\NormalTok{(}\DataTypeTok{Int64}\NormalTok{, quantas)}
\NormalTok{    npessoas }\OperatorTok{=} \FunctionTok{parse}\NormalTok{(}\DataTypeTok{Int64}\NormalTok{, npessoas)}
\NormalTok{    sucessos }\OperatorTok{=} \FloatTok{0}
\NormalTok{    i }\OperatorTok{=} \FloatTok{1}
    \ControlFlowTok{while}\NormalTok{ i }\OperatorTok{\textless{}=}\NormalTok{ quantas}
        \ControlFlowTok{if} \FunctionTok{experimento\_niver}\NormalTok{(npessoas)}
\NormalTok{            sucessos }\OperatorTok{+=} \FloatTok{1}
        \ControlFlowTok{end}
\NormalTok{        i }\OperatorTok{+=} \FloatTok{1}
    \ControlFlowTok{end}
    \FunctionTok{println}\NormalTok{(}\StringTok{"A probabilidade estimada √© "}\NormalTok{, }\FloatTok{100}\OperatorTok{*}\NormalTok{sucessos}\OperatorTok{/}\NormalTok{quantas, }\StringTok{"\%"}\NormalTok{)}
\KeywordTok{end}
\FunctionTok{main}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

A parte interessante √© que podemos com pequenas varia√ß√µes ter outros
experimentos, como verificar se mais do que duas pessoas fazem
anivers√°rio na mesma data. Para isso, abaixo, contamos o n√∫mero de
repeti√ß√µes.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{experimento\_niver}\NormalTok{(n)}
\NormalTok{    repetiu }\OperatorTok{=} \FloatTok{0}
\NormalTok{    i }\OperatorTok{=} \FloatTok{1}
\NormalTok{    nivers }\OperatorTok{=}\NormalTok{ []}
    \ControlFlowTok{while}\NormalTok{ i }\OperatorTok{\textless{}=}\NormalTok{ n}
\NormalTok{        niver }\OperatorTok{=} \FunctionTok{rand}\NormalTok{(}\FloatTok{1}\OperatorTok{:}\FloatTok{365}\NormalTok{)}
        \ControlFlowTok{if}\NormalTok{ niver }\KeywordTok{in}\NormalTok{ nivers}
\NormalTok{            repetiu }\OperatorTok{+=} \FloatTok{1}
        \ControlFlowTok{end}
        \FunctionTok{push!}\NormalTok{(nivers, niver)}
\NormalTok{        i }\OperatorTok{+=} \FloatTok{1}
    \ControlFlowTok{end}
    \ControlFlowTok{return}\NormalTok{ repetiu }\OperatorTok{\textgreater{}=} \FloatTok{2}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
experimento_niver (generic function with 1 method)
\end{verbatim}

\bookmarksetup{startatroot}

\chapter{Modelando um problema maior}\label{modelando-um-problema-maior}

Nessa aula vamos modelar um jogo bem conhecido, o 21, ou BlackJack. Nele
os jogadores devem tentar chegar mais perto da soma de cartas 21, sem
estourar. Quem chegar mais perto ganha.

Cada jogador come√ßa com duas cartas, sendo que as cartas tem o seu valor
nominal, as figuras (J, Q, K), que valem 10. Al√©m disso, o √Ås, pode
valer 1 ou 11. O que for mais vantajoso para o jogador.

Para come√ßar vamos fazer uma simula√ß√£o com um baralho, ou seja 52
cartas. J√° que{]} para o jogo, n√£o importa o naipe da carta, vamos supor
que existem quatro cartas de cada. Para isso, vamos criar duas fun√ß√µes,
uma que cria um baralho e o guarda em um vetor, e uma segunda que pega
uma carta do baralho. Nessa segunda fun√ß√£o temos que ``retirar'' a carta
do vetor. Caso j√° n√£o exista a carta do tipo desejado, temos que sortear
uma nova carta.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{criaBaralho}\NormalTok{()}
\NormalTok{  cards }\OperatorTok{=} \FunctionTok{zeros}\NormalTok{(}\DataTypeTok{Int8}\NormalTok{, }\FloatTok{13}\NormalTok{)}
\NormalTok{  i }\OperatorTok{=} \FloatTok{1}
  \ControlFlowTok{while}\NormalTok{ i }\OperatorTok{\textless{}} \FloatTok{14}
\NormalTok{    cards[i] }\OperatorTok{=} \FloatTok{4}
\NormalTok{    i }\OperatorTok{+=} \FloatTok{1}
  \ControlFlowTok{end}
  \ControlFlowTok{return}\NormalTok{ cards}
\KeywordTok{end}

\KeywordTok{function} \FunctionTok{pegarCarta}\NormalTok{(cards)}
\NormalTok{  sorteio }\OperatorTok{=} \FunctionTok{rand}\NormalTok{(}\FloatTok{1}\OperatorTok{:}\FloatTok{13}\NormalTok{)}
  \ControlFlowTok{while}\NormalTok{ cards[sorteio] }\OperatorTok{==} \FloatTok{0}
\NormalTok{    sorteio }\OperatorTok{=} \FunctionTok{rand}\NormalTok{(}\FloatTok{1}\OperatorTok{:}\FloatTok{13}\NormalTok{)}
  \ControlFlowTok{end}
\NormalTok{  cards[sorteio] }\OperatorTok{{-}=} \FloatTok{1}
  \ControlFlowTok{if}\NormalTok{ sorteio }\OperatorTok{\textgreater{}} \FloatTok{10}  \CommentTok{\# se a carta for figura, ela vale 10}
\NormalTok{    sorteio }\OperatorTok{=} \FloatTok{10}
  \ControlFlowTok{end}  
  \ControlFlowTok{return}\NormalTok{ sorteio}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
pegarCarta (generic function with 1 method)
\end{verbatim}

De posse dessas duas fun√ß√µes, podemos criar outras que simulam o
comportamento dos jogadores. Vamos usar algumas estrat√©gias simples,
como o jogador que fica com as duas cartas que recebeu.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{jogador1}\NormalTok{(cards)}
\NormalTok{  carta1 }\OperatorTok{=} \FunctionTok{pegarCarta}\NormalTok{(cards)}
\NormalTok{  carta2 }\OperatorTok{=} \FunctionTok{pegarCarta}\NormalTok{(cards)}
  \ControlFlowTok{if}\NormalTok{ carta1 }\OperatorTok{==} \FloatTok{1} \OperatorTok{||}\NormalTok{ carta2 }\OperatorTok{==} \FloatTok{1}
    \ControlFlowTok{return}\NormalTok{ carta1 }\OperatorTok{+}\NormalTok{ carta2 }\OperatorTok{+} \FloatTok{10}
  \ControlFlowTok{else}
    \ControlFlowTok{return}\NormalTok{ carta1 }\OperatorTok{+}\NormalTok{ carta2}
  \ControlFlowTok{end}  
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
jogador1 (generic function with 1 method)
\end{verbatim}

Notem que acima, usamos a estrat√©gia de usar o √Ås da forma mais
vantajosa.

Para os outros jogadores, vamos usar estrat√©gias mais elaboradas, ou
seja o jogador fica pegando cartas enquanto n√£o chegar a um valor
pr√©-determinado, como por exemplo 21, 19, 17, 15 e 13.

Como cada jogador pode ter um n√∫mero grande de cartas e no caso dele ter
um √Ås, a conta tem que ser feita da maneira mais vantajosa, vamos usar
uma fun√ß√£o que recebe um vetor de cartas e calcula a soma.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{somaCartas}\NormalTok{(c)}
\NormalTok{  soma }\OperatorTok{=} \FloatTok{0}
\NormalTok{  temAz }\OperatorTok{=} \ConstantTok{false}
  \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in}\NormalTok{ c}
\NormalTok{    soma }\OperatorTok{+=}\NormalTok{ i}
    \ControlFlowTok{if}\NormalTok{ c }\OperatorTok{==} \FloatTok{1} 
\NormalTok{      temAz }\OperatorTok{=} \ConstantTok{true}
    \ControlFlowTok{end}
  \ControlFlowTok{end}
  \ControlFlowTok{if}\NormalTok{ soma }\OperatorTok{\textless{}=} \FloatTok{11} \OperatorTok{\&\&}\NormalTok{ temAz}
      \ControlFlowTok{return}\NormalTok{ soma }\OperatorTok{+} \FloatTok{10}
  \ControlFlowTok{else} 
      \ControlFlowTok{return}\NormalTok{ soma}
  \ControlFlowTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
somaCartas (generic function with 1 method)
\end{verbatim}

De posse do soma cartas, podemos modelar os jogadores.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{jogador2}\NormalTok{(cards)}
\NormalTok{  cartas }\OperatorTok{=}\NormalTok{ []}
  \FunctionTok{push!}\NormalTok{(cartas, }\FunctionTok{pegarCarta}\NormalTok{(cards))}
  \FunctionTok{push!}\NormalTok{(cartas, }\FunctionTok{pegarCarta}\NormalTok{(cards))}
  \ControlFlowTok{while} \FunctionTok{somaCartas}\NormalTok{(cartas) }\OperatorTok{\textless{}} \FloatTok{21}
    \FunctionTok{push!}\NormalTok{(cartas, }\FunctionTok{pegarCarta}\NormalTok{(cards))}
  \ControlFlowTok{end}
  \ControlFlowTok{return} \FunctionTok{somaCartas}\NormalTok{(cartas)}
\KeywordTok{end}

\KeywordTok{function} \FunctionTok{jogador3}\NormalTok{(cards)}
\NormalTok{  cartas }\OperatorTok{=}\NormalTok{ []}
  \FunctionTok{push!}\NormalTok{(cartas, }\FunctionTok{pegarCarta}\NormalTok{(cards))}
  \FunctionTok{push!}\NormalTok{(cartas, }\FunctionTok{pegarCarta}\NormalTok{(cards))}
  \ControlFlowTok{while} \FunctionTok{somaCartas}\NormalTok{(cartas) }\OperatorTok{\textless{}} \FloatTok{19}
    \FunctionTok{push!}\NormalTok{(cartas,}\FunctionTok{pegarCarta}\NormalTok{(cards))}
  \ControlFlowTok{end}
  \ControlFlowTok{return} \FunctionTok{somaCartas}\NormalTok{(cartas)}
\KeywordTok{end}

\KeywordTok{function} \FunctionTok{jogador4}\NormalTok{(cards)}
\NormalTok{  cartas }\OperatorTok{=}\NormalTok{ []}
  \FunctionTok{push!}\NormalTok{(cartas, }\FunctionTok{pegarCarta}\NormalTok{(cards))}
  \FunctionTok{push!}\NormalTok{(cartas, }\FunctionTok{pegarCarta}\NormalTok{(cards))}
  \ControlFlowTok{while} \FunctionTok{somaCartas}\NormalTok{(cartas) }\OperatorTok{\textless{}} \FloatTok{17}
    \FunctionTok{push!}\NormalTok{(cartas,}\FunctionTok{pegarCarta}\NormalTok{(cards))}
  \ControlFlowTok{end}
  \ControlFlowTok{return} \FunctionTok{somaCartas}\NormalTok{(cartas)}
\KeywordTok{end}

  \KeywordTok{function} \FunctionTok{jogador5}\NormalTok{(cards)}
\NormalTok{    cartas }\OperatorTok{=}\NormalTok{ []}
    \FunctionTok{push!}\NormalTok{(cartas, }\FunctionTok{pegarCarta}\NormalTok{(cards))}
    \FunctionTok{push!}\NormalTok{(cartas, }\FunctionTok{pegarCarta}\NormalTok{(cards))}
    \ControlFlowTok{while} \FunctionTok{somaCartas}\NormalTok{(cartas) }\OperatorTok{\textless{}} \FloatTok{15}
      \FunctionTok{push!}\NormalTok{(cartas,}\FunctionTok{pegarCarta}\NormalTok{(cards))}
    \ControlFlowTok{end}
    \ControlFlowTok{return} \FunctionTok{somaCartas}\NormalTok{(cartas)}
  \KeywordTok{end}

\KeywordTok{function} \FunctionTok{jogador6}\NormalTok{(cards)}
\NormalTok{  cartas }\OperatorTok{=}\NormalTok{ []}
  \FunctionTok{push!}\NormalTok{(cartas, }\FunctionTok{pegarCarta}\NormalTok{(cards))}
  \FunctionTok{push!}\NormalTok{(cartas, }\FunctionTok{pegarCarta}\NormalTok{(cards))}
  \ControlFlowTok{while} \FunctionTok{somaCartas}\NormalTok{(cartas) }\OperatorTok{\textless{}} \FloatTok{13}
    \FunctionTok{push!}\NormalTok{(cartas,}\FunctionTok{pegarCarta}\NormalTok{(cards))}
  \ControlFlowTok{end}
  \ControlFlowTok{return} \FunctionTok{somaCartas}\NormalTok{(cartas)}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
jogador6 (generic function with 1 method)
\end{verbatim}

Agora que temos todos os jogadores, podemos modelar uma partida. Para
isso criamos um baralho e fazemos com que cada jogador siga a sua
estrat√©gia

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{partida}\NormalTok{()}
\NormalTok{  cards }\OperatorTok{=} \FunctionTok{criaBaralho}\NormalTok{()}
\NormalTok{  jogadores }\OperatorTok{=} \FunctionTok{zeros}\NormalTok{(}\DataTypeTok{Int8}\NormalTok{, }\FloatTok{6}\NormalTok{)}
\NormalTok{  jogadores[}\FloatTok{1}\NormalTok{] }\OperatorTok{=} \FunctionTok{jogador1}\NormalTok{(cards)}
\NormalTok{  jogadores[}\FloatTok{2}\NormalTok{] }\OperatorTok{=} \FunctionTok{jogador2}\NormalTok{(cards)}
\NormalTok{  jogadores[}\FloatTok{3}\NormalTok{] }\OperatorTok{=} \FunctionTok{jogador3}\NormalTok{(cards)}
\NormalTok{  jogadores[}\FloatTok{4}\NormalTok{] }\OperatorTok{=} \FunctionTok{jogador4}\NormalTok{(cards)}
\NormalTok{  jogadores[}\FloatTok{5}\NormalTok{] }\OperatorTok{=} \FunctionTok{jogador5}\NormalTok{(cards)}
\NormalTok{  jogadores[}\FloatTok{6}\NormalTok{] }\OperatorTok{=} \FunctionTok{jogador6}\NormalTok{(cards)}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
partida (generic function with 1 method)
\end{verbatim}

N√£o deu tempo de continuar, ficou para a pr√≥xima aula.

\bookmarksetup{startatroot}

\chapter{Continuando a modelagem}\label{continuando-a-modelagem}

No cap√≠tulo anterior ficamos com uma partida, mas sem a verifica√ß√£o do
vencedor, ou seja o jogador com o maior valor, menor ou igual a 21. Uma
decis√£o de projeto √© dizer que no caso de empate, os jogadores, com os
maiores valores ganham e dividem o pr√™mio.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{partida}\NormalTok{()}
\NormalTok{  cards }\OperatorTok{=} \FunctionTok{criaBaralho}\NormalTok{()}
\NormalTok{  jogadores }\OperatorTok{=} \FunctionTok{zeros}\NormalTok{(}\DataTypeTok{Int8}\NormalTok{, }\FloatTok{6}\NormalTok{)}
\NormalTok{  jogadores[}\FloatTok{1}\NormalTok{] }\OperatorTok{=} \FunctionTok{jogador1}\NormalTok{(cards)}
\NormalTok{  jogadores[}\FloatTok{2}\NormalTok{] }\OperatorTok{=} \FunctionTok{jogador2}\NormalTok{(cards)}
\NormalTok{  jogadores[}\FloatTok{3}\NormalTok{] }\OperatorTok{=} \FunctionTok{jogador3}\NormalTok{(cards)}
\NormalTok{  jogadores[}\FloatTok{4}\NormalTok{] }\OperatorTok{=} \FunctionTok{jogador4}\NormalTok{(cards)}
\NormalTok{  jogadores[}\FloatTok{5}\NormalTok{] }\OperatorTok{=} \FunctionTok{jogador5}\NormalTok{(cards)}
\NormalTok{  jogadores[}\FloatTok{6}\NormalTok{] }\OperatorTok{=} \FunctionTok{jogador6}\NormalTok{(cards)}
  \ControlFlowTok{return}\NormalTok{ jogadores}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
partida (generic function with 1 method)
\end{verbatim}

Logo, a partida devolve a pontua√ß√£o de cada jogador, para podermos
verificar na rotina ganhador quem ganhou.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{ganhador}\NormalTok{(v)}
\NormalTok{    i }\OperatorTok{=} \FloatTok{1}
\NormalTok{    maximo }\OperatorTok{=} \FloatTok{0}
    \ControlFlowTok{while}\NormalTok{ i }\OperatorTok{\textless{}=} \FunctionTok{length}\NormalTok{(v)}
        \ControlFlowTok{if}\NormalTok{ v[i] }\OperatorTok{\textgreater{}} \FloatTok{21}  \CommentTok{\# se estourou √© como se tivesse o menor valor}
\NormalTok{            v[i] }\OperatorTok{=} \FloatTok{0}
        \ControlFlowTok{end}
        \ControlFlowTok{if}\NormalTok{ v[i] }\OperatorTok{\textgreater{}}\NormalTok{ maximo}
\NormalTok{            maximo }\OperatorTok{=}\NormalTok{ v[i]  }\CommentTok{\# encontra o vencedor}
        \ControlFlowTok{end}
\NormalTok{        i }\OperatorTok{=}\NormalTok{ i }\OperatorTok{+} \FloatTok{1}
    \ControlFlowTok{end}
\NormalTok{    result }\OperatorTok{=} \FunctionTok{zeros}\NormalTok{(}\DataTypeTok{Int64}\NormalTok{, }\FunctionTok{length}\NormalTok{(v))}
\NormalTok{    i }\OperatorTok{=} \FloatTok{1}
        \ControlFlowTok{while}\NormalTok{ i }\OperatorTok{\textless{}=} \FunctionTok{length}\NormalTok{(v)}
            \ControlFlowTok{if}\NormalTok{ v[i] }\OperatorTok{==}\NormalTok{ maximo}
\NormalTok{                result[i] }\OperatorTok{=} \FloatTok{1}
            \ControlFlowTok{end}
\NormalTok{            i }\OperatorTok{=}\NormalTok{ i }\OperatorTok{+} \FloatTok{1}
        \ControlFlowTok{end}
    \ControlFlowTok{return}\NormalTok{ result}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
ganhador (generic function with 1 method)
\end{verbatim}

A rotinha ganhador devolve um vetor com os vencedores, com 1 na posi√ß√£o
de quem ganhou e zero na posi√ß√£o dos perdedores.

Uma das vantagens de se usar um computador √© que podemos ter milhares de
partidas de 21 para encontrar qual seria a melhor estrat√©gia.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{porcentagem}\NormalTok{()}
\NormalTok{    i }\OperatorTok{=} \FloatTok{1}
\NormalTok{    porc }\OperatorTok{=} \FunctionTok{zeros}\NormalTok{(}\DataTypeTok{Int64}\NormalTok{, }\FloatTok{6}\NormalTok{)}
    \ControlFlowTok{while}\NormalTok{ i }\OperatorTok{\textless{}} \FloatTok{100000}
\NormalTok{        porc }\OperatorTok{=}\NormalTok{ porc }\OperatorTok{+} \FunctionTok{ganhador}\NormalTok{(}\FunctionTok{partida}\NormalTok{())}
\NormalTok{        i }\OperatorTok{=}\NormalTok{ i }\OperatorTok{+} \FloatTok{1}
    \ControlFlowTok{end}
    \FunctionTok{println}\NormalTok{(porc)}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
porcentagem (generic function with 1 method)
\end{verbatim}

Ao simularmos o jogo 10000 vezes, podemos encontrar qual √© a melhor
estrat√©gia dentre as que foram apresentadas.

O c√≥digo acima ficou relativamente grande, e uma das coisas que podemos
notar √© que h√° muita duplica√ß√£o nos c√≥digos dos Jogadores a partir do
segundo. Um dos maiores problemas de c√≥digo √© a duplica√ß√£o. No caso
acima, podemos evit√°-la adicionando um par√¢metro √† fun√ß√£o Jogador, de
forma que esse seja o limite a ser considerado no la√ßo. A fun√ß√£o
jogador2 fica assim:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{jogador2}\NormalTok{(cards, valor)}
\NormalTok{    cartas }\OperatorTok{=}\NormalTok{ []}
    \FunctionTok{push!}\NormalTok{(cartas, }\FunctionTok{pegarCarta}\NormalTok{(cards))}
    \FunctionTok{push!}\NormalTok{(cartas, }\FunctionTok{pegarCarta}\NormalTok{(cards))}
    \ControlFlowTok{while} \FunctionTok{somaCartas}\NormalTok{(cartas) }\OperatorTok{\textless{}}\NormalTok{ valor}
       \FunctionTok{push!}\NormalTok{(cartas, }\FunctionTok{pegarCarta}\NormalTok{(cards))}
    \ControlFlowTok{end}
    \ControlFlowTok{return} \FunctionTok{somaCartas}\NormalTok{(cartas)}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
jogador2 (generic function with 1 method)
\end{verbatim}

Como a fun√ß√£o tem um par√¢metro novo, temos que acertar a partida. Mas,
agora podemos usar todos os valores.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{partida}\NormalTok{()}
\NormalTok{   cards }\OperatorTok{=} \FunctionTok{criaBaralho}\NormalTok{()}
\NormalTok{   jogadores }\OperatorTok{=} \FunctionTok{zeros}\NormalTok{(}\DataTypeTok{Int8}\NormalTok{, }\FloatTok{6}\NormalTok{)}
\NormalTok{   jogadores[}\FloatTok{1}\NormalTok{] }\OperatorTok{=} \FunctionTok{jogador1}\NormalTok{(cards)}
\NormalTok{   jogadores[}\FloatTok{2}\NormalTok{] }\OperatorTok{=} \FunctionTok{jogador2}\NormalTok{(cards, }\FloatTok{21}\NormalTok{)}
\NormalTok{   jogadores[}\FloatTok{3}\NormalTok{] }\OperatorTok{=} \FunctionTok{jogador2}\NormalTok{(cards, }\FloatTok{20}\NormalTok{)}
\NormalTok{   jogadores[}\FloatTok{4}\NormalTok{] }\OperatorTok{=} \FunctionTok{jogador2}\NormalTok{(cards, }\FloatTok{19}\NormalTok{)}
\NormalTok{   jogadores[}\FloatTok{5}\NormalTok{] }\OperatorTok{=} \FunctionTok{jogador2}\NormalTok{(cards, }\FloatTok{18}\NormalTok{)}
\NormalTok{   jogadores[}\FloatTok{6}\NormalTok{] }\OperatorTok{=} \FunctionTok{jogador2}\NormalTok{(cards, }\FloatTok{17}\NormalTok{)}
   \ControlFlowTok{return}\NormalTok{ jogadores}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
partida (generic function with 1 method)
\end{verbatim}

Notem que n√£o h√° mudan√ßa na fun√ß√£o ganhador, que continua funcionando.

Para terminar, podemos ter agora uma vers√£o interativa que permite que
um jogador humano jogue com o computador.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{partidaComHumano}\NormalTok{()}
\NormalTok{    cards }\OperatorTok{=} \FunctionTok{criaBaralho}\NormalTok{()}
\NormalTok{    humano }\OperatorTok{=}\NormalTok{ []}
\NormalTok{    computador }\OperatorTok{=} \FunctionTok{jogador2}\NormalTok{(cards, }\FloatTok{19}\NormalTok{)}
    \FunctionTok{push!}\NormalTok{(humano, }\FunctionTok{pegarCarta}\NormalTok{(cards))}
    \FunctionTok{push!}\NormalTok{(humano, }\FunctionTok{pegarCarta}\NormalTok{(cards))}
    \FunctionTok{println}\NormalTok{(}\StringTok{"O humano tem "}\NormalTok{, humano, }\StringTok{" e soma "}\NormalTok{, }\FunctionTok{somaCartas}\NormalTok{(humano))}
    \FunctionTok{println}\NormalTok{(}\StringTok{"O humano quer mais cartas (S/N)?"}\NormalTok{)}
\NormalTok{    resp }\OperatorTok{=} \FunctionTok{readline}\NormalTok{()}
    \ControlFlowTok{while}\NormalTok{ resp }\OperatorTok{==} \StringTok{"S"} \OperatorTok{||}\NormalTok{ resp }\OperatorTok{==} \StringTok{"s"}
         \FunctionTok{push!}\NormalTok{(humano, }\FunctionTok{pegarCarta}\NormalTok{(cards))}
         \FunctionTok{println}\NormalTok{(}\StringTok{"O computador tem "}\NormalTok{, computador, }\StringTok{" e soma "}\NormalTok{, }\FunctionTok{somaCartas}\NormalTok{(computador))}
         \FunctionTok{println}\NormalTok{(}\StringTok{"O humano tem "}\NormalTok{, humano, }\StringTok{" e soma "}\NormalTok{, }\FunctionTok{somaCartas}\NormalTok{(humano))}
         \FunctionTok{println}\NormalTok{(}\StringTok{"O humano quer mais cartas (S/N)?"}\NormalTok{)}
\NormalTok{         resp }\OperatorTok{=} \FunctionTok{readline}\NormalTok{()}
    \ControlFlowTok{end}
    \FunctionTok{println}\NormalTok{(}\StringTok{"O computador tem "}\NormalTok{, computador, }\StringTok{" e soma "}\NormalTok{, }\FunctionTok{somaCartas}\NormalTok{(computador))}
    \ControlFlowTok{if} \FunctionTok{somaCartas}\NormalTok{(computador) }\OperatorTok{\textless{}=} \FloatTok{21} \OperatorTok{\&\&} \FunctionTok{somaCartas}\NormalTok{(humano) }\OperatorTok{\textless{}=} \FloatTok{21}
         \ControlFlowTok{if} \FunctionTok{somaCartas}\NormalTok{(computador) }\OperatorTok{\textgreater{}} \FunctionTok{somaCartas}\NormalTok{(humano)}
             \FunctionTok{println}\NormalTok{(}\StringTok{"Humano Perdeu"}\NormalTok{)}
         \ControlFlowTok{elseif} \FunctionTok{somaCartas}\NormalTok{(computador) }\OperatorTok{==} \FunctionTok{somaCartas}\NormalTok{(humano)}
             \FunctionTok{println}\NormalTok{(}\StringTok{"Empate"}\NormalTok{)}
         \ControlFlowTok{else}
             \FunctionTok{println}\NormalTok{(}\StringTok{"Humano ganhou"}\NormalTok{)}
         \ControlFlowTok{end}
    \ControlFlowTok{elseif} \FunctionTok{somaCartas}\NormalTok{(computador) }\OperatorTok{\textgreater{}} \FloatTok{21} \OperatorTok{\&\&} \FunctionTok{somaCartas}\NormalTok{(humano) }\OperatorTok{\textgreater{}} \FloatTok{21}
         \FunctionTok{println}\NormalTok{(}\StringTok{"os dois perderam"}\NormalTok{)}
    \ControlFlowTok{elseif} \FunctionTok{somaCartas}\NormalTok{(computador) }\OperatorTok{\textgreater{}} \FloatTok{21}
         \FunctionTok{println}\NormalTok{(}\StringTok{"Humano ganhou"}\NormalTok{)}
    \ControlFlowTok{else}
         \FunctionTok{println}\NormalTok{(}\StringTok{"Computador ganhou"}\NormalTok{)}
    \ControlFlowTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
partidaComHumano (generic function with 1 method)
\end{verbatim}

\bookmarksetup{startatroot}

\chapter{Boas pr√°ticas}\label{boas-pruxe1ticas}

Vamos come√ßar apresentando 3 boas pr√°ticas de programa√ß√£o. Na verdade h√°
uma √°rea que cuida de desenvolvimento de software, a Engenharia de
Software. Vamos a elas:

\section{Uso de contratos}\label{uso-de-contratos}

Sempre que poss√≠vel o c√≥digo deve ser modular, ou seja estar repartido
em arquivos e ou fun√ß√µes. Cada tipo de fun√ß√£o deve deixar claro quais
s√£o os seus par√¢metros e o que ela devolve. Isso pode ser feito usando
tipos.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{fatorial}\NormalTok{(n}\OperatorTok{::}\DataTypeTok{Int64}\NormalTok{)}\OperatorTok{::}\DataTypeTok{Int64}
    \ControlFlowTok{if}\NormalTok{ n }\OperatorTok{\textless{}} \FloatTok{2} 
        \ControlFlowTok{return} \FloatTok{1}
    \ControlFlowTok{else}  
        \ControlFlowTok{return}\NormalTok{ n }\OperatorTok{*} \FunctionTok{fatorial}\NormalTok{(n }\OperatorTok{{-}} \FloatTok{1}\NormalTok{)}
    \ControlFlowTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
fatorial (generic function with 1 method)
\end{verbatim}

Com isso, fica claro o que a fun√ß√£o recebe e devolve, e se for enviado
um tipo diferente do esperado, temos em erro imediato.

\subsection{Boa pr√°tica 1: Use tipos}\label{boa-pruxe1tica-1-use-tipos}

\section{Testes automatizados}\label{testes-automatizados}

Para evitar que apare√ßam erros, ou os populates bugs, uma forma eficaz √©
escrever c√≥digo que verifica o funcionamento do c√≥digo. Se isso for
feito de forma autom√°tica, temos os testes automatizados.

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{using} \BuiltInTok{Test}
\KeywordTok{function} \FunctionTok{testaFat}\NormalTok{()}
  \PreprocessorTok{@test} \FunctionTok{fatorial}\NormalTok{(}\FloatTok{3}\NormalTok{) }\OperatorTok{==} \FloatTok{6}
  \PreprocessorTok{@test} \FunctionTok{fatorial}\NormalTok{(}\FloatTok{5}\NormalTok{) }\OperatorTok{==} \FloatTok{120}
  \PreprocessorTok{@test} \FunctionTok{fatorial}\NormalTok{(}\FloatTok{1}\NormalTok{) }\OperatorTok{==} \FloatTok{1}
  \PreprocessorTok{@test} \FunctionTok{fatorial}\NormalTok{(}\FloatTok{0}\NormalTok{) }\OperatorTok{==} \FloatTok{1}
  \PreprocessorTok{@test} \FunctionTok{fatorial}\NormalTok{(}\FloatTok{4}\NormalTok{) }\OperatorTok{==} \FloatTok{24}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
testaFat (generic function with 1 method)
\end{verbatim}

\subsection{Boa pr√°tica 2: Sempre que poss√≠vel fa√ßa
testes}\label{boa-pruxe1tica-2-sempre-que-possuxedvel-fauxe7a-testes}

\section{Escreva c√≥digo para humanos, n√£o para
computadores}\label{escreva-cuxf3digo-para-humanos-nuxe3o-para-computadores}

Apesar dos computadores serem capazes de ler c√≥digo nem sempre bem
formatado, √© bem dif√≠cil para humanos lerem c√≥digo de forma n√£o padr√£o.
Por isso algumas dicas importantes s√£o:

\begin{itemize}
\item
  Use identa√ß√£o. Com isso, os blocos ficam bem claros e √© f√°cil
  identificar os la√ßos, blocos de if e corpos de fun√ß√£o;
\item
  Escolha bem o nome das vari√°veis e fun√ß√µes, isso ajuda muito quem for
  ler o c√≥digo
\item
  Sempre que voc√™ identificar uma possibilidade de melhoria no c√≥digo,
  implemente. Ainda melhor se voc√™ tiver testes automatizados, para
  verificar que a melhoria n√£o quebrou o c√≥digo.
\end{itemize}

\subsection{Boa pr√°tica 3: Escreva c√≥digo para que outros
leiam}\label{boa-pruxe1tica-3-escreva-cuxf3digo-para-que-outros-leiam}

\section{Aplicando as boas
pr√°ticas}\label{aplicando-as-boas-pruxe1ticas}

Vamos agora resolver o seguinte problema, aplicando as pr√°ticas acima.
Dada um vetor com n√∫meros reais, determinar os n√∫meros que est√£o no
vetor e o n√∫mero de vezes que cada um deles ocorre na mesma.

Ao analizar o problema, vemos que temos como entrada um vetor de n√∫mero
reais, que pode conter repeti√ß√µes. Para determinar os n√∫meros que est√£o
no vetor, podemos usar um outro vetor de sa√≠da. Sendo que o de entrada e
o de sa√≠da devem ser do tipo Float64. Al√©m disso, para o vetor que
fornece a quantidade de n√∫meros temos um vetor de inteiros. De posse
disso, j√° temos a assinatura da fun√ß√£o.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{contHist}\NormalTok{(v}\OperatorTok{::}\DataTypeTok{Vector\{Float64\}}\NormalTok{, el}\OperatorTok{::}\DataTypeTok{Vector\{Float64\}}\NormalTok{, qtd}\OperatorTok{::}\DataTypeTok{Vector\{Int64\}}\NormalTok{)}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
contHist (generic function with 1 method)
\end{verbatim}

De posse dessa assinatura, j√° podemos escrever os testes.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{verifica}\NormalTok{(v}\OperatorTok{::}\DataTypeTok{Vector\{Float64\}}\NormalTok{, elementos}\OperatorTok{::}\DataTypeTok{Vector\{Float64\}}\NormalTok{, }
\NormalTok{     quant}\OperatorTok{::}\DataTypeTok{Vector\{Int64\}}\NormalTok{)}
\NormalTok{     el }\OperatorTok{=} \DataTypeTok{Float64}\NormalTok{[]}
\NormalTok{     quan }\OperatorTok{=} \DataTypeTok{Int64}\NormalTok{[]}
     \FunctionTok{contHist}\NormalTok{(v, el, quan)}
     \ControlFlowTok{if}\NormalTok{ el }\OperatorTok{==}\NormalTok{ elementos }\OperatorTok{\&\&}\NormalTok{ quan }\OperatorTok{==}\NormalTok{ quant}
        \ControlFlowTok{return} \ConstantTok{true}
     \ControlFlowTok{else}
        \ControlFlowTok{return} \ConstantTok{false}
     \ControlFlowTok{end}
\KeywordTok{end}

\KeywordTok{function} \FunctionTok{testaLista}\NormalTok{()}
  \PreprocessorTok{@test} \FunctionTok{verifica}\NormalTok{([}\FloatTok{1.3}\NormalTok{, }\FloatTok{1.2}\NormalTok{, }\FloatTok{0.0}\NormalTok{, }\FloatTok{1.3}\NormalTok{], [}\FloatTok{1.3}\NormalTok{, }\FloatTok{1.2}\NormalTok{, }\FloatTok{0.0}\NormalTok{], [}\FloatTok{2}\NormalTok{, }\FloatTok{1}\NormalTok{, }\FloatTok{1}\NormalTok{])}
  \PreprocessorTok{@test} \FunctionTok{verifica}\NormalTok{([}\FloatTok{1.0}\NormalTok{, }\FloatTok{1.0}\NormalTok{, }\FloatTok{1.0}\NormalTok{, }\FloatTok{1.0}\NormalTok{], [}\FloatTok{1.0}\NormalTok{], [}\FloatTok{4}\NormalTok{])}
  \PreprocessorTok{@test} \FunctionTok{verifica}\NormalTok{([}\FloatTok{8.3}\NormalTok{], [}\FloatTok{8.3}\NormalTok{], [}\FloatTok{1}\NormalTok{])}
  \PreprocessorTok{@test} \FunctionTok{verifica}\NormalTok{([}\FloatTok{3.14}\NormalTok{, }\FloatTok{2.78}\NormalTok{, }\FloatTok{2.78}\NormalTok{], [}\FloatTok{3.14}\NormalTok{, }\FloatTok{2.78}\NormalTok{], [}\FloatTok{1}\NormalTok{, }\FloatTok{2}\NormalTok{])}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
testaLista (generic function with 1 method)
\end{verbatim}

Finalmente, podemos escrever o c√≥digo. A idea para escrever a solu√ß√£o √©
simples, vamos percorrer o vetor de entrada. Para cada elemento, temos
duas possibilidades, se ele n√£o tiver aparecido antes, temos que
adicionar o n√∫mero ao vetor sa√≠da e marcar 1 ocorr√™ncia. Se j√° apareceu,
basta incrementar o n√∫mero de ocorr√™ncias.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{contHist}\NormalTok{(v}\OperatorTok{::}\DataTypeTok{Vector\{Float64\}}\NormalTok{, el}\OperatorTok{::}\DataTypeTok{Vector\{Float64\}}\NormalTok{, qtd}\OperatorTok{::}\DataTypeTok{Vector\{Int64\}}\NormalTok{)}
    \ControlFlowTok{for}\NormalTok{ a }\KeywordTok{in}\NormalTok{ v}
        \ControlFlowTok{if}\NormalTok{ a }\KeywordTok{in}\NormalTok{ el}
\NormalTok{            i }\OperatorTok{=} \FloatTok{1}
            \ControlFlowTok{while}\NormalTok{ el[i] }\OperatorTok{!=}\NormalTok{ a}
\NormalTok{               i }\OperatorTok{+=} \FloatTok{1}
            \ControlFlowTok{end}
\NormalTok{            qtd[i] }\OperatorTok{+=} \FloatTok{1}
        \ControlFlowTok{else}
            \FunctionTok{push!}\NormalTok{(el, a)}
            \FunctionTok{push!}\NormalTok{(qtd, }\FloatTok{1}\NormalTok{)}
        \ControlFlowTok{end}
    \ControlFlowTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
contHist (generic function with 1 method)
\end{verbatim}

\bookmarksetup{startatroot}

\chapter{Indo al√©m de uma dimens√£o
(Matrizes)}\label{indo-aluxe9m-de-uma-dimensuxe3o-matrizes}

At√© o momento trabalhamos com estruturas com mais de uma dimens√£o, mas
sem olharmos muito bem o seu tipo. Nessa aula vamos procurar entender as
diferen√ßas entre elas e como isso pode ser usado ao nosso favor.

Vamos come√ßar com as listas:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v }\OperatorTok{=}\NormalTok{ [}\FloatTok{1}\NormalTok{, }\FloatTok{2}\NormalTok{, }\FloatTok{3}\NormalTok{]}
\FunctionTok{typeof}\NormalTok{(v)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Vector{Int64} (alias for Array{Int64, 1})
\end{verbatim}

O tipo devolvido √©: Vector\{Int64\} (alias for Array\{Int64, 1\}). No
caso isso significa que v √© um vetor de inteiros, ou um array de uma
dimens√£o. Da mesma forma

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v }\OperatorTok{=} \FunctionTok{zeros}\NormalTok{(}\DataTypeTok{Int64}\NormalTok{, }\FloatTok{3}\NormalTok{)}
\FunctionTok{typeof}\NormalTok{(v)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Vector{Int64} (alias for Array{Int64, 1})
\end{verbatim}

Mas, vetores podem ser mais flex√≠veis, como por exemplo abaixo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{v }\OperatorTok{=}\NormalTok{ [}\FloatTok{1}\NormalTok{, }\FloatTok{2.0}\NormalTok{, }\StringTok{"tr√™s"}\NormalTok{]}
\FunctionTok{typeof}\NormalTok{(v)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Vector{Any} (alias for Array{Any, 1})
\end{verbatim}

Nesse caso o tipo de vetor, deixa de ser de inteiros e passa a ser
``Any'', ou seja Vector\{Any\} (alias for Array\{Any, 1\}).

Mais ainda, imaginem a seguinte situa√ß√£o:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a }\OperatorTok{=}\NormalTok{ [}\FloatTok{1}\NormalTok{, }\FloatTok{2}\NormalTok{, }\FloatTok{3}\NormalTok{]}
\FunctionTok{push!}\NormalTok{(v, a)}
\FunctionTok{typeof}\NormalTok{(v)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Vector{Any} (alias for Array{Any, 1})
\end{verbatim}

Nesse caso, o vetor continua sendo do tipo Any, mas na quarta posi√ß√£o
temos um vetor com tr√™s inteiros. Com isso podemos ver que as estruturas
de vetores podem ser bem flex√≠veis. Mas, apesar disso, quando temos
estruturas de tipos diferentes, com muita flexibilidade, geralmente h√°
alguma penalidade de uso, geralmente no desempenho.

Por outro lado, podemos ter estruturas com mais de uma dimens√£o, no caso
elas s√£o denominadas matrizes. Elas podem ser criadas com a fun√ß√£o zeros
que j√° usamos acima.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m }\OperatorTok{=} \FunctionTok{zeros}\NormalTok{(}\DataTypeTok{Int64}\NormalTok{, }\FloatTok{3}\NormalTok{, }\FloatTok{2}\NormalTok{)}
\FunctionTok{typeof}\NormalTok{(m)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Matrix{Int64} (alias for Array{Int64, 2})
\end{verbatim}

Acima foi criada uma matriz de duas dimens√µes com 3 linhas e duas
colunas. Seus elementos podem se acessados como em um vetor, mas agora
com dois ind√≠ces.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m[}\FloatTok{1}\NormalTok{, }\FloatTok{2}\NormalTok{]  }\OperatorTok{=} \FloatTok{10}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
10
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{imprime}\NormalTok{(m}\OperatorTok{::}\DataTypeTok{Array\{Int64,2\}}\NormalTok{)}
    \FunctionTok{println}\NormalTok{(m)}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
imprime (generic function with 1 method)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{imprime}\NormalTok{(m}\OperatorTok{::}\DataTypeTok{Vector\{Vector\{Int64\}\}}\NormalTok{)}
    \FunctionTok{println}\NormalTok{(m[}\FloatTok{1}\NormalTok{])}
    \FunctionTok{println}\NormalTok{(m[}\FloatTok{2}\NormalTok{])}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
imprime (generic function with 2 methods)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{imprime}\NormalTok{(m}\OperatorTok{::}\DataTypeTok{Vector\{Vector\{Int64\}\}}\NormalTok{)}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in}\NormalTok{ m}
        \FunctionTok{println}\NormalTok{(i)}
    \ControlFlowTok{end}
 \KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
imprime (generic function with 2 methods)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{imprime}\NormalTok{(m}\OperatorTok{::}\DataTypeTok{Vector\{Vector\{Int64\}\}}\NormalTok{)}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in}\NormalTok{ m}
        \ControlFlowTok{for}\NormalTok{ j }\KeywordTok{in}\NormalTok{ m[i]}
            \FunctionTok{println}\NormalTok{(j,}\StringTok{"  "}\NormalTok{)}
        \ControlFlowTok{end}   
    \ControlFlowTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
imprime (generic function with 2 methods)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{imprime}\NormalTok{(m}\OperatorTok{::}\DataTypeTok{Vector\{Vector\{Int64\}\}}\NormalTok{)}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in}\NormalTok{ m}
        \FunctionTok{print}\NormalTok{(}\StringTok{"|"}\NormalTok{)}
        \ControlFlowTok{for}\NormalTok{ j }\KeywordTok{in}\NormalTok{ i}
            \FunctionTok{print}\NormalTok{(j,}\StringTok{"  "}\NormalTok{)}
        \ControlFlowTok{end}
        \FunctionTok{println}\NormalTok{(}\StringTok{"|"}\NormalTok{)   }
    \ControlFlowTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
imprime (generic function with 2 methods)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{imprimeMatriz}\NormalTok{(m}\OperatorTok{::}\DataTypeTok{Matrix\{Int64\}}\NormalTok{)}
    \FunctionTok{println}\NormalTok{(m)}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
imprimeMatriz (generic function with 1 method)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{imprimeMatriz}\NormalTok{(m}\OperatorTok{::}\DataTypeTok{Matrix\{Int64\}}\NormalTok{)}
\NormalTok{    i }\OperatorTok{=} \FloatTok{1}
    \ControlFlowTok{while}\NormalTok{ i }\OperatorTok{\textless{}} \FunctionTok{size}\NormalTok{(m)[}\FloatTok{1}\NormalTok{]}
        \FunctionTok{println}\NormalTok{(m[}\FloatTok{1}\NormalTok{])}
\NormalTok{        i }\OperatorTok{+=} \FloatTok{1}
    \ControlFlowTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
imprimeMatriz (generic function with 1 method)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{imprimeMatriz}\NormalTok{(m}\OperatorTok{::}\DataTypeTok{Matrix\{Int64\}}\NormalTok{)}
\NormalTok{    i }\OperatorTok{=} \FloatTok{1}
    \ControlFlowTok{while}\NormalTok{ i }\OperatorTok{\textless{}} \FunctionTok{size}\NormalTok{(m)[}\FloatTok{1}\NormalTok{]}
\NormalTok{        j }\OperatorTok{=} \FloatTok{1}
        \ControlFlowTok{while}\NormalTok{ j }\OperatorTok{\textless{}} \FunctionTok{size}\NormalTok{(m)[}\FloatTok{2}\NormalTok{]}
            \FunctionTok{print}\NormalTok{(m[i, j], }\StringTok{" "}\NormalTok{)}
\NormalTok{            j }\OperatorTok{+=} \FloatTok{1}
        \ControlFlowTok{end}
        \FunctionTok{println}\NormalTok{()   }
\NormalTok{        i }\OperatorTok{+=} \FloatTok{1}
    \ControlFlowTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
imprimeMatriz (generic function with 1 method)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{preencheMatriz}\NormalTok{(m}\OperatorTok{::}\DataTypeTok{Matrix\{Int64\}}\NormalTok{)}
\NormalTok{    i }\OperatorTok{=} \FloatTok{1}
    \ControlFlowTok{while}\NormalTok{ i }\OperatorTok{\textless{}=} \FunctionTok{length}\NormalTok{(m)}
\NormalTok{        m[i] }\OperatorTok{=} \FunctionTok{rand}\NormalTok{(}\DataTypeTok{Int}\NormalTok{) }\OperatorTok{\%} \FloatTok{10}
\NormalTok{        i }\OperatorTok{+=} \FloatTok{1}
    \ControlFlowTok{end}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
preencheMatriz (generic function with 1 method)
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{criaIdentidate}\NormalTok{(tam}\OperatorTok{::}\DataTypeTok{Int64}\NormalTok{)}
\NormalTok{    m }\OperatorTok{=} \FunctionTok{zeros}\NormalTok{(}\DataTypeTok{Int64}\NormalTok{, tam, tam)}
\NormalTok{    i }\OperatorTok{=} \FloatTok{1}
    \ControlFlowTok{while}\NormalTok{ i }\OperatorTok{\textless{}=}\NormalTok{ tam}
\NormalTok{        m[i, i] }\OperatorTok{=} \FloatTok{1}
    \ControlFlowTok{end}
    \ControlFlowTok{return}\NormalTok{ m  }
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
criaIdentidate (generic function with 1 method)
\end{verbatim}

Opera√ß√µes diretas com matrizes tipo +, - e *

\bookmarksetup{startatroot}

\chapter{Aula de exerc√≠cios sobre
Strings}\label{aula-de-exercuxedcios-sobre-strings}

Nesta aula, vamos explorar fun√ß√µes que manipulam strings e criar testes
para verificar sua corre√ß√£o. Em algumas fun√ß√µes, vamos notar que h√°
diversas formas de se obter o mesmo resultado

\section{1. Concatena√ß√£o de letras}\label{concatenauxe7uxe3o-de-letras}

A primeira fun√ß√£o \texttt{concatena} concatena as primeiras duas e as
√∫ltimas duas letras de uma string.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{concatena}\NormalTok{(s}\OperatorTok{::}\DataTypeTok{String}\NormalTok{)}\OperatorTok{::}\DataTypeTok{String}
    \ControlFlowTok{if} \FunctionTok{length}\NormalTok{(s) }\OperatorTok{\textless{}} \FloatTok{2}
        \ControlFlowTok{return} \StringTok{"Erro: tamanho da string menor do que 2"}
    \ControlFlowTok{end}
\NormalTok{    resposta }\OperatorTok{=}\NormalTok{ s[}\FloatTok{1}\OperatorTok{:}\FloatTok{2}\NormalTok{]}\OperatorTok{*}\NormalTok{s[}\KeywordTok{end}\OperatorTok{{-}}\FloatTok{1}\OperatorTok{:}\KeywordTok{end}\NormalTok{]}
    \ControlFlowTok{return}\NormalTok{ resposta}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
concatena (generic function with 1 method)
\end{verbatim}

Awui utulizamos \texttt{s{[}1:2{]}} para obter as duas primeiras letras
de s, que √© uma forma mais concisa de acessar mais de um √≠ndice de um
objeto. Alternativamente, poder√≠amos acessar esses dois √≠ndices
separadamente com o comando \texttt{s{[}1{]}*s{[}2{]}}.

Para verificar se a fun√ß√£o est√° funcionando corretamente, podemos
utilizar o seguinte teste:

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{using} \BuiltInTok{Test}

\KeywordTok{function} \FunctionTok{testeConcatena}\NormalTok{()}
  \PreprocessorTok{@test} \FunctionTok{concatena}\NormalTok{(}\StringTok{"Ola Bom Dia"}\NormalTok{) }\OperatorTok{==} \StringTok{"Olia"}
  \PreprocessorTok{@test} \FunctionTok{concatena}\NormalTok{(}\StringTok{"oi"}\NormalTok{) }\OperatorTok{==} \StringTok{"oioi"}
  \PreprocessorTok{@test} \FunctionTok{concatena}\NormalTok{(}\StringTok{"tre"}\NormalTok{) }\OperatorTok{==} \StringTok{"trre"}
  \PreprocessorTok{@test} \FunctionTok{concatena}\NormalTok{(}\StringTok{"a"}\NormalTok{) }\OperatorTok{==} \StringTok{"Erro: tamanho da string menor do que 2"}
  \PreprocessorTok{@test} \FunctionTok{concatena}\NormalTok{(}\StringTok{"a123"}\NormalTok{) }\OperatorTok{==} \StringTok{"a123"}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
testeConcatena (generic function with 1 method)
\end{verbatim}

\section{2. Invers√£o de String}\label{inversuxe3o-de-string}

Devemos criar uma fun√ß√£o que interte uma string, retornando os
caracteres na ordem reversa.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{function} \FunctionTok{inverte}\NormalTok{(s}\OperatorTok{::}\DataTypeTok{String}\NormalTok{)}\OperatorTok{::}\DataTypeTok{String}
    \CommentTok{\# Inicializamos uma string vazia}
\NormalTok{    inversa}\OperatorTok{=}\StringTok{""}

    \CommentTok{\# Intervalo de lenght(s) at√© 1, a passos de {-}1}
    \ControlFlowTok{for}\NormalTok{ i }\KeywordTok{in} \FunctionTok{length}\NormalTok{(s)}\OperatorTok{:{-}}\FloatTok{1}\OperatorTok{:}\FloatTok{1}
        \CommentTok{\# Concatena cada caractere na ordem inversa}
\NormalTok{        inversa}\OperatorTok{*=}\NormalTok{s[i]}
    \ControlFlowTok{end}

    \ControlFlowTok{return}\NormalTok{ inversa}
\KeywordTok{end}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
inverte (generic function with 1 method)
\end{verbatim}

Para obter o resultado que desejamos, fazemos um la√ßo \texttt{for} que
itera do √∫ltimo √≠ndice da string, representado por \texttt{length(s)},
at√© o primeiro, concatenando os caracteres nessa ordem na string de
retorno. O la√ßo √© configurado para decrementar o √≠ndice a cada itera√ß√£o,
especificando -1 como passo. Isso nos permite acessar cada caractere da
string de tr√°s para frente. E em cada itera√ß√£o, concatenamos o caractere
atual, \texttt{s{[}i{]}}, √† string \texttt{inversa}. Dessa forma, os
caracteres s√£o adicionados na ordem inversa.




\end{document}
