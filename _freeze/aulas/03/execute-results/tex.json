{
  "hash": "4743872be120018651727a46d7bdff59",
  "result": {
    "engine": "julia",
    "markdown": "---\nengine: julia\n---\n\n\n# Usando o Interpretador (REPL) como Calculadora\n\nObjetivo: Ver o interpretador de Julia como uma calculadora poderosa, introduzir a no√ß√£o de vari√°veis.\n\n## Come√ßando com o modo interativo do Julia\n\nQuem quiser j√° pode instalar o ambiente de programa√ß√£o, usem esse [link](https://julialang.org/). H√° tamb√©m alguns ambientes que permitem o uso da linguagem no seu navegador, sugiro a busca pelas palavras chave `Julia Language online`.\n\nDentro do Julia (ap√≥s chamar julia na linha de comando), vamos come√ßar com contas com n√∫meros inteiros:\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n1 + 2\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n3\n```\n:::\n:::\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n40 * 4\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n160\n```\n:::\n:::\n\n\n\n\n\nSim, como era de se esperar, podemos em Julia usar os operandos: `+`, `-` e `*`, o resultado ser√° como o esperado. Vejamos a seguir que com a divis√£o fica um pouco diferente:\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\na = 84 \nb = 2\n\n# As vari√°veis a e b s√£o do tipo Int64\n\nresultado = a / b\nprintln(resultado)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n42.0\n```\n:::\n:::\n\n\n\n\n\nNotem que nesse caso, houve uma mudan√ßa de tipos, pois 84 e 2 s√£o inteiros e o resultado √© um n√∫mero em ponto flutuante (float), podemos ver isso, pois ao inv√©s de 42, tivemos como resultado 42.0.\n\nTamb√©m √© poss√≠vel pedir o resultado inteiro usando o operador `div`:\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\ndiv(84,2)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n42\n```\n:::\n:::\n\n\n\n\n\nOu de forma equivalente usando o operador `\\div` (para conseguir ver o s√≠mbolo da divis√£o √© necess√°rio digitar `\\div` seguido da tecla `<tab>`).\n\nAl√©m das contas b√°sicas, tamb√©m d√° para fazer a exponencia√ß√£o:\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n2^31\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2147483648\n```\n:::\n:::\n\n\n\n\n\nExpress√µes mais complexas tamb√©m podem ser calculadas:\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n23 + 2 * 2 + 3 * 4\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n39\n```\n:::\n:::\n\n\n\n\n\nSim, a preced√™ncia de operadores usual tamb√©m √© v√°lida em Julia. Mas, segue a primeira li√ß√£o de programa√ß√£o: *Escreva para humanos, n√£o para m√°quinas*.\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n23 + (2 * 2) + (3 * 4)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n39\n```\n:::\n:::\n\n\n\n\n\nEm Julia tamb√©m podemos fazer opera√ß√µes com n√∫meros em ponto flutuante:\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n23.5 * 3.14\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n73.79\n```\n:::\n:::\n\n\n\n\n\nou\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n12.5 / 2.0\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n6.25\n```\n:::\n:::\n\n\n\n\n\nAcima temos mais um exemplo de c√≥digo escrito para pessoas, ao se escrever 2.0 estamos deixando claro que o segundo par√¢metro √© um n√∫mero float.\n\n√â importante saber que n√∫meros em ponto flutuante tem precis√£o limitada, logo n√£o se espante com resultados inesperados como abaixo:\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n1.2 - 1.0\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n0.19999999999999996\n```\n:::\n:::\n\n\n\n\n\nErros como esse s√£o bastante raros, tanto que usualmente confiamos plenamente nas contas feitas com computadores e calculadoras. Mas, √© bom saber que existem limita√ß√µes.\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n2.6 - 0.7 - 1.9\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2.220446049250313e-16\n```\n:::\n:::\n\n\n\n\n\nou\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n0.1 + 0.2\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n0.30000000000000004\n```\n:::\n:::\n\n\n\n\n\nou ainda\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n10e15 + 1 - 10e15\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n0.0\n```\n:::\n:::\n\n\n\n\n\nEsses problemas de precis√£o est√£o ligados a limita√ß√£o de como os n√∫meros s√£o representados no computador. De maneira simplificada, os valores no computador s√£o codificados em palavras, formadas por bits. Nos computadores modernos as palavras tem 64 bits, ou 8 bytes. Logo, uma outra limita√ß√£o est√° ligada aos n√∫meros inteiros muito grandes\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n2^63\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n-9223372036854775808\n```\n:::\n:::\n\n\n\n\n\nMas, para um curso introdut√≥rio basta saber que existem essas limita√ß√µes. Como lidar com elas √© parte de um curso mais avan√ßado.\n\n√â importante notar que o erro acima √© um *erro silencioso*, ou seja quanto estamos usando n√∫meros inteiros, pode ocorrer que o n√∫mero a ser representado n√£o caiba no n√∫mero de bits dispon√≠vel, o que faz com que ocorra um erro.\n\nVoltando para as contas. Um outro operador interessante √© o `%` que faz o resto da divis√£o\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n4 % 3\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n1\n```\n:::\n:::\n\n\n\n\n\nAt√© agora vimos como trabalhar com um √∫nico valor, ou seja, como se fosse no visor de uma calculadora. Mas, √© poss√≠vel ir al√©m. Ao inv√©s de termos teclas de mem√≥ria, o computador nos oferece vari√°veis. Elas s√£o como nomes para valores que queremos guardar e usar mais tarde.\n\nAl√©m das opera√ß√µes b√°sicas tamb√©m temos as opera√ß√µes matem√°ticas (fun√ß√µes), como por exemplo o seno, sin em ingl√™s. Para saber como uma fun√ß√£o funciona podemos pedir ajuda ao ambiente, usando uma `?` ou o macro `@doc`, e em seguida digitando o que queremos saber, como por exemplo em:\n\n\n\n::: {.cell execution_count=0}\n``` {.julia .cell-code}\n@doc sin\n```\n:::\n\n\n\n\n\nA sa√≠da desse comando indica a opera√ß√£o que a fun√ß√£o realiza e ainda apresenta alguns exemplos: \n\n```\n  sin(x)\n\n  Compute sine of x, where x is in radians.\n\n  See also sind, sinpi, sincos, cis, asin.\n\n  Examples\n  ‚â°‚â°‚â°‚â°‚â°‚â°‚â°‚â°\n\n  julia> round.(sin.(range(0, 2pi, length=9)'), digits=3)\n  1√ó9 Matrix{Float64}:\n   0.0  0.707  1.0  0.707  0.0  -0.707  -1.0  -0.707  -0.0\n```\n\n\nAmbos os comandos `? sin` `@doc sin` possuem a mesma sa√≠da.\n\n\nNotem que nem tudo que foi apresentado faz sentido no momento, mas j√° d√° para entender o uso de uma fun√ß√£o como sin. Vejamos agora a raiz quadrada:\n\n\n\n::: {.cell execution_count=0}\n``` {.julia .cell-code}\n@doc sqrt\n```\n:::\n\n\n\n\n\nNela vemos que √© poss√≠vel calcular a raiz como em:\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nsqrt(4)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2.0\n```\n:::\n:::\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nsqrt(4.0)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2.0\n```\n:::\n:::\n\n\n\n\n\nMas, observamos tamb√©m na documenta√ß√£o a fun√ß√£o `big()`, que tem a seguinte ajuda:\n\n\n\n::: {.cell execution_count=0}\n``` {.julia .cell-code}\n@doc BigInt\n```\n:::\n\n\n\n\n\nA fun√ß√£o `big()` em Julia √© usada para criar n√∫meros inteiros grandes, representados pelo tipo BigInt. Essa fun√ß√£o √© especialmente √∫til quando voc√™ precisa lidar com n√∫meros muito grandes que excedem o limite dos tipos inteiros padr√£o, como Int64 ou Int32.\n\nCom n√∫meros BigInt, j√° n√£o h√° problemas de estouro, como podemos ver abaixo:\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nbig(2) ^ 1002\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n42860344287450692837937001962400072422456192468221344297750015534814042044997444899727935152627834325103786916702125873007485811427692561743938310298794299215738271099296923941684298420249484567511816728612185899934327765069595070236662175784308251658284785910746168670641719326610497547348822672277504\n```\n:::\n:::\n\n\n\n\n\n\nPodemos ainda carregar fun√ß√µes de outros arquivos em nosso arquivo Julia ou no pr√≥prio terminal, para isso basta utilizar o comando `include(\"caminho/do/arquivo.jl\")`, Julia l√™ o arquivo especificado e executa todo o seu conte√∫do no contexto atual. Isso significa que todas as fun√ß√µes, vari√°veis e defini√ß√µes no arquivo tornam-se dispon√≠veis no ambiente onde `include` foi chamado.\n\nComo por exemplo no primeiro caso tenho um arquivo chamado `funcoes.jl` que possui a fun√ß√£o soma:\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction ola(nome)\n    println(\"Ol√°\", nome)\nend\n\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nola (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\nPodemos incluir essa fun√ß√£o em um segundo arquivo utilizando o `include(\"funcoes.jl\")`, e utilizar a fun√ß√£o definida no arquivo `funcoes.jl`\n\n```\n    include(\"funcoes.jl\")\n    println(ola(\"Alfredo\"))  \n```\n\nCuja sa√≠da dever√° ser `Ol√° Alfredo`.\n\n## Vari√°veis e seus tipos\n\nEm Julia tamb√©m temos o conceito de vari√°veis, que servem para armazenar os diferentes conte√∫dos de dados poss√≠veis.\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\na = 7\n2 + a\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n9\n```\n:::\n:::\n\n\n\n\n\n\n### Tipagem din√¢mica\n\n√â importante notar que as vari√°veis em Julia podem receber novos valores e o tipo da vari√°vel depende do que foi atribu√≠do por √∫ltimo.\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\na = 3\ntypeof(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nInt64\n```\n:::\n:::\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\na = a + 1\ntypeof(a)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nInt64\n```\n:::\n:::\n\n\n\n\n\nNeste pr√≥ximo exemplo, a vari√°vel b √© inicializada com um valor de tipo inteiro, contudo, ap√≥s a opera√ß√£o de multiplica√ß√£o, seu valor √© do tipo ponto flutuante:\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nb = 3\nb = b * 0.5\ntypeof(b)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nFloat64\n```\n:::\n:::\n\n\n\n\n\nA tipagem din√¢mica apresenta diversas vantagens, entre elas a flexibilidade, pois √© poss√≠vel reutilizar vari√°veis para armazenar diferentes tipos de dados ao longo do tempo; e menos verbosidade, pois n√£o √© necess√°rio especificar o tipo de cada vari√°vel, o que melhora a legibilidade do c√≥digo.\n\nAproveitando o momento, podemos ver que h√° v√°rios tipos primitivos em Julia, sendo os principais:\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\ntypeof(1)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nInt64\n```\n:::\n:::\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\ntypeof(1.1)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nFloat64\n```\n:::\n:::\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\ntypeof(\"Bom dia\")\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nString\n```\n:::\n:::\n\n\n\n\n\nFalando em Strings, elas s√£o definidas por conjuntos de caracteres entre aspas como:\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\ns1 = \"Olha que legal\"\ns2 = \"Outra String\"\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n\"Outra String\"\n```\n:::\n:::\n\n\n\n\n\nD√° tamb√©m para fazer opera√ß√µes com strings como concatena√ß√£o:\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\ns1 = \"Tenha um\"\ns2 = \" Bom dia\"\ns3 = s1 * s2\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n\"Tenha um Bom dia\"\n```\n:::\n:::\n\n\n\n\n\nOu pot√™ncia:\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\ns = \"Nao vou mais fazer coisas que possam desagradar os meus colegas \"\ns ^ 10\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n\"Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fa\" ‚ãØ 98 bytes ‚ãØ \"s meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas Nao vou mais fazer coisas que possam desagradar os meus colegas \"\n```\n:::\n:::\n\n\n\n\n\nAinda sobre vari√°veis, h√° umas regras com rela√ß√£o aos seus nomes, tem que come√ßar com uma letra (ou com `_`), pode ter d√≠gitos e n√£o pode ser uma palavra reservada. √â bom notar que Julia por ser uma linguagem moderna, aceita nomes de caracteres em unicode, por exemplo o Œî (`\\Delta`):\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nŒî = 2\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2\n```\n:::\n:::\n\n\n\n\n\nMas, a linguagem vai bem al√©m com caracteres de animais e s√≠mbolos:\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nüê± = 5 # \\:cat: <tab>\nüê∂ = 3 # \\:dog: <tab>\nüè† = 20 # \\:house: <tab>\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n20\n```\n:::\n:::\n\n\n\n\n\nIsso n√£o adiciona nada do lado de algoritmos, mas √© poss√≠vel ter vari√°veis bem bonitinhas. A lista de figuras pode ser encontrada [aqui](   ://docs.julialang.org/en/v1/manual/unicode-input/).\n\n## Sa√≠da de dados\nPara fazer sa√≠das usam-se dois comandos, `print()` e o `println()`, sendo que o primeiro n√£o pula linha e o segundo pula.\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nprint(\"Hello \")\nprintln(\"World!\")\nprintln(\"Ola, mundo!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello World!\nOla, mundo!\n```\n:::\n:::\n\n\n\n\n\nPara evitar que se digitem muitos caracteres, por vezes podemos usar \"a√ßucares sint√°ticos\".\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nx = 1\nx = x + 1\nx += 1  # forma equivalente a acima, o mesmo vale para os operadores *, - e /\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n3\n```\n:::\n:::\n\n\n\n\n\nAcima, vimos a forma de se inserir coment√°rios em Julia (sim esses ser√£o ignorados pelo computador).\n\n\nExerc√≠cio:\nFa√ßa o passo a passo para encontrar as ra√≠zes da equa√ß√£o de segundo grau $x^2 - 5 x + 6$, usando\nas v√°riaveis `a`, `b`, `c`, `\\Delta`, `x1` e `x2`. Ap√≥s isso, compare com a solu√ß√£o a seguir:\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n\n# Defini√ß√£o dos coeficientes\na = 1\nb = -5\nc = 6\n\n# C√°lculo do discriminante\ndelta = b^2 - 4 * a * c\n\n# C√°lculo das ra√≠zes\nif delta >= 0\n    x1 = (-b + sqrt(delta)) / (2 * a)\n    x2 = (-b - sqrt(delta)) / (2 * a)\n    println(\"As ra√≠zes s√£o: x1 = $x1 e x2 = $x2\")\nelse\n    println(\"A equa√ß√£o n√£o possui ra√≠zes reais.\")\nend\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAs ra√≠zes s√£o: x1 = 3.0 e x2 = 2.0\n```\n:::\n:::\n\n\n",
    "supporting": [
      "03_files/figure-pdf"
    ],
    "filters": []
  }
}