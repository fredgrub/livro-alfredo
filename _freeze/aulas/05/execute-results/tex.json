{
  "hash": "f9f180712a95f5ad2df6c45c5945bab9",
  "result": {
    "engine": "julia",
    "markdown": "---\nengine: julia\n---\n\n\n\n# Comparações, o comando if e recursão\n\nAntes de falar em desvio (if), vamos ver um novo tipo de variável que foi introduzido\nde forma natural. O tipo booleando, ou seja uma variável que pode valer true\n(verdadeiro) ou false (falso). O seu uso está intimamente ligado ao if.\n\nObservem os seguintes exemplos:\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n2 + 2 == 4\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\ntrue\n```\n:::\n:::\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n3 != 8\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\ntrue\n```\n:::\n:::\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n23 < 24\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\ntrue\n```\n:::\n:::\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n42 <= 44\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\ntrue\n```\n:::\n:::\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n42 < 2\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nfalse\n```\n:::\n:::\n\n\n\n\n\nVale chamar a atenção, como em linguagens de programação o = é usado para\natribuições, para comparações se usa o `==`. Da mesma forma o != é usado como\ndiferente. Esses operadores, em conjunto com o `<`, `<=`, `>` e `>=` nos permitem\ncomparar valores.\n\nSobre as variáveis booleanas vale também observar o seu tipo. Uma explicação mais aprofundada sobre como essas variáveis funcionam será fornecida quando abordarmos os operadores condicionais:\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\ntypeof(2 == 3)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nBool\n```\n:::\n:::\n\n\n\n\n\n\nFinalmente, também podemos negar variáveis booleanas para inverter o seu valor:\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n!true\n!false\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\ntrue\n```\n:::\n:::\n\n\n\n\n\n\n\n\nNessa aula, vamos aprender um novo comando.\nO desvio condicional, através dele é possível alterar o fluxo de execução de um programa. Até o\nmomento não tínhamos comentado isso explicitamente, mas a ordem de execução de instruções segue\na ordem em que elas estão. Vejamos o exemplo abaixo:\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nprintln(\"Oi\")\nprintln(\"um\")\nprintln(\"dois\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOi\num\ndois\n```\n:::\n:::\n\n\n\n\n\n\nA ordem de impressão será Oi, um e dois.\n\nDa mesma forma não temos problema ao executar o código abaixo.\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\ndenominador = 0\ndenominador += 2\n30 / denominador\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n15.0\n```\n:::\n:::\n\n\n\n\n\n\nApesar da variável denominador começar inicialmente com 0, antes de se fazer a\ndivisão, ela estará valendo 2.\n\nComo é de se esperar nem sempre queremos que essa ordem seja respeitada. Observe\no seguinte exemplo:\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\npandemia = true\nprintln(\"Vou sair de casa?\")\nif pandemia == true\n   println(\"Só vou sair de casa se for essencial\")\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nVou sair de casa?\nSó vou sair de casa se for essencial\n```\n:::\n:::\n\n\n\n\n\n\n\n O exemplo acima é claro, se uma condição for verdadeira, o código que\n está no escopo do if (isso é entre a condição e o end) será executado.\n\n Um outro exemplo:\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\ndenominador = 1\nif denominador != 0\n   println(\"sei fazer a divisão se não for por zero\")\n   println(\"o resultado da divisão de 30 por \", denominador, \" é igual a \", 30/denominador)\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nsei fazer a divisão se não for por zero\no resultado da divisão de 30 por 1 é igual a 30.0\n```\n:::\n:::\n\n\n\n\n\n\n\n Situações muito comuns em computação devem ser favorecidas pela linguagem, nesse\ncaso do if, é muito comum termos duas ou mais situações. Nesse sentido em Julia podemos\ntambém ter alternativas como abaixo:\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n pandemia = true\n println(\"Vou sair de casa?\")\n if pandemia == true\n    println(\"Só vou sair de casa se for essencial\")\n else\n    println(\"Balada liberada!!\")\n end\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nVou sair de casa?\nSó vou sair de casa se for essencial\n```\n:::\n:::\n\n\n\n\n\n\n\nNo caso de termos mais de uma altenativa, não basta termos só uma condição,\nnesse caso temos que usar elseif.\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\npandemia = true\ntenhoqueestudar = true\nprintln(\"Vou sair de casa?\")\nif pandemia == true\n  println(\"Só vou sair de casa se for essencial\")\nelseif tenhoqueestudar == true\n  println(\"Melhor ficar em casa\")\nelse\n  println(\"Balada liberada\")\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nVou sair de casa?\nSó vou sair de casa se for essencial\n```\n:::\n:::\n\n\n\n\n\n\n\n Conhecendo o if, agora, escreva uma função que recebe os coeficientes, a, b e c de uma\nequação de segundo grau e imprime as suas raízes reais.\n\n Sim, a forma de se aprender a programar é programando.\n\n\n\nVamos agora a parte mais importante do curso, lembrando que até o momento aprendemos:\n - valores\n - varíaveis e alguns dos seus tipos\n - alguma funções já prontas como div(), typeof(), parse(), string(), println(), sin(), etc\n - como fazer as nossas funções com a palavra reservada function e que termina por end\n - lembrando que a função pode ou não devolver algo através do return\n - lembrando também que uma função pode chamar outra função\n - como mudar o fluxo de execução normal com o if, elseif\n\n## Agora sim: Funções que se chamam\n\nAgora podemos, ir ao tópico principal da aula.\n\nObserve a seguinte função imprime().\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction imprime()\n    println(\"Mensagem positiva\")\n    imprime()\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nimprime (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\nAo ser chamada, o que acontece? O computador fará chamadas seguidas a função, imprimindo\na mensagem, até o momento que ocorra uma limitação de memória. Logo, fazer chamadas onde\numa função se chama, sem controle não é uma boa ideia.\n\nPor outro lado, podemos pensar em uma forma de chamada controlada, onde a\nprópria função decide o momento de parar de se chamar. Para isso, vamos pegar uma\nfunção matemática bem conhecida, o fatorial.\n\nSabemos que 5! = 5.4.3.2.1. Mais, ainda dado um número n, sabemos que n! = n.(n - 1)!\nContinuando, temos que (n - 1)! = (n - 1).(n - 2)! e assim por diante. Para reproduzir\nisso no computador precisamos saber quando parar. Para isso, podemos usar que o fatorial de\nzero é 1, ou 0! = 1. Logo já temos a primeira parte da função:\n\n\n\n::: {.cell execution_count=0}\n``` {.julia .cell-code}\nfunction fatorial(n)\n if n == 0\n   return 1\n else\n   # o que vamos colocar aqui?\nend\n```\n:::\n\n\n\n\n\n\nNo código acima, temos o critério de parada, ou seja quando n for igual a zero,\na resposta será 1. Mas, e se n não for zero. Nesse caso, temos que seguir a fórmula\nda recursão ou seja n.(n - 1)!. Como (n - 1)! pode ser escrito como fatorial(n - 1).\nFicamos com a expressão n * fatorial(n - 1).\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction fatorial(n)\n # Critério de parada: quando n é igual a 0, a recursão termina\n if n == 0\n   return 1\n else\n   return n * fatorial(n - 1) # Chamada recursiva\n end\nend\nfatorial(5)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n120\n```\n:::\n:::\n\n\n\n\n\n\nVamos a um segundo exemplo, a contagem regressiva. Mais uma vez, quando se chega a\nzero, podemos considerar que a contagem terminou. Além disso, a cada número, o próximo\npasso é o número menos 1.\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction contagem(n)\n   if n < 0\n       println(\"Bum!\")\n   else\n       print(n, \" \")\n       contagem(n - 1)\n   end\nend\ncontagem(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5 4 3 2 1 0 Bum!\n```\n:::\n:::\n\n\n\n\n\n\nEssa estrutura é bem poderosa, pois permite que operações sejam executadas um\nnúmero controlado de vezes.  Voltando ao countdown, imagine que ao invés de\nimprimir uma mensagem quiséssemos fazer uma conta com o que será devolvido.\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction soma(n)\n if n > 0\n   return n + soma(n - 1)\n else\n   return 1\n end\nend\n\nsoma(11)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n67\n```\n:::\n:::\n\n\n\n\n\n\nEssa estrutura é bastante poderosa e pode ser usada para o cálculo de produto, nesse\ncaso, a mudança é bem pequena.\n\nDa mesma forma segue um exemplo para o cálculo dos n primeiros elementos da soma\nhârmonica.\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction somaharmonica(atual, n)\n # Caso base: se 'atual' é maior ou igual a 'n'\n if atual >= n\n   # Retorna o recíproco de 'atual' (último termo da soma)\n   return 1.0 / atual\n else\n   # Caso recursivo: soma o recíproco de 'atual' e chama a função para o próximo número\n   return 1.0 / atual + somaharmonica(atual + 1, n)\n end\nend\n\nsomaharmonica(1, 10)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n2.9289682539682538\n```\n:::\n:::\n\n\n",
    "supporting": [
      "05_files/figure-pdf"
    ],
    "filters": []
  }
}