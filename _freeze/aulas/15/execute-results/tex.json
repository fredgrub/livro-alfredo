{
  "hash": "bb095025bd3af9b6350e5fab17858f9f",
  "result": {
    "engine": "julia",
    "markdown": "---\nengine: julia\n---\n\n\n\n# Boas práticas\n\nVamos começar apresentando 3 boas práticas de programação. Na verdade há uma área que \ncuida de desenvolvimento de software, a Engenharia de Software. Vamos a elas:\n\n## Uso de contratos\n\nSempre que possível o código deve ser modular, ou seja estar repartido em arquivos\ne ou funções. Cada tipo de função deve deixar claro quais são os seus parâmetros\ne o que ela devolve.\nIsso pode ser feito usando tipos.\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction fatorial(n::Int64)::Int64\n    if n < 2 \n        return 1\n    else  \n        return n * fatorial(n - 1)\n    end\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nfatorial (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\nCom isso, fica claro o que a função recebe e devolve, e se for enviado um tipo\ndiferente do esperado, temos em erro imediato.\n\n### Boa prática 1: Use tipos\n\n## Testes automatizados\n\nPara evitar que apareçam erros, ou os populates bugs, uma forma eficaz é escrever código \nque verifica o funcionamento do código. Se isso for feito de forma automática, temos os\ntestes automatizados.\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing Test\nfunction testaFat()\n  @test fatorial(3) == 6\n  @test fatorial(5) == 120\n  @test fatorial(1) == 1\n  @test fatorial(0) == 1\n  @test fatorial(4) == 24\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\ntestaFat (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n### Boa prática 2: Sempre que possível faça testes\n\n## Escreva código para humanos, não para computadores\n\nApesar dos computadores serem capazes de ler código nem sempre bem \nformatado, é bem difícil para humanos lerem código de forma não padrão.\nPor isso algumas dicas importantes são:\n\n- Use identação. Com isso, os blocos ficam bem claros e é fácil identificar\nos laços, blocos de if e corpos de função;\n\n- Escolha bem o nome das variáveis e funções, isso ajuda muito quem for ler\no código\n\n- Sempre que você identificar uma possibilidade de melhoria no código,\nimplemente. Ainda melhor se você tiver testes automatizados, para verificar que\na melhoria não quebrou o código.\n\n### Boa prática 3: Escreva código para que outros leiam\n\n\n## Aplicando as boas práticas\n\nVamos agora resolver o seguinte problema, aplicando as práticas acima. \nDada um vetor com números reais, determinar os números que estão no vetor e o \nnúmero de vezes que cada um deles ocorre na mesma. \n\nAo analizar o problema, vemos que temos como entrada um vetor de número reais,\nque pode conter repetições. Para determinar os números que estão no vetor, podemos\nusar um outro vetor de saída. Sendo que o de entrada e o de saída devem ser do \ntipo Float64. Além disso, para o vetor que fornece a quantidade de números temos\num vetor de inteiros. De posse disso, já temos a assinatura da função.\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction contHist(v::Vector{Float64}, el::Vector{Float64}, qtd::Vector{Int64})\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\ncontHist (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\nDe posse dessa assinatura, já podemos escrever os testes.\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction verifica(v::Vector{Float64}, elementos::Vector{Float64}, \n     quant::Vector{Int64})\n     el = Float64[]\n     quan = Int64[]\n     contHist(v, el, quan)\n     if el == elementos && quan == quant\n        return true\n     else\n        return false\n     end\nend\n\nfunction testaLista()\n  @test verifica([1.3, 1.2, 0.0, 1.3], [1.3, 1.2, 0.0], [2, 1, 1])\n  @test verifica([1.0, 1.0, 1.0, 1.0], [1.0], [4])\n  @test verifica([8.3], [8.3], [1])\n  @test verifica([3.14, 2.78, 2.78], [3.14, 2.78], [1, 2])\nend\n\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\ntestaLista (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\nFinalmente, podemos escrever o código. A idea para escrever a solução é simples,\nvamos percorrer o vetor de entrada. Para cada elemento, temos duas possibilidades,\nse ele não tiver aparecido antes, temos que adicionar o número ao vetor saída e \nmarcar 1 ocorrência. Se já apareceu, basta incrementar o número de ocorrências.\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction contHist(v::Vector{Float64}, el::Vector{Float64}, qtd::Vector{Int64})\n    for a in v\n        if a in el\n            i = 1\n            while el[i] != a\n               i += 1\n            end\n            qtd[i] += 1\n        else\n            push!(el, a)\n            push!(qtd, 1)\n        end\n    end\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\ncontHist (generic function with 1 method)\n```\n:::\n:::\n\n\n",
    "supporting": [
      "15_files"
    ],
    "filters": []
  }
}