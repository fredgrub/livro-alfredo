{
  "hash": "6ff8e0693504e49d31b52a65837b2458",
  "result": {
    "engine": "julia",
    "markdown": "---\nengine: julia\n---\n\n\n\n\n# Aula de exercícios sobre Strings\n\nNesta aula, vamos explorar funções que manipulam strings e criar testes para verificar sua correção. Em algumas funções, vamos notar que há diversas formas de se obter o mesmo resultado\n\n## Concatenação de letras\n\nA primeira função `concatena` concatena as primeiras duas e as últimas duas letras de uma string.\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction concatena(s::String)::String\n    if length(s) < 2\n        return \"Erro: tamanho da string menor do que 2\"\n    end\n    resposta = s[1:2]*s[end-1:end]\n    return resposta\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nconcatena (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\nAwui utulizamos `s[1:2]` para obter as duas primeiras letras de s, que é uma forma mais concisa de acessar mais de um índice de um objeto. Alternativamente, poderíamos acessar esses dois índices separadamente com o comando `s[1]*s[2]`.\n\nPara verificar se a função está funcionando corretamente, podemos utilizar o seguinte teste:\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing Test\n\nfunction testeConcatena()\n  @test concatena(\"Ola Bom Dia\") == \"Olia\"\n  @test concatena(\"oi\") == \"oioi\"\n  @test concatena(\"tre\") == \"trre\"\n  @test concatena(\"a\") == \"Erro: tamanho da string menor do que 2\"\n  @test concatena(\"a123\") == \"a123\"\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\ntesteConcatena (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n## Inversão de String \n\nDevemos criar uma função que interte uma string, retornando os caracteres na ordem reversa.\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction inverte(s::String)::String\n    # Inicializamos uma string vazia\n    inversa=\"\"\n\n    # Intervalo de lenght(s) até 1, a passos de -1\n    for i in length(s):-1:1\n        # Concatena cada caractere na ordem inversa\n        inversa*=s[i]\n    end\n\n    return inversa\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\ninverte (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\nPara obter o resultado que desejamos, fazemos um laço `for` que itera do último índice da string, representado por `length(s)`, até o primeiro, concatenando os caracteres nessa ordem na string de retorno. \nO laço é configurado para decrementar o índice a cada iteração, especificando -1 como passo. Isso nos permite acessar cada caractere da string de trás para frente. E em cada iteração, concatenamos o caractere atual, `s[i]`, à string `inversa`. Dessa forma, os caracteres são adicionados na ordem inversa.\n\nAgora podemos criar uma função de teste para verificar o funcionamento da nossa função `inverte`.\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing Test\n\nfunction testeInverte()\n  @test inverte(\"123\") == \"321\"\n  @test inverte(\"x\") == \"x\"\n  @test inverte(\"SOS\") == \"SOS\"\n  @test inverte(\"tres\") == \"sert\"\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\ntesteInverte (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n### Função reverse\n\n\nÉ interessante notar que Julia já fornece uma função chamada `reverse`, que pode ser utilizada para inverter tanto vetores quanto strings. Por exemplo:\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nreversa = reverse(\"exemplo\")\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n\"olpmexe\"\n```\n:::\n:::\n\n\n\n\n\n\nNeste exemplo, a função `reverse` recebe como parâmetro apenas o objeto a ser invertido, mas no caso de vetores, podemos ainda informar exatamente o intervalo que desejamos que seja invertido.\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nvetor = [1, 2, 3, 4, 5]\nreversa = reverse(vetor, 2, 4)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n5-element Vector{Int64}:\n 1\n 4\n 3\n 2\n 5\n```\n:::\n:::\n\n\n\n\n\n\n##  Modificação de String\n\nA terceira função modifica altera uma string que termina com \"ing\" para adicionar \"ly\" ou, caso contrário, adiciona \"ing\". \n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction modifica(s::String)::String\n    if length(s) < 3\n        return \"Erro: tamanho da string menor do que 3\"\n    end\n    \n    if s[end-2:end] == \"ing\"\n        s = s*\"ly\"\n    else    \n        s = s*\"ing\"                \n    end\n\n\n    return s\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nmodifica (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\nNeste exemplo, verificamos manualmente os últimos três caracteres da string s. No entanto, Julia oferece uma função mais prática e legível chamada `endswith`, que podemos usar para simplificar essa verificação.\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction modifica(s::String)::String\n    if length(s) < 3\n        return \"Erro: tamanho da string menor do que 3\"\n    end\n    \n    if endswith(s, \"ing\")\n        s = s*\"ly\"\n    else    \n        s = s*\"ing\"                \n    end\n\n    return s\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nmodifica (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\nVamos então escrever o teste que verifica o correto funcionamento das funções anteriores\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing Test\nfunction testaModifica()\n  @test modifica(\"doing\") == \"doingly\"\n  @test modifica(\"sing\") == \"singly\"\n  @test modifica(\"run\") == \"runing\"\n  @test modifica(\"talk\") == \"talking\"\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\ntestaModifica (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n## Rearranjo de letras \n\nA segunda função `rearranja` recebe uma string e devolve uma string que contém as letras minúsculas primeiro, seguidas pelas letras maiúsculas.\n\nPodemos verificar se uma letra é maiúscula ou minúscula usando a tabela ASCII, que codifica caracteres em números inteiros. Na tabela, as letras maiúsculas estão no intervalo de 65 a 90, e as letras minúsculas no intervalo de 97 a 122.\n\nPara saber mais sobre a tabela ASCII você pode acessar [essa página](https://www.ime.usp.br/~kellyrb/mac2166_2015/tabela_ascii.html).\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction rearranja(s::String)::String\n    maiusculos=\"\"\n    minusculos=\"\"\n\n    for i in 1:length(s)\n        if Int(s[i]) >= 65 && Int(s[i]) <= 90 \n            maiusculos = maiusculos*s[i]\n        elseif Int(s[i]) >= 97 && Int(s[i]) <= 122\n            minusculos = minusculos*s[i]\n        end \n    end\n\n    return minusculos*maiusculos\n     \nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nrearranja (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\nUma abordagem mais legível é utilizar as funções `islowercase` e `isuppercase`, que verificam se uma letra é minúscula ou maiúscula, respectivamente.\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction rearranja(s::String)::String\n    maiusculos=\"\"\n    minusculos=\"\"\n\n    for i in 1:length(s)\n        if isuppercase(s[i]) \n            maiusculos = maiusculos*s[i]\n        elseif islowercase(s[i])\n            minusculos = minusculos*s[i]\n        end \n    end\n\n    return minusculos*maiusculos\n     \nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nrearranja (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\nPodemos então escrever o teste para nossas funções.\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing Test\n\nfunction testaRearranja()\n  @test rearranja1(\"PaRaLelO\") == \"aaelPRLO\"\n  @test rearranja1(\"ELEfantE\") == \"fantELEE\"\n  @test rearranja1(\"Olá\") == \"lO\"\n  @test rearranja1(\"13La2\") == \"aL\"\n  @test rearranja2(\"PaRaLelO\") == \"aaelPRLO\"\n  @test rearranja2(\"ELEfantE\") == \"fantELEE\"\n  @test rearranja2(\"Olá\") == \"láO\"\n  @test rearranja2(\"13La2\") == \"aL\"\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\ntestaRearranja (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n## Encontrar a maior palavra \n\nNossa última função deve receber uma lista de palavras e retornar a maior delas, junto de seu tamanho.\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction maior_palavra(vetor::Vector{String})\n    # Inicialmente, a maoior palavra que encontramos é uma string vazia\n    maior_palavra = \"\"\n    maior_tamanho = 0\n\n    for palavra in vetor\n        #  Verifica se a palavra atual é maior que a maior encontrada até agora\n        if length(palavra) > maior_tamanho \n            maior_palavra = palavra\n            maior_tamanho = length(palavra)\n        end\n    end\n\n    return maior_palavra, maior_tamanho\n\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nmaior_palavra (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\nApesar de parecer correto, esse código não lida com o caso de haver mais de uma palavra com o maior tamanho. Como por exemplo:\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nvetor = [\"boa\", \"bem\", \"oi\"]\nmaior_palavra(vetor)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n(\"boa\", 3)\n```\n:::\n:::\n\n\n\n\n\n\nNesse caso, apenas a palavra \"boa\" será retornada, mesmo que \"bem\" tenha o mesmo tamanho. Para consertar a função devemos alterar a variável em que guardamos a maior palavra, para que possamos armazenar mais de uma palavra, para isso vamos usar um vetor de strings.\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction maiores_palavras(vetor::Vector{String})\n    maiores_palavras = String[]\n    maior_tamanho = 0\n\n    for palavra in vetor\n        # Se a palavra é maior do que o maior tamanho salvo, \n        # então todas as palavras que estão no vetor maior_palavra são menores do que a palavra atual\n        if length(palavra) > maior_tamanho \n            # Limpa o vetor e salva a palavra atual\n            maiores_palavras = String[]\n            push!(maiores_palavras, palavra)\n            maior_tamanho = length(palavra)\n\n        # Se é igual ao tamanho salvo, então é do mesmo tamanho que as palavras já salvas no vetor maiores_palavras,\n        # apenas damos push na palavra atual\n        elseif length(palavra) == maior_tamanho\n            push!(maiores_palavras, palavra) \n        end\n    end\n\n    return maiores_palavras, maior_tamanho\n\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nmaiores_palavras (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\nAssim podemos escrever testes para esta última função .\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing Test\n\nfunction testeMaioresPalavras()\n    vetor1 = [\"gato\", \"elefante\", \"cachorro\"]\n    @test maiores_palavras(vetor1) == ([\"elefante\", \"cachorro\"], 8)  \n    \n    vetor2 = [\"a\", \"ab\", \"abc\"]\n    @test maiores_palavras(vetor2) == ([\"abc\"], 3)        \n    \n    vetor3 = [\"bem\", \"boa\", \"bom\", \"oi\"]\n    @test maiores_palavras(vetor3) == ([\"bem\", \"boa\", \"bom\"], 3)       \n\n    vetor4 = [\"\", \" \", \"teste\"]\n    @test maiores_palavras(vetor4) == ([\"teste\"], 5)      \n\n    vetor5 = String[]\n    @test maiores_palavras(vetor5) == ([], 0)              \n\n    vetor6 = [\"a\", \"ab\", \"abc\", \"xyz\", \"xy\"]\n    @test maiores_palavras(vetor6) == ([\"abc\", \"xyz\"], 3)  \nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\ntesteMaioresPalavras (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n## Retorno de múltiplos valores\n\nComo visto no exercício anterior, Julia permite que uma função retorne múltiplos valores. Isso permite que você envie mais de um resultado ao chamar uma função, tornando o código mais conciso e fácil de entender. Essa funcionalidade é especialmente útil em situações onde você precisa de mais de um resultado, como em operações matemáticas, decomposições, ou processamento de dados.\n\nPara retornar múltiplos valores em Julia, você pode simplesmente separá-los por vírgulas. Aqui está um exemplo simples:\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction troca(a,b)\n    aux = a\n    a = b\n    b = aux\n\n    return a, b\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\ntroca (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\nAo chamar essa função, você pode capturar os múltiplos valores retornados em variáveis separadas:\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\na, b = troca(1, 10)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n(10, 1)\n```\n:::\n:::\n\n\n",
    "supporting": [
      "17_files/figure-pdf"
    ],
    "filters": []
  }
}