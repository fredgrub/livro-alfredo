{
  "hash": "9d296af9c9c22e8124c07627c7d1bd18",
  "result": {
    "engine": "julia",
    "markdown": "---\nengine: julia\n---\n\n\n\n\n# Revisitando a aula passada\n\nAlém de discutirmos o que vimos na aula passada. Nessa aula,\nvimos uma nova solução para o problema de verificar de um número é\npalíndromo.\n\nPara isso usamos uma técnica um pouco diferente, ou seja, ao invés\nde inverter o número e compará-lo com o original. Verificamos se\nos seus extremos são iguais.\n\nObserve o número 234432, o primeiro passo seria verificar que nos extremos,\nmais significativo e menos significativo, temos os números 2. Em seguida,\npodemos continuar com a verificação para o número 3443. Se em algum momento\na verificação falhar o número não é palíndromo.\n\nSeguem os testes e o código abaixo.\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing Test\n\nfunction testaPal()\n  @test testaPal(1)\n  @test testaPal(131)\n  @test testaPal(22)\n  @test testaPal(53877835)\n  @test !testaPal(123)\n  @test !testaPal(23452)\n  println(\"Final dos testes\")\nend\n\nfunction testaPal(n::Int64)\n# o primeiro passo é encontrar um número com o mesmo número de dígitos de n\n  pot10 = 1\n  while pot10 < n\n    pot10 = pot10 * 10\n  end\n  pot10 = div(pot10, 10)\n\n\n  while n > 9\n    d1 = n % 10\n    d2 = div(n, pot10)\n    if d1 != d2\n      return false\n    end\n    n = div(n % pot10, 10)\n    pot10 = div(pot10, 100)\n  end\n  return true\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\ntestaPal (generic function with 2 methods)\n```\n:::\n:::\n\n\n\n\n\n\n## Aleatoreidade\n\nEm julia temos a função rand() que devolve um número em ponto flutuante entre 0 e 1.\nConforme os parâmetros, podemos ter outros tipos de número como:\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nrand(Int)  # devolve um inteiro\nrand(1:10) # devolve um número entre 1 e 10\nrand(Bool) # devolve verdadeiro ou falso\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nfalse\n```\n:::\n:::\n\n\n\n\n\n\nMas, antes de ver um código com rand(). Vamos pensar em um problema da vida real. Imagine \nque temos que fazer um sorteio justo, e o único instrumento que possuímos para o sorteio\né uma moeda viciada. Que tem como resultado muito mais faces do que coroas. Dá para usar\nessa moeda em um sorteio justo?\n\nA ideia para resolver o problema é olhar para pares de sorteios. Ou seja, vamos ignorar\nsorteios onde tenhamos duas faces ou duas coroas. Nos outros, teremos uma coroa e\numa face ou vice versa. As chances das duas serão de 50%. Logo podemos assim, corrigir a \nmoeda viciada.\n\nPara simplificar o exercício, a moeda pode devolver 0, ou 1, correspondentes\na cara ou a coroa. Observe a seguinte função que simula uma moeda viciada.\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction sorteio()\n  if rand() > 0.90\n    return 1\n  else \n    return 0\n  end\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nsorteio (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\nPode se observar que a função devolve 0 na maior parte das vezes. Podemos\ninclusive ver isso, fazendo mil sorteios:\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction verificaSorteio()\n   cara = 0\n   coroa = 0\n   i = 0\n   while i < 1000\n     if sorteio() == 0\n        cara = cara + 1\n     else\n        coroa = coroa + 1\n     end\n     i = i + 1\n   end\n   println(\"O número de caras foi: \", cara,\" e de coroas foi :\", coroa)\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nverificaSorteio (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\nMas, podemos corrigir o sorteio da seguinte forma:\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction sorteioBom()\n   sorteio1 = sorteio()\n   sorteio2 = sorteio()\n   while sorteio1 == sorteio2 # se forem iguais, tente novamente\n     sorteio1 = sorteio()\n     sorteio2 = sorteio()\n   end\n   return sorteio1   # ao termos um diferente, podemos devolver o primeiro sorteio\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nsorteioBom (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\nPodemos usar o verificaSorteio para ver a diferença.\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction verificaSorteio()\n   cara = 0\n   coroa = 0\n   i = 0\n   while i < 1000\n     if sorteioBom() == 0\n        cara = cara + 1\n     else\n        coroa = coroa + 1\n     end\n     i = i + 1\n   end\n   println(\"O número de caras foi: \", cara,\" e de coroas foi :\", coroa)\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nverificaSorteio (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\nPara terminar a aula vamos aplicar o método de Monte Carlo para o cálculo de Pi.\nImaginem o primeiro quadrante, onde temos um semi-círculo de raio 1, dentro de um\nquadrado de lado 1. Podemos sortear valores, os que sairem dentro do círculo podem\ncontar para a área desse. Mais informações podem ser vistas aqui (https://pt.wikipedia.org/wiki/M%C3%A9todo_de_Monte_Carlo)\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction calculaPi(total)\n   noAlvo = 0\n   i = 0\n   while i < total\n     x = rand() / 2.0 # gera um número entre 0 e 0.5\n     y = rand() / 2.0\n     if sqrt(x * x + y * y) <= 0.5\n       noAlvo = noAlvo + 1\n     end\n     i = i + 1\n   end\n   return 4 * (noAlvo / total)  # precisamos multiplicar para ter a área de 4 quadrantes\nend \n\nprintln(calculaPi(100))\nprintln(calculaPi(1000000))\nprintln(calculaPi(1000000000))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3.08\n3.139292\n3.141422988\n```\n:::\n:::\n\n\n",
    "supporting": [
      "10_files"
    ],
    "filters": []
  }
}