{
  "hash": "c486adc94d3371684db50166ece627f1",
  "result": {
    "engine": "julia",
    "markdown": "---\nengine: julia\n---\n\n\n\n# Revisitando a aula passada\n\nAl√©m de discutirmos o que vimos na aula passada. Nessa aula,\nvimos uma nova solu√ß√£o para o problema de verificar de um n√∫mero √©\npal√≠ndromo.\n\nPara isso usamos uma t√©cnica um pouco diferente, ou seja, ao inv√©s\nde inverter o n√∫mero e compar√°-lo com o original. Verificamos se\nos seus extremos s√£o iguais.\n\nObserve o n√∫mero 234432, o primeiro passo seria verificar que nos extremos,\nmais significativo e menos significativo, temos os n√∫meros 2. Em seguida,\npodemos continuar com a verifica√ß√£o para o n√∫mero 3443. Se em algum momento\na verifica√ß√£o falhar o n√∫mero n√£o √© pal√≠ndromo.\n\nSeguem os testes e o c√≥digo abaixo.\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing Test\n\nfunction testaPal()\n  @test testaPal(1)\n  @test testaPal(131)\n  @test testaPal(22)\n  @test testaPal(53877835)\n  @test !testaPal(123)\n  @test !testaPal(23452)\n  println(\"Final dos testes\")\nend\n\nfunction testaPal(n::Int64)\n# o primeiro passo √© encontrar um n√∫mero com o mesmo n√∫mero de d√≠gitos de n\n  pot10 = 1\n  while pot10 < n\n    pot10 = pot10 * 10\n  end\n  pot10 = div(pot10, 10)\n\n\n  while n > 9\n    d1 = n % 10\n    d2 = div(n, pot10)\n    if d1 != d2\n      return false\n    end\n    n = div(n % pot10, 10)\n    pot10 = div(pot10, 100)\n  end\n  return true\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\ntestaPal (generic function with 2 methods)\n```\n:::\n:::\n\n\n\n\n\n## Aleatoreidade\n\nEm julia temos a fun√ß√£o rand() que devolve um n√∫mero em ponto flutuante entre 0 e 1.\nConforme os par√¢metros, podemos ter outros tipos de n√∫mero como:\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nrand(Int)  # devolve um inteiro\nrand(1:10) # devolve um n√∫mero entre 1 e 10\nrand(Bool) # devolve verdadeiro ou falso\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nfalse\n```\n:::\n:::\n\n\n\n\n\nMas, antes de ver um c√≥digo com rand(). Vamos pensar em um problema da vida real. Imagine \nque temos que fazer um sorteio justo, e o √∫nico instrumento que possu√≠mos para o sorteio\n√© uma moeda viciada. Que tem como resultado muito mais faces do que coroas. D√° para usar\nessa moeda em um sorteio justo?\n\nA ideia para resolver o problema √© olhar para pares de sorteios. Ou seja, vamos ignorar\nsorteios onde tenhamos duas faces ou duas coroas. Nos outros, teremos uma coroa e\numa face ou vice versa. As chances das duas ser√£o de 50%. Logo podemos assim, corrigir a \nmoeda viciada.\n\nPara simplificar o exerc√≠cio, a moeda pode devolver 0, ou 1, correspondentes\na cara ou a coroa. Observe a seguinte fun√ß√£o que simula uma moeda viciada.\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction sorteio()\n  if rand() > 0.90\n    return 1\n  else \n    return 0\n  end\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nsorteio (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\nPode se observar que a fun√ß√£o devolve 0 na maior parte das vezes. Podemos\ninclusive ver isso, fazendo mil sorteios:\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction verificaSorteio()\n   cara = 0\n   coroa = 0\n   i = 0\n   while i < 1000\n     if sorteio() == 0\n        cara = cara + 1\n     else\n        coroa = coroa + 1\n     end\n     i = i + 1\n   end\n   println(\"O n√∫mero de caras foi: \", cara,\" e de coroas foi :\", coroa)\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nverificaSorteio (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\nMas, podemos corrigir o sorteio da seguinte forma:\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction sorteioBom()\n   sorteio1 = sorteio()\n   sorteio2 = sorteio()\n   while sorteio1 == sorteio2 # se forem iguais, tente novamente\n     sorteio1 = sorteio()\n     sorteio2 = sorteio()\n   end\n   return sorteio1   # ao termos um diferente, podemos devolver o primeiro sorteio\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nsorteioBom (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\nPodemos usar o verificaSorteio para ver a diferen√ßa.\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction verificaSorteio()\n   cara = 0\n   coroa = 0\n   i = 0\n   while i < 1000\n     if sorteioBom() == 0\n        cara = cara + 1\n     else\n        coroa = coroa + 1\n     end\n     i = i + 1\n   end\n   println(\"O n√∫mero de caras foi: \", cara,\" e de coroas foi :\", coroa)\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nverificaSorteio (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\nPodemos ainda aproximar o n√∫mero de Euler (ùëí), constante matem√°tica que √© a base dos logaritmos naturais, usando uma simula√ß√£o probabil√≠stica.\nA ideia por tr√°s desse c√≥digo √© que o n√∫mero m√©dio de tentativas necess√°rias para que a soma de n√∫meros aleat√≥rios entre 0 e 1 ultrapasse 1 se aproxima do valor de ùëí. Isso √© baseado em uma rela√ß√£o matem√°tica que conecta essa situa√ß√£o ao n√∫mero ùëí.\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction calculaEuler(total)\n    soma_tentativas = 0\n    for i in 1:total\n        soma = 0.0\n        tentativas = 0      \n        while soma <= 1   # Continue gerando n√∫meros at√© a soma ultrapassar 1\n            soma += rand()     # Gera n√∫mero aleat√≥rio entre 0 e 1\n            tentativas += 1\n        end        \n        soma_tentativas += tentativas     # Somar o n√∫mero de tentativas necess√°rias\n    end \n    return soma_tentativas / total     # A m√©dia do n√∫mero de tentativas ser√° uma estimativa de e\nend\n\nprintln(\"Estimativa de e (1000 itera√ß√µes): \", calculaEuler(1000))\nprintln(\"Estimativa de e (100000 itera√ß√µes): \", calculaEuler(100000))\nprintln(\"Estimativa de e (100000000 itera√ß√µes): \", calculaEuler(100000000))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEstimativa de e (1000 itera√ß√µes): 2.713\nEstimativa de e (100000 itera√ß√µes): 2.71589\nEstimativa de e (100000000 itera√ß√µes): 2.71811446\n```\n:::\n:::\n\n\n\n\n\n\nPara terminar a aula vamos aplicar o m√©todo de Monte Carlo para o c√°lculo de Pi.\nImaginem o primeiro quadrante, onde temos um semi-c√≠rculo de raio 1, dentro de um\nquadrado de lado 1. Podemos sortear valores, os que sairem dentro do c√≠rculo podem\ncontar para a √°rea desse. Mais informa√ß√µes podem ser vistas aqui (https://pt.wikipedia.org/wiki/M%C3%A9todo_de_Monte_Carlo)\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction calculaPi(total)\n   noAlvo = 0\n   i = 0\n   while i < total\n     x = rand() / 2.0 # gera um n√∫mero entre 0 e 0.5\n     y = rand() / 2.0\n     if sqrt(x * x + y * y) <= 0.5\n       noAlvo = noAlvo + 1\n     end\n     i = i + 1\n   end\n   return 4 * (noAlvo / total)  # precisamos multiplicar para ter a √°rea de 4 quadrantes\nend \n\nprintln(calculaPi(100))\nprintln(calculaPi(1000000))\nprintln(calculaPi(1000000000))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3.04\n3.139624\n3.141516436\n```\n:::\n:::\n\n\n",
    "supporting": [
      "10_files/figure-pdf"
    ],
    "filters": []
  }
}