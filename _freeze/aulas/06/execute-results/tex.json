{
  "hash": "6656d522f941a51c6198ed5f63d8c683",
  "result": {
    "engine": "julia",
    "markdown": "---\nengine: julia\n---\n\n\n\n\nNessa aula,  vamos ver  algoritmos um  pouco mais  elaborados. Mas,  sabendo que\nvamos usar algo com um maior grau de sofisticação, que tal pensar em testes?\n\nDe  uma forma  geral, para  verificar o  funcionamento de  um programa,  podemos\nescrever testes que verificam o  funcionamento em algumas situações específicas.\n\nDado que o primeiro problema que queremos resolver é um algoritmo que encontra o\nn-ésimo número de Fibonacci. Por que não começar com testes?\n\nUma forma de se fazr testes, e de forma manual, mas isso não é reprodutível. A\nmelhor maneira de se fazer testes, é de forma automatizada, ou seja criar código\nque teste código. Isso pode parecer complicado, mas vamos ver abaixo que não é.\n\nEm uma  busca rápida,  podemos ver que  a sequência de  Fibonacci é  definida da\nseguinte forma,  os dois primeiros elementos  $F_1$ e $F_2$ valem  1, em seguida\ntemos a fórmula  $F_n = F_{n-1} +  F_{n-2}$. Mas, antes de pensar  em resolver o\nproblema vamos pensar em como testar.\n\nJá  sabemos os  primeiros  valores, além  disso, através  de  uma busca  rápida,\npodemos  descobrir alguns  valores  da sequência  como  $F_5 =  5$  e $F_{12}  =\n144$. Supondo que a função para o cálculo do n-ésimo número de Fibonacci chamará\nfibo(). Podemos escrever o seguinte trecho de código:\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction testafibo_versao1()\n  if fibo(1) == 1\n    println(\"Deu certo para 1\")\n  end\n  if fibo(2) == 1\n    println(\"Deu certo para 2\")\n  end\n  if fibo(5) == 5\n    println(\"Deu certo para 5\")\n  end\n  if fibo(12) == 144\n    println(\"Deu certo para 12\")\n  end\n  println(\"Final dos testes\")\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\ntestafibo_versao1 (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\nA função de testes acima verifica se a função fibo() devolve o resultado correto\npara três casos. Mas, ela tem um defeito, ela imprime mensagens demais, o que\npode ser ruim. Considerando isso, vamos ver o primeiro fundamento importante com\nrelação a testes automatizados.\n\n*Se o teste passou, ele deve indicar apenas que deu certo!*\n\nLevando em conta o que foi escrito acima, podemos mudar o nosso teste para:\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction testafibo()\n  if fibo(1) != 1\n    println(\"Não deu certo para 1\")\n  end\n  if fibo(2) != 1\n    println(\"Não deu certo para 2\")\n  end\n  if fibo(5) != 5\n    println(\"Não eu certo para 5\")\n  end\n  if fibo(12) != 144\n    println(\"Não deu certo para 12\")\n  end\n  println(\"Final dos testes\")\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\ntestafibo (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\nAgora de posse da nossa função de testes, podemos pensar em escrever a nossa função de Fibonacci.\nVamos ao caso fácil de n for menor que 2, a resposta é 1. Como vemos abaixo:\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction fibo(n)\n    if n <= 2\n        return 1\n    else\n        # ainda não sabemos o que colocar aqui...\n    end\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nfibo (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\nMas, a resposta está na própria definição da função, ou seja:  $F_n = F_{n-1} +  F_{n-2}$.\nSe o $n$ for maior do que 2, temos que fazer a soma dos valores de Fibonacci de $n-1$ e de\n$n-2$. Ou seja:\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction fibo(n)\n    if n <= 2\n        return 1\n    else\n        return fibo(n - 1) + fibo(n - 2)\n    end\nend\n\nfibo(10)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n55\n```\n:::\n:::\n\n\n\n\n\nÉ interessante notar que apesar de ser um dos exemplos clássicos de uso de\nrecursão, o algoritmo acima é extremamente ineficiente. A razão é simples, cada\nvez que é feita a chamada, toda os valores de Fibonacci são recalculados para os\nvalores de $n$ e $n-1$.\n\nComo Julia é uma linguagem moderna podemos usar o conceito de Memoização, que evita calcular o que já foi calculado. O Memoize tem que ser instalado no Julia com\nos comandos `import Pkg` e  `Pkg.add(\"Memoize\")`.\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing Memoize\n@memoize function fibo(n)\n    if n <= 2\n        return 1\n    else\n        return fibo(n - 1) + fibo(n - 2)\n    end\nend\n\nfibo(10)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n55\n```\n:::\n:::\n\n\n\n\n\n\nAs diferenças de tempo das duas versões podem ser verificada com o comando @time.\nDa seguinte forma:\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n@time fibo(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  0.000003 seconds\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n55\n```\n:::\n:::\n\n\n\n\n\nEsse tipo de comando, que começa com @ é conhecido como anotação, e tem o poder de\nmudar o comportamente de partes do código.\n\nVamos ao segundo algoritmo da aula, o MDC (Máximo Divisor Comum). A ideia é usar o\nalgoritmo de Euclides.\n\n\nBasicamente ele diz que o MDC de dois números a e b, é igual ao MDC de b e r,\nonde $r=a\\% b$. Quando esse resto for zero, chegamos a solução, que é b.\n\nVamos começar com os testes para alguns valores bem conhecidos. Por sinal começar\npelos testes antes de escrever o código é uma boa prática de programação conhecida por\nTDD (Test Driven Design).\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction testaMDC()\n    if MDC(3298, 2031)!= 1\n        println(\"deu erro, para 3298 e 2031\")\n    end\n    if MDC(120, 36)!= 12\n        println(\"deu erro, para 120 e 36\")\n    end\n    if MDC(36, 120)!= 12\n        println(\"deu erro, para 36 e 120\")\n    end\n    println(\"Acabaram os testes\")\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\ntestaMDC (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\nVamos pensar na função agora. Dessa vez, se o resto for 0, temos que devolver o segundo termo.\nCaso contrário temos que continuar com a regra\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction MDC(a, b)\n    r = a % b\n    if r == 0\n        return b\n    else\n        return MDC(b, r)\n    end\nend\n\ntestaMDC()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAcabaram os testes\n```\n:::\n:::\n\n\n\n\n\n\n\nAté agora usamos o modo interativo do Julia para fazer os nosso códigos. Mas, existe oura forma bem mais\nreutilizável, ou seja escrever o texto em arqivos. Isso é relativamente simples, basta usar um editor de texto\n(puro) da sua preferência, como o notepad, nano, juno, atom, vscode ou outro e salvar um\narquivo com a extensão .jl.\n\nMas, para que algo seja executado é importante colocar uma chamada ao final. Veja abaixo\num possível arquivo mdc.jl.\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction testeMDC()\n    if mdc(70, 5) != 5\n        println(\"Não funcionou para 70 e 5\")\n    end\n    if mdc(13, 7) != 1\n        println(\"Não funcionou para 13 e 7\")\n    end\n    if mdc(127, 15) != 1\n        println(\"Não funcionou para 127 e 15\")\n    end\n    if mdc(20, 15) != 5\n        println(\"Não funcionou para 20 e 15\")\n    end\n    if mdc(42, 3) != 3\n        println(\"Não funcionou para 42 e 3\")\n    end\n    if mdc(42, 8) != 2\n        println(\"Não funcionou para 42 e 8\")\n    end\n    println(\"Final dos testes\")\nend\n\nfunction mdc(a, b)\n    r = a % b\n    if r == 0\n        return b\n    else\n        mdc(b, r)\n    end\nend\n\ntesteMDC()\nprintln(\"O mdc entre 1227 e 321 é \", mdc(1227, 321))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFinal dos testes\nO mdc entre 1227 e 321 é 3\n```\n:::\n:::\n\n\n",
    "supporting": [
      "06_files/figure-pdf"
    ],
    "filters": []
  }
}