{
  "hash": "dfe16dec6a07e046f5248b48eed68889",
  "result": {
    "engine": "julia",
    "markdown": "---\nengine: julia\n---\n\n\n\n# Aula de exercícios\n\n\n\n## Revisitando o cálculo do fatorial, recursivo e interativo\n\nAgora que aprendemos a fazer também repetições com o comando while, sempre é \nbom pensar em qual o comando mais adequado. Vejamos o exemplo abaixo com duas\nversões da função para o cálculo do Fatorial.\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction fatorial_recursivo(n::Int64) # Com o ::Int64 estamos definindo que o parâmetro da função deve ser um número inteiro\n    # Caso base do fatorial: 0! e 1! são iguais a 1\n    if n == 0 || n == 1\n        return 1\n    # Chamada recursiva: n! = n * (n-1)!\n    else\n        return n * fatorial_recursivo(n - 1)\n    end\nend\n\nfunction fatorial_iterativo(n::Int64)\n    # Inicializa o resultado como 1 (já que o fatorial de 0 é 1)\n    resultado = 1\n\n    # No loop estamos fazendo a multiplicação: n * (n-1) * ... * 2\n    while n > 1\n        # Multiplica o resultado pelo valor atual de n\n        resultado *= n\n\n        # Decrementa n em 1 para continuar o cálculo do fatorial\n        n -= 1\n    end\n    return resultado\nend\n\nprintln(fatorial_recursivo(3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n6\n```\n:::\n:::\n\n\n\n\n\nNo código acima temos uma novidade, nos parâmetros da função, o tipo está sendo \ndeclarado expicitamente. No caso, estamos dizendo que o valor n que a função vai \nreceber é de um tipo específico. Ou seja um Inteiro de 64 bits.\n\nO estilo de código está um pouco diferente do que antes, pois foi escrito por\noutra pessoa. A monitora. Vemos que ela tem o hábito de usar nomes de variáveis maiores \nalém do que usar contrações como += e *=.\n\n## Aproximação da raiz quadrada\n\nPara o próximo exemplo, vamos ver o método de Newthon-Raphson para o cálculo\nda raiz quadrada. É um método recursivo no qual o próximo valor é baseado no \nvalor anterior. Quanto mais chamadas forem feitas, mais próximo do valor final\nvai se chegar.\n\nMais informações sobre o método podem ser encontradas em [aqui](https://pt.wikipedia.org/wiki/M%C3%A9todo_de_Newton%E2%80%93Raphson).\nMas para o momento temos que pensar na seguinte implementação. Para se calcular \na raiz, podemos usar a seguinte fórmula, a partir de um palpite inicial r, para\no valor da raiz de x.\n\n$$ r_{n+1} = 0.5 * (r + x / r)$$\n\nComo o código abaixo é mais complicado, foram usados comentários.\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction aproxima_raiz(x::Float64, epsilon::Float64)::Float64\n    if x < 0\n        return nothing\n    end\n\n    # Chute inicial \n    aproximacao = x/2\n    melhor_aproximicao = aproximacao\n\n    while true\n        # Fórmula para aproximação de raiz quadrada utilizando o método de Newthon-Raphson\n        melhor_aproximicao = 0.5 * (aproximacao + x/aproximacao)\n\n        # Se a distância absoluta entre os dois pontos é menor do que epsilon, então podemos parar o método\n        if abs(aproximacao - melhor_aproximicao) <= epsilon\n            break\n        end\n\n        # Se a aproximação ainda não for boa o sufuciente, então atualizamos a aproximação para a próxima iteração\n        aproximacao = melhor_aproximicao\n    end\n\n    return melhor_aproximicao\n\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\naproxima_raiz (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\nNotem que foi introduzido um comando novo, o break, esse comando apenas interrompe a \nexecução do while. Ou seja, força a saída do laço.\n\n## Verificar se um número é primo\n\nNo próximo exemplo, vamos verificar se um número é primo, ou seja, se os seus únicos \ndivisores são 1 e o próprio. A forma mais simples de se fazer isso é procurando \ndividir o número por outros. Se algum dividir, o número não é primo.\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction verifica_primo(num :: Int64)\n    if num <= 1\n        return false\n    end\n    i=2\n    # pode ser melhorado com i<=num/2\n    # ou também com i<= sqrt(num): baseado no fato que um número composto deve ter um fator menor ou igual a raiz desse número\n    while i<num\n        if num % i == 0\n            return false\n        end\n        i+=1\n    end\n    return true\nend\n\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nverifica_primo (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\nAssim, como o comando break é usado para interromper a execução de um laço, o \ncomando return, pode ser usado para terminar a execução de uma função, a qualquer\nmomento.\n\n## Verificar se um número é palíndromo\n\nUm número palíndromo é um número que é simétrico. Ou seja, a leitura dos dígitos \nda esquerda para a direita é igual a leitura dos dígitos na ordem inversa. Por\nexemplo, o número 121 é palíndromo, assim como o 11 e o 25677652. Os números \nde um dígito também são.\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction e_palindromo(n::Int64)\n    #=\n        Guarda os dígitos de n que ainda devem ser invertidos\n        A variável auxiliar é necessária para que o valor de n não seja, perdido, e possamos usar ele posteriormente.\n    =#\n    aux = n\n    # Guarda a inversão do número n \n    n_inv = 0\n\n    #=\n        Continuamos o while enquanto ainda há números a serem invertidos,\n        ou seja, enquanto aux for maior que 0.\n    =#\n    while aux > 0 \n        # Coloca o último dígito de aux na variável que guarda a inversão\n        resto = aux % 10\n        n_inv= n_inv * 10 + resto\n\n        # Retira o último dígito de aux\n        aux = div(aux,10)\n    end\n\n    if n == n_inv\n        println(\"O número $n é palíndromo\")\n    else\n        println(\"O número $n não é palíndromo\")\n    end \nend\n\ne_palindromo(2002)\ne_palindromo(1234)\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nO número 2002 é palíndromo\nO número 1234 não é palíndromo\n```\n:::\n:::\n\n\n",
    "supporting": [
      "09_files/figure-pdf"
    ],
    "filters": []
  }
}