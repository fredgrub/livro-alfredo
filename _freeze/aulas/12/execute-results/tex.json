{
  "hash": "9ef4fdd19654f78443fcde556721c583",
  "result": {
    "engine": "julia",
    "markdown": "---\nengine: julia\n---\n\n\n\n\n# Exercícios com vetores  \n\nOs vetores permitem que sejam realizados algoritmos bem mais complexos, nesse capítulo\nveremos algums exercícios.\n\n## Permutação\n\nDado um vetor com inteiros, queremos verificar se esse vetor contém uma permutação.\nPara isso, temos que verificar em um vetor de tamanho n, se ele contém os números de\n1 a n exatamente uma vez cada 1. O vetor [3, 1, 2] é uma permutação, pois tem tamanho\n3 e os elementos de 1 a 3 aparecem uma vez.\n\nUma forma de se resolver esse problema é por meio de um indicador de passagem. Inicialmente\nvamos supor que o vetor é uma permutação, em seguida verificamos se todos os números entre\n1 e n estão no vetor. Isso pode ser feito com comando in, que verifica se um elemento pertence\nao vetor.\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction permutação(l)\n    perm = true\n    tamanho = length(l)\n    i = 1\n    while i <= tamanho\n        if !(i in l)\n            perm = false\n        end    \n        i += 1\n    end\n    return perm\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\npermutação (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\n\nUma outra alternativa é verificar se para cada elemento do vetor, se ele está entre 1 e n,\ne é unico. Ou seja, verificamos se o primeiro elemento está entre 1 e n, e depois percorremos\no vetor para ver se ele é único. Em seguida fazemos isso para os elementos seguintes.\nO código fica:\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction permutação(l)\n    perm = true\n    tamanho = length(l)\n    i = 1\n    while i <= tamanho\n        if (l[i] > tamanho || l[i] <= 0)\n            perm = false\n        end\n        j = i +1\n        while j <= tamanho\n            if l[j] == l[i]\n                perm = false\n            end\n            j += 1\n        end\n        i += 1\n    end\n    return perm\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\npermutação (generic function with 1 method)\n```\n:::\n:::\n\n\n\n\n\n\nUma outra alternativa é ter um vetor auxiliar onde contamos as ocorrências de cada número entre 1 e n.\nAo final, todos os elementos desse vetor auxiliar tem que valer 1. Dessa vez, aproveitamos e já colocamos\nos testes automatizados.\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing Test\nfunction permutação(l)\n    perm = true\n    tamanho = length(l)\n    aux = zeros(Int8, tamanho)\n    for i in l\n      if i < 1 || i > tamanho\n        perm = false\n      else\n        aux[i] += 1\n      end\n    end\n    for i in aux\n      if i != 1\n        perm = false\n      end\n    end  \n    return perm\nend\n\n@testset \"Verifica Permutação\" begin\n    @test permutação([1,2,3])\n    @test permutação([3, 2, 1])\n    @test permutação([1])\n    @test permutação([2, 1])\n    @test permutação([4, 2, 3, 1])\n    @test !permutação([1, 1])\n    @test !permutação([1, 3])\n    @test !permutação([4, 2, 3, -1])\n    @test !permutação([5, 2, 3, 1])\n    @test permutação([])\n    @test !permutação([0, 3, 3])\n    @test !permutação([2, 2, 2])\nend\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTest Summary:       | Pass  Total  Time\nVerifica Permutação |   12     12  0.1s\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nTest.DefaultTestSet(\"Verifica Permutação\", Any[], 12, false, false, true, 1.729792205835976e9, 1.729792205941158e9, false, \"/workspaces/livro-alfredo/aulas/112.qmd\")\n```\n:::\n:::\n\n\n\n\n\n\n## Histograma\n\nJá que vimos o exemplo anterior onde \"contamos\" o número, podemos ir um pouco além e \ncalcular o histograma de um vetor com números entre 1 e 10.\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing Test\n\nfunction histograma(l)\n    result = [0,0,0,0,0,0,0,0,0,0]\n    i = 1\n    while i <= length(l)\n        valor_atual = l[i]\n        if valor_atual >= 1 && valor_atual <= 10\n           result[valor_atual] += 1\n        end\n        i += 1\n    end\n    return result\nend\n\n@testset \"Verifica Histograma\" begin\n    @test [1,0,0,0,0,0,0,0,0,0] == histograma([1])\n    @test [0,0,0,0,0,0,0,0,0,0] == histograma([-1])\n    @test [0,0,1,0,0,0,0,0,0,0] == histograma([3])\n    @test [0,0,0,0,0,0,0,0,0,1] == histograma([10])\n    @test [0,0,0,0,0,0,0,0,0,0] == histograma([11])\n    @test [1,4,0,2,5,1,0,1,0,0] == histograma([5,6,5,4,5,5,4,2,8,2,1,2,5,2])\n    @test [0,0,0,0,0,0,0,0,0,0] == histograma([])\n    end\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTest Summary:       | Pass  Total  Time\nVerifica Histograma |    7      7  0.1s\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nTest.DefaultTestSet(\"Verifica Histograma\", Any[], 7, false, false, true, 1.729792206375156e9, 1.729792206428047e9, false, \"/workspaces/livro-alfredo/aulas/112.qmd\")\n```\n:::\n:::\n\n\n\n\n\n\n## Modelando problemas com o computador\n\nO computador pode ser uma ferramenta bem poderosa para a modelagem de problemas reais.\nPara isso vamos pegar o caso do problema dos aniversários. Esse problema também é conhecido\npelo paradoxo do aniversário: Calcular a probabilidade de que em uma sala com n pessoas, \npelo menos duas possuam a mesma data de aniversário. Esse problema pode ser resolvido usando \nprobabilidade, por meio da qual se descobre que se a sala tem 23 pessoas a chance de duas\nterem a mesma data é de pouco mais de 50%.\n\nMas, também podemos modelar esse problema computacionalmente. Para isso, o primeiro passo\né simplificar as datas, ao invés de mês e ano, podemos codificar os dias em um número entre\n1 e 365, sendo que 1 corresponderia a primeiro de janeiro. Para resolver o problema, podemos\nsortear n datas, e ver se há alguma repetição, se houver encontramos duas pessoas com a mesma\ndata.\n\nIsso está representado na função experimento_niver abaixo. Mas, para saber a chance real, temos\nque repetr o experimento várias vezes. Na função main() abaixo, pedimos a quantidade de experimentos\ne o número de pessoas para executar a simulação.\n\n\n\n\n\n::: {.cell execution_count=0}\n``` {.julia .cell-code}\nfunction experimento_niver(n)\n    repetiu = false\n    i = 1\n    nivers = []\n    while i <= n && (repetiu == false)\n        niver = rand(1:365)\n        if niver in nivers\n            repetiu = true\n        end\n        push!(nivers, niver)\n        i += 1\n    end\n    return repetiu\nend\n\nfunction main()\n    print(\"Quantos experimentos? \")\n    quantas = readline()\n    print(\"Quantas pessoas? \")\n    npessoas = readline()\n    quantas = parse(Int64, quantas)\n    npessoas = parse(Int64, npessoas)\n    sucessos = 0\n    i = 1\n    while i <= quantas\n        if experimento_niver(npessoas)\n            sucessos += 1\n        end\n        i += 1\n    end\n    println(\"A probabilidade estimada é \", 100*sucessos/quantas, \"%\")\nend\nmain()\n\n```\n:::\n\n\n\n\n\n\nA parte interessante é que podemos com pequenas variações ter outros experimentos, como\nverificar se mais do que duas pessoas fazem aniversário na mesma data. Para isso, abaixo,\ncontamos o número de repetições.\n\n\n\n\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nfunction experimento_niver(n)\n    repetiu = 0\n    i = 1\n    nivers = []\n    while i <= n\n        niver = rand(1:365)\n        if niver in nivers\n            repetiu += 1\n        end\n        push!(nivers, niver)\n        i += 1\n    end\n    return repetiu >= 2\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nexperimento_niver (generic function with 1 method)\n```\n:::\n:::\n\n\n",
    "supporting": [
      "112_files"
    ],
    "filters": []
  }
}